{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/css/blog_basic.styl","path":"css/blog_basic.styl","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/css/font-awesome.css","path":"css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/css/insight.css","path":"css/insight.css","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/css/search.css","path":"css/search.css","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/images/favicon.webp","path":"images/favicon.webp","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/images/gongan.png","path":"images/gongan.png","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/images/logo.webp","path":"images/logo.webp","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/images/logo@2x.webp","path":"images/logo@2x.webp","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/add-bookmark.js","path":"js/add-bookmark.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/baidu-tongji.js","path":"js/baidu-tongji.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/jquery-migrate-1.2.1.min.js","path":"js/jquery-migrate-1.2.1.min.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/jquery.appear.js","path":"js/jquery.appear.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/tagcanvas.js","path":"js/tagcanvas.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/tagcloud.js","path":"js/tagcloud.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/visitors.js","path":"js/visitors.js","modified":0,"renderable":1},{"_id":"source/images/logo.webp","path":"images/logo.webp","modified":0,"renderable":0},{"_id":"source/images/shared_ptr线程安全/dump.png","path":"images/shared_ptr线程安全/dump.png","modified":0,"renderable":0},{"_id":"source/images/local_static/res.png","path":"images/local_static/res.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"535a84862e557086eb83d343c8209ee589d13a38","modified":1662132688903},{"_id":"source/_posts/test.md","hash":"75bbe72dacaf2126838b459152e630b16fc8bf43","modified":1662132659993},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1662127190474},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1662127190476},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1662127190477},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1662127190480},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1662127190480},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1662127190480},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1662127190481},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1662127190489},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1662127190490},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1662127190489},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1662127190489},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1662127190490},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1662127190490},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1662127190490},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1662127190490},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1662127190490},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1662127190490},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1662127190490},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1662127190490},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1662127190485},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1662127190490},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1662127190490},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1662127190490},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1662127190490},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1662127190490},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1662127190485},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1662127190490},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1662127190494},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1662127190494},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1662127190495},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1662127190494},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1662127190494},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1662127190494},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1662127190495},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1662127190494},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1662127190495},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1662127190495},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1662127190490},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1662127190495},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1662127190495},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1662127190495},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1662127190495},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1662127190496},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1662127190502},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1662127190499},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1662127190499},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1662127190499},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1662127190499},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1662127190500},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1662127190499},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1662127190500},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1662127190502},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1662127190502},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1662127190502},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1662127190497},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1662127190495},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1662127190496},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1662127190496},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1662127190496},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1662127190496},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1662127190496},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1662127190503},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1662127190502},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1662127190503},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1662127190503},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1662127190504},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1662127190503},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1662127190503},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1662127190503},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1662127190503},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1662127190504},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1662127190502},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1662127190504},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1662127190502},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1662127190504},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1662127190504},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1662127190504},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1662127190497},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1662127190504},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1662127190504},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1662127190504},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1662127190504},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1662127190504},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1662127190503},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1662127190504},{"_id":"public/2022/09/02/test/index.html","hash":"134bdd9d78cd6346ad300fd1cb6e50e4b22d3b91","modified":1662277517014},{"_id":"public/2022/09/02/hello-world/index.html","hash":"51c0c3c050a794510d8d6f461af3376f20ac6f62","modified":1662277704933},{"_id":"public/archives/index.html","hash":"599c88942ec40d7452354e7580dee7069f210187","modified":1662986475584},{"_id":"public/archives/2022/index.html","hash":"c3d86c0f86cbb34ca4c171263bc967e45bd523c9","modified":1662986475584},{"_id":"public/archives/2022/09/index.html","hash":"4eae6eab2554a18b130992f18fecbfc8b0a2d487","modified":1662986475584},{"_id":"public/index.html","hash":"6293cba6ec7f1afb9aecf3a39db8a355d8f527d5","modified":1662986475584},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1662127486389},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1662127486389},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1662127486389},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1662127486389},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1662127486389},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1662127486389},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1662127486389},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1662127486389},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1662127486389},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1662127486389},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1662127486389},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1662127486389},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1662127486389},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1662127486389},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1662127486389},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1662127486389},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1662127486389},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1662127486389},{"_id":"public/css/style.css","hash":"c0f346d04e643520b1bd77552bd3d723c5a88366","modified":1662132071838},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1662127486389},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1662127486389},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1662127486389},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1662127486389},{"_id":"source/_posts/test1.md","hash":"49e8ebfc4037ecf0c52039b57d11646cfa8215e2","modified":1662132255829},{"_id":"themes/Anatolo/.gitignore","hash":"34d5fc554d9f7f0eb41773e16bd753112d9b9e95","modified":1662272325086},{"_id":"themes/Anatolo/LICENSE","hash":"c6e73f74e331546c7bc59ed16025b1381145e389","modified":1662131863804},{"_id":"themes/Anatolo/README.md","hash":"101f5ada93bc99e7c349d4c62179baf51ca321b7","modified":1662131863804},{"_id":"themes/Anatolo/_config.yml","hash":"652a37b13396c3d17dc3ab7be041b33f272ecacc","modified":1662277238803},{"_id":"themes/Anatolo/package.json","hash":"da1cba3cf5d7e45eb731fed952ce1d0aaccc16bc","modified":1662131863808},{"_id":"themes/Anatolo/languages/en.yml","hash":"bc4f41d20ca49893a3e5373961c8b3e006867d15","modified":1662131863806},{"_id":"themes/Anatolo/languages/pt-BR.yml","hash":"77d0db5442d38eb3c804ec2cd99d7c7461230477","modified":1662131863806},{"_id":"themes/Anatolo/languages/zh-cn.yml","hash":"6f3c966764b1b57ce64b3cec2c515e0df01eca11","modified":1662131863806},{"_id":"themes/Anatolo/layout/archive.pug","hash":"7c9c18beef56e713191da2f76a5320b1bfda86c5","modified":1662131863806},{"_id":"themes/Anatolo/layout/category.pug","hash":"cf9c50a38f21a5a1f3223a06d3c731d211389d1c","modified":1662131863806},{"_id":"themes/Anatolo/layout/index.pug","hash":"57e3b4f9ff332de85c0726fc6f3e7a7882750eff","modified":1662131863806},{"_id":"themes/Anatolo/layout/mixins.pug","hash":"c17a7d51fb25f2629fb3f8a1af89c1e946a900c1","modified":1662131863806},{"_id":"themes/Anatolo/layout/page.pug","hash":"570190249a84b551dc6ac3d4466c9e9deaff0711","modified":1662131863807},{"_id":"themes/Anatolo/layout/post.pug","hash":"e05c8c9cdbed372eb098cfdcebfd17c79ac7f8ff","modified":1662131863807},{"_id":"themes/Anatolo/layout/tag.pug","hash":"cc0b383e1313199e9e8537c610fc6c6023f22a1e","modified":1662131863807},{"_id":"themes/Anatolo/layout/tags.pug","hash":"41208b4d5ca33e171419769605089a012206ca35","modified":1662131863807},{"_id":"themes/Anatolo/scripts/index.js","hash":"116a35be4c2c89ee400bb5453943de2abb676840","modified":1662131863808},{"_id":"themes/Anatolo/includes/generators/insight.js","hash":"c4b981443927b87cc14a3a583029e13f819d6d71","modified":1662131863804},{"_id":"themes/Anatolo/includes/generators/tags.js","hash":"50d939b63fc00a19064c6fe59b6db0f8e140e39d","modified":1662131863805},{"_id":"themes/Anatolo/includes/tasks/welcome.js","hash":"56073b2019bb20b452a123b9dfcbb3678b40517c","modified":1662131863805},{"_id":"themes/Anatolo/includes/helpers/site.js","hash":"221d84f5eca5b91dfd429705d0651067e6d9063a","modified":1662131863805},{"_id":"themes/Anatolo/layout/partial/comments.pug","hash":"de5da9a655717f85f0bdc21f61e569adb16cf4b3","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/footer.pug","hash":"4e3e47701211869b2097e6472278a024b912346d","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/layout.pug","hash":"1311905a9ea1870caf44a97a5296d72b7c131b13","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/head.pug","hash":"8ec73cb945f60b27e9ce9928be31b13e98e18810","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/nav.pug","hash":"fec7b36ee20d387bafc70328677cd63985afbdda","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/search.pug","hash":"342e0f1d5813d448051257c361fa676f45e3f49c","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/sidebar.pug","hash":"08a304b3a640c48fd4c58125d220d3f8dd1f1b08","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/social_links.pug","hash":"234218895422dd915a6d0115b012353d9b37fc62","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/toc.pug","hash":"2bbaab792d5346063d94d18ad1dd5e6dd7903711","modified":1662131863807},{"_id":"themes/Anatolo/source/css/blog_basic.styl","hash":"6036d6b6c44fd29a83732e6800aca163aac86008","modified":1662131863808},{"_id":"themes/Anatolo/source/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1662131863809},{"_id":"themes/Anatolo/source/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1662131863809},{"_id":"themes/Anatolo/source/css/insight.css","hash":"b468a47b30b47017b06ff6c431c49a316288a501","modified":1662131863809},{"_id":"themes/Anatolo/source/css/search.css","hash":"c1cb306e075386517ac15bf4ef37c647d37ec6b5","modified":1662131863809},{"_id":"themes/Anatolo/source/css/style.styl","hash":"c4341430ddecc1e26012af7cbf28e3f87d4414fe","modified":1662131863809},{"_id":"themes/Anatolo/source/images/favicon.webp","hash":"b2c2e853f326a171da7dce74aa45a363a750c359","modified":1662131863818},{"_id":"themes/Anatolo/source/images/gongan.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1662131863818},{"_id":"themes/Anatolo/source/images/logo.webp","hash":"c92aea3812e471d84b173e7c6fcd474787bfd4de","modified":1662133222868},{"_id":"themes/Anatolo/source/images/logo@2x.webp","hash":"c92aea3812e471d84b173e7c6fcd474787bfd4de","modified":1662133373872},{"_id":"themes/Anatolo/source/js/add-bookmark.js","hash":"3cd1622f94f184ca7a542fcbcce75cf9130b9208","modified":1662131863818},{"_id":"themes/Anatolo/source/js/baidu-tongji.js","hash":"49d6d863bc54d843efcc1cd5a92b0e3d65c4bdd6","modified":1662131863818},{"_id":"themes/Anatolo/source/js/insight.js","hash":"16f64c50efc78abb3d94c079d3cda0b74e809f5e","modified":1662131863818},{"_id":"themes/Anatolo/source/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1662131863818},{"_id":"themes/Anatolo/source/js/jquery.appear.js","hash":"1f8067d7bd4c0bde30785e8016100f239e14394f","modified":1662131863818},{"_id":"themes/Anatolo/source/js/tagcanvas.js","hash":"db9a61a79350d1618a74a8f3448f06046c3d9a6c","modified":1662131863821},{"_id":"themes/Anatolo/source/js/tagcloud.js","hash":"cd02ffd8e5192cb25f50f6c5c920a3249ff1614f","modified":1662131863821},{"_id":"themes/Anatolo/source/js/visitors.js","hash":"717a2483ae4d7682d944e79c2a1efd959fa112bc","modified":1662131863821},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1662131863817},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1662131863818},{"_id":"themes/Anatolo/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1662131863811},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1662131863812},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1662131863817},{"_id":"themes/Anatolo/source/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1662131863820},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1662131863815},{"_id":"public/content.json","hash":"4ed3f8900e75c7a8a09b64ec9a8b2971b3a5e31e","modified":1662986475584},{"_id":"public/2022/09/02/test1/index.html","hash":"3b43e7ad2170f193f9606dcc602d452b2074f2dc","modified":1662277517014},{"_id":"public/tags/index.html","hash":"2f2ff3ab4655d86cce93b031c90d4473d02c7d7c","modified":1662986475584},{"_id":"public/images/favicon.webp","hash":"b2c2e853f326a171da7dce74aa45a363a750c359","modified":1662132071838},{"_id":"public/images/gongan.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1662132071838},{"_id":"public/images/logo@2x.webp","hash":"48e26e26b8e4a07d7e5c0a4b3654675cc870f3aa","modified":1662132071838},{"_id":"public/images/logo.webp","hash":"c92aea3812e471d84b173e7c6fcd474787bfd4de","modified":1662291808010},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1662132071838},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1662132071838},{"_id":"public/css/blog_basic.css","hash":"277c08a8a9305ddbe45a5fae2e44d0726d8f2ee1","modified":1662132071838},{"_id":"public/css/insight.css","hash":"b468a47b30b47017b06ff6c431c49a316288a501","modified":1662132071838},{"_id":"public/css/search.css","hash":"c1cb306e075386517ac15bf4ef37c647d37ec6b5","modified":1662132071838},{"_id":"public/js/add-bookmark.js","hash":"3cd1622f94f184ca7a542fcbcce75cf9130b9208","modified":1662132071838},{"_id":"public/js/baidu-tongji.js","hash":"49d6d863bc54d843efcc1cd5a92b0e3d65c4bdd6","modified":1662132071838},{"_id":"public/js/insight.js","hash":"16f64c50efc78abb3d94c079d3cda0b74e809f5e","modified":1662132071838},{"_id":"public/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1662132071838},{"_id":"public/js/jquery.appear.js","hash":"1f8067d7bd4c0bde30785e8016100f239e14394f","modified":1662132071838},{"_id":"public/js/tagcloud.js","hash":"cd02ffd8e5192cb25f50f6c5c920a3249ff1614f","modified":1662132071838},{"_id":"public/js/visitors.js","hash":"717a2483ae4d7682d944e79c2a1efd959fa112bc","modified":1662132071838},{"_id":"public/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1662132071838},{"_id":"public/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1662132071838},{"_id":"public/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1662132071838},{"_id":"public/js/tagcanvas.js","hash":"db9a61a79350d1618a74a8f3448f06046c3d9a6c","modified":1662132071838},{"_id":"public/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1662132071838},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1662132071838},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1662132071838},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1662132071838},{"_id":"public/tags/c/index.html","hash":"ea72d01db6ce7684afe00bc17f7c7fb10ea0e3e9","modified":1662729418731},{"_id":"public/tags/c-2/index.html","hash":"763172b933c364a1d0980dce0e707d1fbd56126b","modified":1662277517014},{"_id":"source/_posts/tvm.md","hash":"1d929f45fc1ec174a10a2c6acbba6339549b70ea","modified":1662290388170},{"_id":"public/2022/09/04/tvm/index.html","hash":"83885ea38ad4d1dd172d40cebb86bbed459dd56d","modified":1662291808010},{"_id":"public/tags/tvm/index.html","hash":"4b28b711b2ba47f2c1c788a5d7d67e7e0efbf8a9","modified":1662734492951},{"_id":"source/_posts/类型萃取.md","hash":"06fafa4d94b155bfd6fcc263782574d8eb4c3957","modified":1662292917600},{"_id":"source/images/logo.webp","hash":"c92aea3812e471d84b173e7c6fcd474787bfd4de","modified":1662133222868},{"_id":"public/2022/09/04/类型萃取/index.html","hash":"959eb58abc687333a05407252659f852118b541e","modified":1662349428652},{"_id":"source/_posts/内存模型1.md","hash":"423b3e9290059b8667b4f7fd9805270e7862f58b","modified":1662349418410},{"_id":"source/_posts/模板偏特化-1.md","hash":"df4ae66de7bc4e85bf82e1f81b4867c483908a4d","modified":1662299605067},{"_id":"source/_posts/模板偏特化.md","hash":"8249f2d877515c01d7d8bac813a7b0cf278543f3","modified":1662349725326},{"_id":"public/2022/09/04/模板偏特化-1/index.html","hash":"31089b3590ed81ee373ede35a38af2b731c2304e","modified":1662349428652},{"_id":"public/2022/09/04/模板偏特化/index.html","hash":"c88c7bf82c960de01088dec656fce95a288eeb11","modified":1662364511575},{"_id":"public/2022/09/05/内存模型1/index.html","hash":"21d98b51940c0d746c116deab3fb519647c37890","modified":1662364511575},{"_id":"source/_posts/shared-ptr线程安全.md","hash":"713f863f46a8b2e9c18ece1c7a94853c2e258cda","modified":1662364500570},{"_id":"source/images/shared_ptr线程安全/dump.png","hash":"4f98cf577e94bc4b998f88448359b2656209d302","modified":1662364425355},{"_id":"public/2022/09/05/shared-ptr线程安全/index.html","hash":"05f4f61c05f94c5901d647b6de8982584bec228c","modified":1662392643609},{"_id":"public/images/shared_ptr线程安全/dump.png","hash":"4f98cf577e94bc4b998f88448359b2656209d302","modified":1662364511575},{"_id":"source/_posts/局部静态对象.md","hash":"2b8877a97054bb69e6d7f28075c4d1905f59108f","modified":1662392638446},{"_id":"source/images/local_static/res.png","hash":"004cdcf7d8ae6d662e88c1d30168d9507543e7a8","modified":1662392477423},{"_id":"public/2022/09/05/局部静态对象/index.html","hash":"745645061e294eb5800d11c6deab8489583579c5","modified":1662557915369},{"_id":"public/images/local_static/res.png","hash":"004cdcf7d8ae6d662e88c1d30168d9507543e7a8","modified":1662392643609},{"_id":"source/_posts/一个可扩展哈希代码阅读.md","hash":"1cc8412a51832bb9616800a7b64948493e62a073","modified":1662557909848},{"_id":"public/archives/page/2/index.html","hash":"181e338e17c2b1012becbd3ec9fefd80630289aa","modified":1662986475584},{"_id":"public/archives/2022/page/2/index.html","hash":"92b0a57a66ed5e5cb14541851f9211a60835c693","modified":1662986475584},{"_id":"public/archives/2022/09/page/2/index.html","hash":"458b52d48905ef3465deed6ccd7edf3de14dfb98","modified":1662986475584},{"_id":"public/page/2/index.html","hash":"ceabd26d9f911c020461726e2c523fe4dd235483","modified":1662986475584},{"_id":"public/tags/小组件/index.html","hash":"ca9d2175da94d059ab655c9742a5b3f70581ec69","modified":1662557915369},{"_id":"public/2022/09/07/一个可扩展哈希代码阅读/index.html","hash":"fed3ed9c25b4abbe0bf8c94f54b51c1594b59ef2","modified":1662565295009},{"_id":"source/_posts/引用折叠.md","hash":"78abe5911810516ea531992af8f4d7051a9df622","modified":1662565290508},{"_id":"public/2022/09/07/引用折叠/index.html","hash":"f26b8d99bf001d31c462c7bc64557f18de84f4fb","modified":1662566644264},{"_id":"source/_posts/函数返回类型后置.md","hash":"f49f01c94334b3e7bbaaa979abc7ca2224517a28","modified":1662566639521},{"_id":"public/2022/09/07/函数返回类型后置/index.html","hash":"1ab998e76f0036205452ceef6cae6eed648d248d","modified":1662729418731},{"_id":"source/_posts/4种c-风格的类型转换.md","hash":"d65d313c2b68c20cbfca3d87db5b8a4bd2b3d6ca","modified":1662729269139},{"_id":"source/_posts/CRTP与静态多态.md","hash":"70729d5039ae2ef7b607b2b7933aef9f6d6c3114","modified":1662686493742},{"_id":"source/_posts/leveldb源码系列1-skiplist.md","hash":"efdcf343deb6a98e08d910306ca8651c2d5c10b6","modified":1662729409710},{"_id":"source/_posts/tvm系列1——te代码阅读.md","hash":"faec63a520c45eb497242c6f16428be40ee8d3a9","modified":1662734475922},{"_id":"public/2022/09/09/4种c-风格的类型转换/index.html","hash":"bb33e50cef6349f4ab426e66372bacc0f741027c","modified":1662729418731},{"_id":"public/2022/09/09/CRTP与静态多态/index.html","hash":"fd9b9e940eb14bb9413d37252bd5b23583f6f65d","modified":1662729418731},{"_id":"public/2022/09/08/tvm系列1——te代码阅读/index.html","hash":"e1e187c41fec3614d9d7e1d83099fe269451aa52","modified":1662734492951},{"_id":"public/tags/leveldb/index.html","hash":"9e885cb4cc6db4c14f5a34d7d57b033a903b8b27","modified":1662729418731},{"_id":"public/2022/09/09/leveldb源码系列1-skiplist/index.html","hash":"79d51f92d12481dd2533a6443efc95892edefe91","modified":1662971082968},{"_id":"source/_posts/effective-modern-c-1-3.md","hash":"31e2e55b509bb7c58fb9646b1f546bc1ce89868c","modified":1662971079209},{"_id":"public/2022/09/12/effective-modern-c-1-3/index.html","hash":"e3aa06171d60661c49cf36840efea8e5df8a4455","modified":1662986475584},{"_id":"public/tags/effective-modern-c/index.html","hash":"a86a1325cbb12af6cafe2277ad2c0eff2888768a","modified":1662986475584},{"_id":"source/_posts/effective-modern-c-4-6.md","hash":"b9b5d9d214a1fd5eb67ef6a8feb09f7892e2c91c","modified":1662986471369},{"_id":"public/2022/09/12/effective-modern-c-4-6/index.html","hash":"2e8a847c51720f968c5048994dbca0d63cddca7e","modified":1662986475584}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"test","date":"2022-09-02T14:04:38.000Z","_content":"","source":"_posts/test.md","raw":"---\ntitle: test\ndate: 2022-09-02 22:04:38\ntags:\n---\n","slug":"test","published":1,"updated":"2022-09-02T14:04:38.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7kjsgzf0000ospv7y772hj6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntags: c+2\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-09-02T15:31:28.907Z","updated":"2022-09-02T15:31:28.903Z","_id":"cl7kjsgzp0001ospv3gja6xid","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"test1","date":"2022-09-02T15:20:43.000Z","_content":"","source":"_posts/test1.md","raw":"---\ntitle: test1\ndate: 2022-09-02 23:20:43\ntags: c++\n---\n","slug":"test1","published":1,"updated":"2022-09-02T15:24:15.829Z","_id":"cl7kmirrs00009kpv6ab995u7","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tvm","date":"2022-09-04T07:38:01.000Z","_content":"\n\nthis is a placeholder for tvm\n下面测试以下图片捏\n![](/images/logo.webp)\n","source":"_posts/tvm.md","raw":"---\ntitle: tvm\ndate: 2022-09-04 15:38:01\ntags: tvm\n---\n\n\nthis is a placeholder for tvm\n下面测试以下图片捏\n![](/images/logo.webp)\n","slug":"tvm","published":1,"updated":"2022-09-04T11:19:48.170Z","_id":"cl7n1867u00007fpv3ge1ad3e","comments":1,"layout":"post","photos":[],"link":"","content":"<p>this is a placeholder for tvm<br>下面测试以下图片捏<br><img src=\"/images/logo.webp\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>this is a placeholder for tvm<br>下面测试以下图片捏<br><img src=\"/images/logo.webp\"></p>\n"},{"layout":"init","title":"类型萃取","date":"2022-09-04T11:26:49.000Z","_content":"\n所谓的类型萃取，就算说在某些函数模板中，它需要知道传进来的变量，它的类型到底是啥，用于返回值这类的，但c++是不允许说推导出返回值类型的，例如以下代码是不可能通过编译的\n`\ntemplate<typename T>\n(*T) func(T t){\n ...\n}\n`\n为了解决这种问题，对于我们自定义的类，可以利用typedef去声明，如下\n~~~\ntemplate<typename T>\nstruct MyIter{\n    typedef T value_type;\n    T * ptr;\n    MyIter(T* p):ptr(p){}\n    T& operator*() { return *ptr; }\n};\ntemplate<typename T>\ntypename T::value_type func(T t){\n    std::cout << *t << std::endl;\n}\n~~~\n这样做当传入类型是MyIter\\<int\\>的时候，首先MyIter的T会实例化为int,func这个函数模板的T会被实例化为MyIter，那么其返回类型也就是int了，这里的typename是告诉编译器，后面的T::value_type 是一个类型（像int，double这种),不加就可能会被当作是成员变量造成歧义。\n那当我们传入的是原生指针呢，上面的自定义对象我们可以直接获取它的成员变量的所指对象，但int * 这种就无法通过T::value_type,因为它根本就没有，所以这个时候就可以利用模板偏特化+trait的技巧了，如下\n~~~\ntemplate\\<typename T\\>\nstruct MyIter{\n    typedef T value_type;\n    T * ptr;\n    MyIter(T* p):ptr(p){}\n    T& operator*() { return *ptr; }\n};\n\ntemplate\\<typename T\\>\nstruct iterator_traits{\n    typedef T::value_type value_type;\n};\n\ntemplate\\<typename T\\>\nstruct iterator_traits\\<T*\\>{\n    typedef  T value_type;\n};\n\ntemplate<typename T>\ntypename iterator_traits<T>::value_type func(T t){\n    std::cout << *t << std::endl;\n~~~\n\n那么当func传进来的是int *的时候，会调用特例化的第2个模板，那么value_type就是int啦，这样做iterator所指类型不管是什么情况都能知道了，\n","source":"_posts/类型萃取.md","raw":"---\nlayout: init\ntitle: 类型萃取\ndate: 2022-09-04 19:26:49\ntags: c++\n---\n\n所谓的类型萃取，就算说在某些函数模板中，它需要知道传进来的变量，它的类型到底是啥，用于返回值这类的，但c++是不允许说推导出返回值类型的，例如以下代码是不可能通过编译的\n`\ntemplate<typename T>\n(*T) func(T t){\n ...\n}\n`\n为了解决这种问题，对于我们自定义的类，可以利用typedef去声明，如下\n~~~\ntemplate<typename T>\nstruct MyIter{\n    typedef T value_type;\n    T * ptr;\n    MyIter(T* p):ptr(p){}\n    T& operator*() { return *ptr; }\n};\ntemplate<typename T>\ntypename T::value_type func(T t){\n    std::cout << *t << std::endl;\n}\n~~~\n这样做当传入类型是MyIter\\<int\\>的时候，首先MyIter的T会实例化为int,func这个函数模板的T会被实例化为MyIter，那么其返回类型也就是int了，这里的typename是告诉编译器，后面的T::value_type 是一个类型（像int，double这种),不加就可能会被当作是成员变量造成歧义。\n那当我们传入的是原生指针呢，上面的自定义对象我们可以直接获取它的成员变量的所指对象，但int * 这种就无法通过T::value_type,因为它根本就没有，所以这个时候就可以利用模板偏特化+trait的技巧了，如下\n~~~\ntemplate\\<typename T\\>\nstruct MyIter{\n    typedef T value_type;\n    T * ptr;\n    MyIter(T* p):ptr(p){}\n    T& operator*() { return *ptr; }\n};\n\ntemplate\\<typename T\\>\nstruct iterator_traits{\n    typedef T::value_type value_type;\n};\n\ntemplate\\<typename T\\>\nstruct iterator_traits\\<T*\\>{\n    typedef  T value_type;\n};\n\ntemplate<typename T>\ntypename iterator_traits<T>::value_type func(T t){\n    std::cout << *t << std::endl;\n~~~\n\n那么当func传进来的是int *的时候，会调用特例化的第2个模板，那么value_type就是int啦，这样做iterator所指类型不管是什么情况都能知道了，\n","slug":"类型萃取","published":1,"updated":"2022-09-04T12:01:57.600Z","_id":"cl7n9mgb0000097pv77cmci4p","comments":1,"photos":[],"link":"","content":"<p>所谓的类型萃取，就算说在某些函数模板中，它需要知道传进来的变量，它的类型到底是啥，用于返回值这类的，但c++是不允许说推导出返回值类型的，例如以下代码是不可能通过编译的<br><code>template&lt;typename T&gt; (*T) func(T t)&#123;  ... &#125;</code><br>为了解决这种问题，对于我们自定义的类，可以利用typedef去声明，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">struct MyIter&#123;</span><br><span class=\"line\">    typedef T value_type;</span><br><span class=\"line\">    T * ptr;</span><br><span class=\"line\">    MyIter(T* p):ptr(p)&#123;&#125;</span><br><span class=\"line\">    T&amp; operator*() &#123; return *ptr; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">typename T::value_type func(T t)&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; *t &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做当传入类型是MyIter&lt;int&gt;的时候，首先MyIter的T会实例化为int,func这个函数模板的T会被实例化为MyIter，那么其返回类型也就是int了，这里的typename是告诉编译器，后面的T::value_type 是一个类型（像int，double这种),不加就可能会被当作是成员变量造成歧义。<br>那当我们传入的是原生指针呢，上面的自定义对象我们可以直接获取它的成员变量的所指对象，但int * 这种就无法通过T::value_type,因为它根本就没有，所以这个时候就可以利用模板偏特化+trait的技巧了，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template\\&lt;typename T\\&gt;</span><br><span class=\"line\">struct MyIter&#123;</span><br><span class=\"line\">    typedef T value_type;</span><br><span class=\"line\">    T * ptr;</span><br><span class=\"line\">    MyIter(T* p):ptr(p)&#123;&#125;</span><br><span class=\"line\">    T&amp; operator*() &#123; return *ptr; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template\\&lt;typename T\\&gt;</span><br><span class=\"line\">struct iterator_traits&#123;</span><br><span class=\"line\">    typedef T::value_type value_type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template\\&lt;typename T\\&gt;</span><br><span class=\"line\">struct iterator_traits\\&lt;T*\\&gt;&#123;</span><br><span class=\"line\">    typedef  T value_type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">typename iterator_traits&lt;T&gt;::value_type func(T t)&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; *t &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>\n\n<p>那么当func传进来的是int *的时候，会调用特例化的第2个模板，那么value_type就是int啦，这样做iterator所指类型不管是什么情况都能知道了，</p>\n","site":{"data":{}},"excerpt":"","more":"<p>所谓的类型萃取，就算说在某些函数模板中，它需要知道传进来的变量，它的类型到底是啥，用于返回值这类的，但c++是不允许说推导出返回值类型的，例如以下代码是不可能通过编译的<br><code>template&lt;typename T&gt; (*T) func(T t)&#123;  ... &#125;</code><br>为了解决这种问题，对于我们自定义的类，可以利用typedef去声明，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">struct MyIter&#123;</span><br><span class=\"line\">    typedef T value_type;</span><br><span class=\"line\">    T * ptr;</span><br><span class=\"line\">    MyIter(T* p):ptr(p)&#123;&#125;</span><br><span class=\"line\">    T&amp; operator*() &#123; return *ptr; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">typename T::value_type func(T t)&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; *t &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做当传入类型是MyIter&lt;int&gt;的时候，首先MyIter的T会实例化为int,func这个函数模板的T会被实例化为MyIter，那么其返回类型也就是int了，这里的typename是告诉编译器，后面的T::value_type 是一个类型（像int，double这种),不加就可能会被当作是成员变量造成歧义。<br>那当我们传入的是原生指针呢，上面的自定义对象我们可以直接获取它的成员变量的所指对象，但int * 这种就无法通过T::value_type,因为它根本就没有，所以这个时候就可以利用模板偏特化+trait的技巧了，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template\\&lt;typename T\\&gt;</span><br><span class=\"line\">struct MyIter&#123;</span><br><span class=\"line\">    typedef T value_type;</span><br><span class=\"line\">    T * ptr;</span><br><span class=\"line\">    MyIter(T* p):ptr(p)&#123;&#125;</span><br><span class=\"line\">    T&amp; operator*() &#123; return *ptr; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template\\&lt;typename T\\&gt;</span><br><span class=\"line\">struct iterator_traits&#123;</span><br><span class=\"line\">    typedef T::value_type value_type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template\\&lt;typename T\\&gt;</span><br><span class=\"line\">struct iterator_traits\\&lt;T*\\&gt;&#123;</span><br><span class=\"line\">    typedef  T value_type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">typename iterator_traits&lt;T&gt;::value_type func(T t)&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; *t &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>\n\n<p>那么当func传进来的是int *的时候，会调用特例化的第2个模板，那么value_type就是int啦，这样做iterator所指类型不管是什么情况都能知道了，</p>\n"},{"layout":"init","title":"内存模型1.md","date":"2022-09-05T02:34:30.000Z","_content":"\nc++的内存模型挺复杂的，因为现代cpu架构的原因，例如cache等，一些操作我们无法得知他具体什么时候会对其他线程可见，例如说thread A写了一个全局变量，但它很有可能是写到自己的私有cache导致说它的这个写对其他thread不可见，那么c++对于这些就提出了一个叫内存模型的玩意。\n首先是顺序一致性模型，它规定有2点：\n1.内存访问执行的顺序与程序指定的顺序相同\n2.所有核心的内存访问实际执行顺序都和程序指定顺序相同\n有1个例子就可以说明这个，一个群聊里，每个人的发言记录的顺序是固定的，不可能说先看到晚发出去的信息，而他所看到的所有人的发言记录，与其他的每个人都一样，都是遵循着某种交叉着的顺序，而且大家观察到的顺序都是一样的，\n而c++默认就是使用这种内存模型，即memory_order_seq_cst,以下面这段代码为例\n~~~\n#include <atomic>\n#include <thread>\n#include <assert.h>\n#include <iostream>\nstd::atomic<bool> x,y;\nstd::atomic<int> z;\nvoid write_x()\n{\n x.store(true,std::memory_order_seq_cst); // 1\n}\nvoid write_y()\n{\n y.store(true,std::memory_order_seq_cst); // 2\n}\nvoid read_x_then_y()\n{\n while(!x.load(std::memory_order_seq_cst));\n if(y.load(std::memory_order_seq_cst)) // 3\n ++z;\n //std::cout << z << std::endl;\n}\nvoid read_y_then_x()\n{\n while(!y.load(std::memory_order_seq_cst));\n if(x.load(std::memory_order_seq_cst)) // 4\n ++z;\n //std::cout << z << std::endl;\n\n}\nint main()\n{\n x=false;\n y=false;\n z=0;\n std::thread a(write_x);\n std::thread b(write_y);\n std::thread c(read_x_then_y);\n std::thread d(read_y_then_x);\n a.join();\n b.join();\n c.join();\n d.join();\n assert(z.load()!=0); // 5\n std::cout << z << std::endl;\n}\n~~~\n\n这里assert永远不会报错，且下一步输出的z有可能是1，有可能是2，下面分别分析：\n如果第1个load是true，但第2个load是false，也就算说它观察到了x的store是先于y的store，或者说在它跳出while的时候，肯定是看到了x的store操作，但y的load还是false，说明它没观察到y的store操作，所以它观察到的所x的store先于y的store，那么对thread d而言，它也必须以这种顺序观察到2个store，所以说thread d的第1个load如果是true了，说明它观察到了y的store，所以它必然已经观察到了x的store，所以它下一步的load必然为true，反过来也同理，这个时候的z就是1了\n而z=2的情况为还不是很明白，假如说a的第一个load到了某个时间点，观察到了x的store，它退出了while，然后它第2个load，观察到了y是true，但这就没办法确定x和y的store的观察顺序了，如果x的store先于y，那么对d而言，它的2个load必然为ture，z=2，如果y的store是先于x的，那么thread d就可能第2个load是false了，此时z=1（这里好像就是第1种情况了？，这里的解释不一定正确）\n\n\n\n\n接下来是acq-rel模型，它解除了对全局一致性的约束，只单纯地利用memory_order_acquire和memory_order_release,前者如果某个load使用则在load之前的指令都不能跨过该语句被重排到后面，后者则是某个store使用则其后语句不能被重排跨到前面\n我们经常利用他们去实现同步操作，但是这里要注意，它无法保证全局一致，也就是说，每个thread观测到的顺序是可能不一样的，如下例子：\n~~~\n#include <atomic>\n#include <thread>\n#include <assert.h>\nstd::atomic<bool> x,y;\nstd::atomic<int> z;\nvoid write_x()\n{\n x.store(true,std::memory_order_release);\n}\nvoid write_y()\n{\n y.store(true,std::memory_order_release);\n}\nvoid read_x_then_y()\n{\n while(!x.load(std::memory_order_acquire));\n if(y.load(std::memory_order_acquire)) // 1\n ++z;\n}\nvoid read_y_then_x()\n{\n while(!y.load(std::memory_order_acquire));\n if(x.load(std::memory_order_acquire)) // 2\n ++z;\n}\nint main()\n{\n x=false;\n y=false;\n z=0;\n std::thread a(write_x);\n std::thread b(write_y);\n std::thread c(read_x_then_y);\n std::thread d(read_y_then_x);\n a.join();\n b.join();\n c.join();\n d.join();\n assert(z.load()!=0); // 3\n}\n~~~\n对于不同thread的对同1个原子变量，acq-rel的语义只能做到——如果在load的时候观察到了store，那么必然就能保证我们需要的同步，如果在load的时候还没观察到store的话就做不到了，如下代码\n~~~\n#include <thread>\n#include <atomic>\n#include <cassert>\n#include <string>\n#include <iostream>\n#include <chrono>\nstd::atomic<std::string*> ptr ;\nint data;\n \nvoid producer()\n{\n    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n    std::string* p  = new std::string(\"Hello\");\n    data = 42;\n    ptr.store(p, std::memory_order_release);\n}\n \nvoid consumer()\n{\n    std::string* p2 = nullptr;\n    //std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n    p2 = ptr.load(std::memory_order_acquire);\n    assert(*p2 == \"Hello\"); // never fires\n    assert(data == 42);\n}\n \nint main()\n{\n    std::thread t1(producer);\n    std::thread t2(consumer);\n    t1.join(); t2.join();\n}\n~~~\n这段代码大多数时候是报错的，因为thread 1 sleep了一段时间，所以在第2个thread中，在它load的时候，第1个thread的store因为sleep的原因未执行，导致了它无法做到同步，所以下面的assert必然报错，但如果修改p2，改成while(!p2=ptr.load(std::memory_order_acquire)),就能实现同步了，因为它会一直在while中循环，直到某1次循环中，它观察到了线程1的store操作，那么这2者的同步语义就能建立起来了——线程1的store之前的语句必然先于store，线程2的load之后的语句必然非先于load，而它跳出循环的时候store必然是已经被观测到了，所以这种同步就建立起来了\n回头看上一段代码，这段代码可能报错的原因就在于，acq-rel语义没有规定全局一致，那么就可能出现thread c观测到x的store先于y的store，而d则反过来，此时他们就都加不了z，或者说我们可以这么理解——全局一致下，c看到了x是true，y只load1次看到是false，说明x的store对d来说也必然先于y的store，而d一直卡在while那里，直到它观测到y是true；但没有全局一致的要求时，以下情况就可能发生——对thread c，它卡在while一段时间退去后，此时它肯定观测到了x的sotre，而它只对y进行了1次load，是false，说明它观测到x的store先于y，但对d而言，没有全局一致的约束，c的观测顺序对它没意义了，它完全可以一直卡在while，直到它观测到y的store，然后在对x进行1次load，发现x的store还没被观察到，对d而言，它是先观测到y后才是x，那么这种矛盾的原因在于，x和y的store它可能是写入内存，而c和d在load的时候，不一定去内存找，它可能直接在自己的cache中找，不一致就来了\n那么怎么修改这段代码呢，很简单，只要保证x和y他们的被观测到的顺序是一样的就可以了，上述由于是分开被2个线程写的原因\n如下\n~~~\n#include <atomic>\n#include <thread>\n#include <assert.h>\nstd::atomic<bool> x,y;\nstd::atomic<int> z;\nvoid write_x_then_y()\n{\n x.store(true,std::memory_order_relaxed); // 1 \n y.store(true,std::memory_order_release); // 2\n}\nvoid read_y_then_x()\n{\n while(!y.load(std::memory_order_acquire)); // 3 自旋，等待y被设置为true\n if(x.load(std::memory_order_relaxed)) // 4\n ++z;\n}\nint main()\n{\n x=false;\n y=false;\n z=0;\n std::thread a(write_x_then_y);\n std::thread b(read_y_then_x);\n a.join();\n b.join();\n assert(z.load()!=0); // 5\n}\n~~~\n这里就不用解释了，但如果说y的load不是while，而是只读1次，那这种同步性就没有了，因为它完全有可能在load之前没有观察到store，加上while，不断的load，直到某1次，发现y被store为true了，这次的load就和store有了先后顺序了，那么就可以保证同步了\n","source":"_posts/内存模型1.md","raw":"---\nlayout: init\ntitle: 内存模型1.md\ndate: 2022-09-05 10:34:30\ntags: c++\n---\n\nc++的内存模型挺复杂的，因为现代cpu架构的原因，例如cache等，一些操作我们无法得知他具体什么时候会对其他线程可见，例如说thread A写了一个全局变量，但它很有可能是写到自己的私有cache导致说它的这个写对其他thread不可见，那么c++对于这些就提出了一个叫内存模型的玩意。\n首先是顺序一致性模型，它规定有2点：\n1.内存访问执行的顺序与程序指定的顺序相同\n2.所有核心的内存访问实际执行顺序都和程序指定顺序相同\n有1个例子就可以说明这个，一个群聊里，每个人的发言记录的顺序是固定的，不可能说先看到晚发出去的信息，而他所看到的所有人的发言记录，与其他的每个人都一样，都是遵循着某种交叉着的顺序，而且大家观察到的顺序都是一样的，\n而c++默认就是使用这种内存模型，即memory_order_seq_cst,以下面这段代码为例\n~~~\n#include <atomic>\n#include <thread>\n#include <assert.h>\n#include <iostream>\nstd::atomic<bool> x,y;\nstd::atomic<int> z;\nvoid write_x()\n{\n x.store(true,std::memory_order_seq_cst); // 1\n}\nvoid write_y()\n{\n y.store(true,std::memory_order_seq_cst); // 2\n}\nvoid read_x_then_y()\n{\n while(!x.load(std::memory_order_seq_cst));\n if(y.load(std::memory_order_seq_cst)) // 3\n ++z;\n //std::cout << z << std::endl;\n}\nvoid read_y_then_x()\n{\n while(!y.load(std::memory_order_seq_cst));\n if(x.load(std::memory_order_seq_cst)) // 4\n ++z;\n //std::cout << z << std::endl;\n\n}\nint main()\n{\n x=false;\n y=false;\n z=0;\n std::thread a(write_x);\n std::thread b(write_y);\n std::thread c(read_x_then_y);\n std::thread d(read_y_then_x);\n a.join();\n b.join();\n c.join();\n d.join();\n assert(z.load()!=0); // 5\n std::cout << z << std::endl;\n}\n~~~\n\n这里assert永远不会报错，且下一步输出的z有可能是1，有可能是2，下面分别分析：\n如果第1个load是true，但第2个load是false，也就算说它观察到了x的store是先于y的store，或者说在它跳出while的时候，肯定是看到了x的store操作，但y的load还是false，说明它没观察到y的store操作，所以它观察到的所x的store先于y的store，那么对thread d而言，它也必须以这种顺序观察到2个store，所以说thread d的第1个load如果是true了，说明它观察到了y的store，所以它必然已经观察到了x的store，所以它下一步的load必然为true，反过来也同理，这个时候的z就是1了\n而z=2的情况为还不是很明白，假如说a的第一个load到了某个时间点，观察到了x的store，它退出了while，然后它第2个load，观察到了y是true，但这就没办法确定x和y的store的观察顺序了，如果x的store先于y，那么对d而言，它的2个load必然为ture，z=2，如果y的store是先于x的，那么thread d就可能第2个load是false了，此时z=1（这里好像就是第1种情况了？，这里的解释不一定正确）\n\n\n\n\n接下来是acq-rel模型，它解除了对全局一致性的约束，只单纯地利用memory_order_acquire和memory_order_release,前者如果某个load使用则在load之前的指令都不能跨过该语句被重排到后面，后者则是某个store使用则其后语句不能被重排跨到前面\n我们经常利用他们去实现同步操作，但是这里要注意，它无法保证全局一致，也就是说，每个thread观测到的顺序是可能不一样的，如下例子：\n~~~\n#include <atomic>\n#include <thread>\n#include <assert.h>\nstd::atomic<bool> x,y;\nstd::atomic<int> z;\nvoid write_x()\n{\n x.store(true,std::memory_order_release);\n}\nvoid write_y()\n{\n y.store(true,std::memory_order_release);\n}\nvoid read_x_then_y()\n{\n while(!x.load(std::memory_order_acquire));\n if(y.load(std::memory_order_acquire)) // 1\n ++z;\n}\nvoid read_y_then_x()\n{\n while(!y.load(std::memory_order_acquire));\n if(x.load(std::memory_order_acquire)) // 2\n ++z;\n}\nint main()\n{\n x=false;\n y=false;\n z=0;\n std::thread a(write_x);\n std::thread b(write_y);\n std::thread c(read_x_then_y);\n std::thread d(read_y_then_x);\n a.join();\n b.join();\n c.join();\n d.join();\n assert(z.load()!=0); // 3\n}\n~~~\n对于不同thread的对同1个原子变量，acq-rel的语义只能做到——如果在load的时候观察到了store，那么必然就能保证我们需要的同步，如果在load的时候还没观察到store的话就做不到了，如下代码\n~~~\n#include <thread>\n#include <atomic>\n#include <cassert>\n#include <string>\n#include <iostream>\n#include <chrono>\nstd::atomic<std::string*> ptr ;\nint data;\n \nvoid producer()\n{\n    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n    std::string* p  = new std::string(\"Hello\");\n    data = 42;\n    ptr.store(p, std::memory_order_release);\n}\n \nvoid consumer()\n{\n    std::string* p2 = nullptr;\n    //std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n    p2 = ptr.load(std::memory_order_acquire);\n    assert(*p2 == \"Hello\"); // never fires\n    assert(data == 42);\n}\n \nint main()\n{\n    std::thread t1(producer);\n    std::thread t2(consumer);\n    t1.join(); t2.join();\n}\n~~~\n这段代码大多数时候是报错的，因为thread 1 sleep了一段时间，所以在第2个thread中，在它load的时候，第1个thread的store因为sleep的原因未执行，导致了它无法做到同步，所以下面的assert必然报错，但如果修改p2，改成while(!p2=ptr.load(std::memory_order_acquire)),就能实现同步了，因为它会一直在while中循环，直到某1次循环中，它观察到了线程1的store操作，那么这2者的同步语义就能建立起来了——线程1的store之前的语句必然先于store，线程2的load之后的语句必然非先于load，而它跳出循环的时候store必然是已经被观测到了，所以这种同步就建立起来了\n回头看上一段代码，这段代码可能报错的原因就在于，acq-rel语义没有规定全局一致，那么就可能出现thread c观测到x的store先于y的store，而d则反过来，此时他们就都加不了z，或者说我们可以这么理解——全局一致下，c看到了x是true，y只load1次看到是false，说明x的store对d来说也必然先于y的store，而d一直卡在while那里，直到它观测到y是true；但没有全局一致的要求时，以下情况就可能发生——对thread c，它卡在while一段时间退去后，此时它肯定观测到了x的sotre，而它只对y进行了1次load，是false，说明它观测到x的store先于y，但对d而言，没有全局一致的约束，c的观测顺序对它没意义了，它完全可以一直卡在while，直到它观测到y的store，然后在对x进行1次load，发现x的store还没被观察到，对d而言，它是先观测到y后才是x，那么这种矛盾的原因在于，x和y的store它可能是写入内存，而c和d在load的时候，不一定去内存找，它可能直接在自己的cache中找，不一致就来了\n那么怎么修改这段代码呢，很简单，只要保证x和y他们的被观测到的顺序是一样的就可以了，上述由于是分开被2个线程写的原因\n如下\n~~~\n#include <atomic>\n#include <thread>\n#include <assert.h>\nstd::atomic<bool> x,y;\nstd::atomic<int> z;\nvoid write_x_then_y()\n{\n x.store(true,std::memory_order_relaxed); // 1 \n y.store(true,std::memory_order_release); // 2\n}\nvoid read_y_then_x()\n{\n while(!y.load(std::memory_order_acquire)); // 3 自旋，等待y被设置为true\n if(x.load(std::memory_order_relaxed)) // 4\n ++z;\n}\nint main()\n{\n x=false;\n y=false;\n z=0;\n std::thread a(write_x_then_y);\n std::thread b(read_y_then_x);\n a.join();\n b.join();\n assert(z.load()!=0); // 5\n}\n~~~\n这里就不用解释了，但如果说y的load不是while，而是只读1次，那这种同步性就没有了，因为它完全有可能在load之前没有观察到store，加上while，不断的load，直到某1次，发现y被store为true了，这次的load就和store有了先后顺序了，那么就可以保证同步了\n","slug":"内存模型1","published":1,"updated":"2022-09-05T03:43:38.410Z","comments":1,"photos":[],"link":"","_id":"cl7o7xgmf0000zepv3hir66l1","content":"<p>c++的内存模型挺复杂的，因为现代cpu架构的原因，例如cache等，一些操作我们无法得知他具体什么时候会对其他线程可见，例如说thread A写了一个全局变量，但它很有可能是写到自己的私有cache导致说它的这个写对其他thread不可见，那么c++对于这些就提出了一个叫内存模型的玩意。<br>首先是顺序一致性模型，它规定有2点：<br>1.内存访问执行的顺序与程序指定的顺序相同<br>2.所有核心的内存访问实际执行顺序都和程序指定顺序相同<br>有1个例子就可以说明这个，一个群聊里，每个人的发言记录的顺序是固定的，不可能说先看到晚发出去的信息，而他所看到的所有人的发言记录，与其他的每个人都一样，都是遵循着某种交叉着的顺序，而且大家观察到的顺序都是一样的，<br>而c++默认就是使用这种内存模型，即memory_order_seq_cst,以下面这段代码为例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;assert.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">std::atomic&lt;bool&gt; x,y;</span><br><span class=\"line\">std::atomic&lt;int&gt; z;</span><br><span class=\"line\">void write_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x.store(true,std::memory_order_seq_cst); // 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void write_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> y.store(true,std::memory_order_seq_cst); // 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_x_then_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!x.load(std::memory_order_seq_cst));</span><br><span class=\"line\"> if(y.load(std::memory_order_seq_cst)) // 3</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\"> //std::cout &lt;&lt; z &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_y_then_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!y.load(std::memory_order_seq_cst));</span><br><span class=\"line\"> if(x.load(std::memory_order_seq_cst)) // 4</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\"> //std::cout &lt;&lt; z &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x=false;</span><br><span class=\"line\"> y=false;</span><br><span class=\"line\"> z=0;</span><br><span class=\"line\"> std::thread a(write_x);</span><br><span class=\"line\"> std::thread b(write_y);</span><br><span class=\"line\"> std::thread c(read_x_then_y);</span><br><span class=\"line\"> std::thread d(read_y_then_x);</span><br><span class=\"line\"> a.join();</span><br><span class=\"line\"> b.join();</span><br><span class=\"line\"> c.join();</span><br><span class=\"line\"> d.join();</span><br><span class=\"line\"> assert(z.load()!=0); // 5</span><br><span class=\"line\"> std::cout &lt;&lt; z &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里assert永远不会报错，且下一步输出的z有可能是1，有可能是2，下面分别分析：<br>如果第1个load是true，但第2个load是false，也就算说它观察到了x的store是先于y的store，或者说在它跳出while的时候，肯定是看到了x的store操作，但y的load还是false，说明它没观察到y的store操作，所以它观察到的所x的store先于y的store，那么对thread d而言，它也必须以这种顺序观察到2个store，所以说thread d的第1个load如果是true了，说明它观察到了y的store，所以它必然已经观察到了x的store，所以它下一步的load必然为true，反过来也同理，这个时候的z就是1了<br>而z=2的情况为还不是很明白，假如说a的第一个load到了某个时间点，观察到了x的store，它退出了while，然后它第2个load，观察到了y是true，但这就没办法确定x和y的store的观察顺序了，如果x的store先于y，那么对d而言，它的2个load必然为ture，z=2，如果y的store是先于x的，那么thread d就可能第2个load是false了，此时z=1（这里好像就是第1种情况了？，这里的解释不一定正确）</p>\n<p>接下来是acq-rel模型，它解除了对全局一致性的约束，只单纯地利用memory_order_acquire和memory_order_release,前者如果某个load使用则在load之前的指令都不能跨过该语句被重排到后面，后者则是某个store使用则其后语句不能被重排跨到前面<br>我们经常利用他们去实现同步操作，但是这里要注意，它无法保证全局一致，也就是说，每个thread观测到的顺序是可能不一样的，如下例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;assert.h&gt;</span><br><span class=\"line\">std::atomic&lt;bool&gt; x,y;</span><br><span class=\"line\">std::atomic&lt;int&gt; z;</span><br><span class=\"line\">void write_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x.store(true,std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void write_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> y.store(true,std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_x_then_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!x.load(std::memory_order_acquire));</span><br><span class=\"line\"> if(y.load(std::memory_order_acquire)) // 1</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_y_then_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!y.load(std::memory_order_acquire));</span><br><span class=\"line\"> if(x.load(std::memory_order_acquire)) // 2</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x=false;</span><br><span class=\"line\"> y=false;</span><br><span class=\"line\"> z=0;</span><br><span class=\"line\"> std::thread a(write_x);</span><br><span class=\"line\"> std::thread b(write_y);</span><br><span class=\"line\"> std::thread c(read_x_then_y);</span><br><span class=\"line\"> std::thread d(read_y_then_x);</span><br><span class=\"line\"> a.join();</span><br><span class=\"line\"> b.join();</span><br><span class=\"line\"> c.join();</span><br><span class=\"line\"> d.join();</span><br><span class=\"line\"> assert(z.load()!=0); // 3</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于不同thread的对同1个原子变量，acq-rel的语义只能做到——如果在load的时候观察到了store，那么必然就能保证我们需要的同步，如果在load的时候还没观察到store的话就做不到了，如下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;cassert&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;chrono&gt;</span><br><span class=\"line\">std::atomic&lt;std::string*&gt; ptr ;</span><br><span class=\"line\">int data;</span><br><span class=\"line\"> </span><br><span class=\"line\">void producer()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::this_thread::sleep_for(std::chrono::milliseconds(1000));</span><br><span class=\"line\">    std::string* p  = new std::string(&quot;Hello&quot;);</span><br><span class=\"line\">    data = 42;</span><br><span class=\"line\">    ptr.store(p, std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">void consumer()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::string* p2 = nullptr;</span><br><span class=\"line\">    //std::this_thread::sleep_for(std::chrono::milliseconds(1000));</span><br><span class=\"line\">    p2 = ptr.load(std::memory_order_acquire);</span><br><span class=\"line\">    assert(*p2 == &quot;Hello&quot;); // never fires</span><br><span class=\"line\">    assert(data == 42);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::thread t1(producer);</span><br><span class=\"line\">    std::thread t2(consumer);</span><br><span class=\"line\">    t1.join(); t2.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码大多数时候是报错的，因为thread 1 sleep了一段时间，所以在第2个thread中，在它load的时候，第1个thread的store因为sleep的原因未执行，导致了它无法做到同步，所以下面的assert必然报错，但如果修改p2，改成while(!p2=ptr.load(std::memory_order_acquire)),就能实现同步了，因为它会一直在while中循环，直到某1次循环中，它观察到了线程1的store操作，那么这2者的同步语义就能建立起来了——线程1的store之前的语句必然先于store，线程2的load之后的语句必然非先于load，而它跳出循环的时候store必然是已经被观测到了，所以这种同步就建立起来了<br>回头看上一段代码，这段代码可能报错的原因就在于，acq-rel语义没有规定全局一致，那么就可能出现thread c观测到x的store先于y的store，而d则反过来，此时他们就都加不了z，或者说我们可以这么理解——全局一致下，c看到了x是true，y只load1次看到是false，说明x的store对d来说也必然先于y的store，而d一直卡在while那里，直到它观测到y是true；但没有全局一致的要求时，以下情况就可能发生——对thread c，它卡在while一段时间退去后，此时它肯定观测到了x的sotre，而它只对y进行了1次load，是false，说明它观测到x的store先于y，但对d而言，没有全局一致的约束，c的观测顺序对它没意义了，它完全可以一直卡在while，直到它观测到y的store，然后在对x进行1次load，发现x的store还没被观察到，对d而言，它是先观测到y后才是x，那么这种矛盾的原因在于，x和y的store它可能是写入内存，而c和d在load的时候，不一定去内存找，它可能直接在自己的cache中找，不一致就来了<br>那么怎么修改这段代码呢，很简单，只要保证x和y他们的被观测到的顺序是一样的就可以了，上述由于是分开被2个线程写的原因<br>如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;assert.h&gt;</span><br><span class=\"line\">std::atomic&lt;bool&gt; x,y;</span><br><span class=\"line\">std::atomic&lt;int&gt; z;</span><br><span class=\"line\">void write_x_then_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x.store(true,std::memory_order_relaxed); // 1 </span><br><span class=\"line\"> y.store(true,std::memory_order_release); // 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_y_then_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!y.load(std::memory_order_acquire)); // 3 自旋，等待y被设置为true</span><br><span class=\"line\"> if(x.load(std::memory_order_relaxed)) // 4</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x=false;</span><br><span class=\"line\"> y=false;</span><br><span class=\"line\"> z=0;</span><br><span class=\"line\"> std::thread a(write_x_then_y);</span><br><span class=\"line\"> std::thread b(read_y_then_x);</span><br><span class=\"line\"> a.join();</span><br><span class=\"line\"> b.join();</span><br><span class=\"line\"> assert(z.load()!=0); // 5</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就不用解释了，但如果说y的load不是while，而是只读1次，那这种同步性就没有了，因为它完全有可能在load之前没有观察到store，加上while，不断的load，直到某1次，发现y被store为true了，这次的load就和store有了先后顺序了，那么就可以保证同步了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>c++的内存模型挺复杂的，因为现代cpu架构的原因，例如cache等，一些操作我们无法得知他具体什么时候会对其他线程可见，例如说thread A写了一个全局变量，但它很有可能是写到自己的私有cache导致说它的这个写对其他thread不可见，那么c++对于这些就提出了一个叫内存模型的玩意。<br>首先是顺序一致性模型，它规定有2点：<br>1.内存访问执行的顺序与程序指定的顺序相同<br>2.所有核心的内存访问实际执行顺序都和程序指定顺序相同<br>有1个例子就可以说明这个，一个群聊里，每个人的发言记录的顺序是固定的，不可能说先看到晚发出去的信息，而他所看到的所有人的发言记录，与其他的每个人都一样，都是遵循着某种交叉着的顺序，而且大家观察到的顺序都是一样的，<br>而c++默认就是使用这种内存模型，即memory_order_seq_cst,以下面这段代码为例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;assert.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">std::atomic&lt;bool&gt; x,y;</span><br><span class=\"line\">std::atomic&lt;int&gt; z;</span><br><span class=\"line\">void write_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x.store(true,std::memory_order_seq_cst); // 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void write_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> y.store(true,std::memory_order_seq_cst); // 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_x_then_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!x.load(std::memory_order_seq_cst));</span><br><span class=\"line\"> if(y.load(std::memory_order_seq_cst)) // 3</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\"> //std::cout &lt;&lt; z &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_y_then_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!y.load(std::memory_order_seq_cst));</span><br><span class=\"line\"> if(x.load(std::memory_order_seq_cst)) // 4</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\"> //std::cout &lt;&lt; z &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x=false;</span><br><span class=\"line\"> y=false;</span><br><span class=\"line\"> z=0;</span><br><span class=\"line\"> std::thread a(write_x);</span><br><span class=\"line\"> std::thread b(write_y);</span><br><span class=\"line\"> std::thread c(read_x_then_y);</span><br><span class=\"line\"> std::thread d(read_y_then_x);</span><br><span class=\"line\"> a.join();</span><br><span class=\"line\"> b.join();</span><br><span class=\"line\"> c.join();</span><br><span class=\"line\"> d.join();</span><br><span class=\"line\"> assert(z.load()!=0); // 5</span><br><span class=\"line\"> std::cout &lt;&lt; z &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里assert永远不会报错，且下一步输出的z有可能是1，有可能是2，下面分别分析：<br>如果第1个load是true，但第2个load是false，也就算说它观察到了x的store是先于y的store，或者说在它跳出while的时候，肯定是看到了x的store操作，但y的load还是false，说明它没观察到y的store操作，所以它观察到的所x的store先于y的store，那么对thread d而言，它也必须以这种顺序观察到2个store，所以说thread d的第1个load如果是true了，说明它观察到了y的store，所以它必然已经观察到了x的store，所以它下一步的load必然为true，反过来也同理，这个时候的z就是1了<br>而z=2的情况为还不是很明白，假如说a的第一个load到了某个时间点，观察到了x的store，它退出了while，然后它第2个load，观察到了y是true，但这就没办法确定x和y的store的观察顺序了，如果x的store先于y，那么对d而言，它的2个load必然为ture，z=2，如果y的store是先于x的，那么thread d就可能第2个load是false了，此时z=1（这里好像就是第1种情况了？，这里的解释不一定正确）</p>\n<p>接下来是acq-rel模型，它解除了对全局一致性的约束，只单纯地利用memory_order_acquire和memory_order_release,前者如果某个load使用则在load之前的指令都不能跨过该语句被重排到后面，后者则是某个store使用则其后语句不能被重排跨到前面<br>我们经常利用他们去实现同步操作，但是这里要注意，它无法保证全局一致，也就是说，每个thread观测到的顺序是可能不一样的，如下例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;assert.h&gt;</span><br><span class=\"line\">std::atomic&lt;bool&gt; x,y;</span><br><span class=\"line\">std::atomic&lt;int&gt; z;</span><br><span class=\"line\">void write_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x.store(true,std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void write_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> y.store(true,std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_x_then_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!x.load(std::memory_order_acquire));</span><br><span class=\"line\"> if(y.load(std::memory_order_acquire)) // 1</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_y_then_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!y.load(std::memory_order_acquire));</span><br><span class=\"line\"> if(x.load(std::memory_order_acquire)) // 2</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x=false;</span><br><span class=\"line\"> y=false;</span><br><span class=\"line\"> z=0;</span><br><span class=\"line\"> std::thread a(write_x);</span><br><span class=\"line\"> std::thread b(write_y);</span><br><span class=\"line\"> std::thread c(read_x_then_y);</span><br><span class=\"line\"> std::thread d(read_y_then_x);</span><br><span class=\"line\"> a.join();</span><br><span class=\"line\"> b.join();</span><br><span class=\"line\"> c.join();</span><br><span class=\"line\"> d.join();</span><br><span class=\"line\"> assert(z.load()!=0); // 3</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于不同thread的对同1个原子变量，acq-rel的语义只能做到——如果在load的时候观察到了store，那么必然就能保证我们需要的同步，如果在load的时候还没观察到store的话就做不到了，如下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;cassert&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;chrono&gt;</span><br><span class=\"line\">std::atomic&lt;std::string*&gt; ptr ;</span><br><span class=\"line\">int data;</span><br><span class=\"line\"> </span><br><span class=\"line\">void producer()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::this_thread::sleep_for(std::chrono::milliseconds(1000));</span><br><span class=\"line\">    std::string* p  = new std::string(&quot;Hello&quot;);</span><br><span class=\"line\">    data = 42;</span><br><span class=\"line\">    ptr.store(p, std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">void consumer()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::string* p2 = nullptr;</span><br><span class=\"line\">    //std::this_thread::sleep_for(std::chrono::milliseconds(1000));</span><br><span class=\"line\">    p2 = ptr.load(std::memory_order_acquire);</span><br><span class=\"line\">    assert(*p2 == &quot;Hello&quot;); // never fires</span><br><span class=\"line\">    assert(data == 42);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::thread t1(producer);</span><br><span class=\"line\">    std::thread t2(consumer);</span><br><span class=\"line\">    t1.join(); t2.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码大多数时候是报错的，因为thread 1 sleep了一段时间，所以在第2个thread中，在它load的时候，第1个thread的store因为sleep的原因未执行，导致了它无法做到同步，所以下面的assert必然报错，但如果修改p2，改成while(!p2=ptr.load(std::memory_order_acquire)),就能实现同步了，因为它会一直在while中循环，直到某1次循环中，它观察到了线程1的store操作，那么这2者的同步语义就能建立起来了——线程1的store之前的语句必然先于store，线程2的load之后的语句必然非先于load，而它跳出循环的时候store必然是已经被观测到了，所以这种同步就建立起来了<br>回头看上一段代码，这段代码可能报错的原因就在于，acq-rel语义没有规定全局一致，那么就可能出现thread c观测到x的store先于y的store，而d则反过来，此时他们就都加不了z，或者说我们可以这么理解——全局一致下，c看到了x是true，y只load1次看到是false，说明x的store对d来说也必然先于y的store，而d一直卡在while那里，直到它观测到y是true；但没有全局一致的要求时，以下情况就可能发生——对thread c，它卡在while一段时间退去后，此时它肯定观测到了x的sotre，而它只对y进行了1次load，是false，说明它观测到x的store先于y，但对d而言，没有全局一致的约束，c的观测顺序对它没意义了，它完全可以一直卡在while，直到它观测到y的store，然后在对x进行1次load，发现x的store还没被观察到，对d而言，它是先观测到y后才是x，那么这种矛盾的原因在于，x和y的store它可能是写入内存，而c和d在load的时候，不一定去内存找，它可能直接在自己的cache中找，不一致就来了<br>那么怎么修改这段代码呢，很简单，只要保证x和y他们的被观测到的顺序是一样的就可以了，上述由于是分开被2个线程写的原因<br>如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;assert.h&gt;</span><br><span class=\"line\">std::atomic&lt;bool&gt; x,y;</span><br><span class=\"line\">std::atomic&lt;int&gt; z;</span><br><span class=\"line\">void write_x_then_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x.store(true,std::memory_order_relaxed); // 1 </span><br><span class=\"line\"> y.store(true,std::memory_order_release); // 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_y_then_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!y.load(std::memory_order_acquire)); // 3 自旋，等待y被设置为true</span><br><span class=\"line\"> if(x.load(std::memory_order_relaxed)) // 4</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x=false;</span><br><span class=\"line\"> y=false;</span><br><span class=\"line\"> z=0;</span><br><span class=\"line\"> std::thread a(write_x_then_y);</span><br><span class=\"line\"> std::thread b(read_y_then_x);</span><br><span class=\"line\"> a.join();</span><br><span class=\"line\"> b.join();</span><br><span class=\"line\"> assert(z.load()!=0); // 5</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就不用解释了，但如果说y的load不是while，而是只读1次，那这种同步性就没有了，因为它完全有可能在load之前没有观察到store，加上while，不断的load，直到某1次，发现y被store为true了，这次的load就和store有了先后顺序了，那么就可以保证同步了</p>\n"},{"layout":"init","title":"模板偏特化","date":"2022-09-04T13:53:25.000Z","_content":"","source":"_posts/模板偏特化-1.md","raw":"---\nlayout: init\ntitle: 模板偏特化\ndate: 2022-09-04 21:53:25\ntags:\n---\n","slug":"模板偏特化-1","published":1,"updated":"2022-09-04T13:53:25.067Z","comments":1,"photos":[],"link":"","_id":"cl7o7xgmk0001zepvamre4kid","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"init","title":"模板偏特化","date":"2022-09-04T12:02:45.000Z","_content":"\n模板偏特化，就\n","source":"_posts/模板偏特化.md","raw":"---\nlayout: init\ntitle: 模板偏特化\ndate: 2022-09-04 20:02:45\ntags: c++\n---\n\n模板偏特化，就\n","slug":"模板偏特化","published":1,"updated":"2022-09-05T03:48:45.326Z","_id":"cl7o7xgmn0003zepvd4ukabme","comments":1,"photos":[],"link":"","content":"<p>模板偏特化，就</p>\n","site":{"data":{}},"excerpt":"","more":"<p>模板偏特化，就</p>\n"},{"layout":"init","title":"shared_ptr线程安全","date":"2022-09-05T07:36:09.000Z","_content":"\nshared_ptr众所周知的智能指针，其允许多个指针指向同一内存对象，且在引用计数为0的时候自动析构被管理的对象，但是，在多线程的环境下，他的操作不是线程安全的，\n原因在于，其管理对象的方式是通过指针去管理，而其底层的引用计数本身也是一个指针，指向一个真正的计数对象，当我们执行如下代码的时候\n~~~\nshared_ptr<A> a1 (new A));\nshared_ptr<A> a2 = a1;\n~~~\na2在构造的时候，是分为2步的，第1步是让a2管理的A对象指向a1管理的对象，第2步是让a2的引用计数也指向a1的引用计数对象，然后再把count+1\n那么这种非原子的操作方式就可能带来race condition了，如下代码\n~~~\n#include <memory>\n#include <iostream>\n#include <thread>\n\nstd::shared_ptr<int> p1 (new int(5));\n\nvoid func1(){\n  std::shared_ptr<int> p2;\n  p2 = p1;\n  std::cout << *p2 << std::endl;\n}\n\nvoid func2(){\n  std::shared_ptr<int> p3;\n  p1 = p3;\n}\n\nint main(){\n  std::thread t1(func1);\n  std::thread t2(func2);\n  t1.join();\n  t2.join();\n}\n~~~\n当线程1执行p2 = p1的时候，首先他会把p1管理对象的指针赋值给p2，但这个时候，线程2来了，他的p1 = p3的赋值操作，导致p1原来管理的int(5)变成了1个没人指向的对象，所以其对应的引用计数也为0，且这个原来的对象就被析构了，此时p1所指的引用计数对象，他的count是2，再下一步，来到线程1，p2 = p1指令继续赋值，把p1的新的引用计数对象赋给了p2，那么这个引用计数对象的count就是3了，但此时p2所指的是那个已经被析构了的int(5),这个时候我们再解引用p2，就会报错了，如图：\n![](/images/shared_ptr线程安全/dump.png)\n中间的那个偶尔的段错误吐核就是啦\n所以这里要记住：shared_ptr的实现机制，最核心的就是使用2个指针，指向1个被管理对象和1个与之关联的引用计数对象，在赋值的时候是分2步的非原子操作，所以这个时候一定要加锁使其原子化\n\n","source":"_posts/shared-ptr线程安全.md","raw":"---\nlayout: init\ntitle: shared_ptr线程安全\ndate: 2022-09-05 15:36:09\ntags: c++\n---\n\nshared_ptr众所周知的智能指针，其允许多个指针指向同一内存对象，且在引用计数为0的时候自动析构被管理的对象，但是，在多线程的环境下，他的操作不是线程安全的，\n原因在于，其管理对象的方式是通过指针去管理，而其底层的引用计数本身也是一个指针，指向一个真正的计数对象，当我们执行如下代码的时候\n~~~\nshared_ptr<A> a1 (new A));\nshared_ptr<A> a2 = a1;\n~~~\na2在构造的时候，是分为2步的，第1步是让a2管理的A对象指向a1管理的对象，第2步是让a2的引用计数也指向a1的引用计数对象，然后再把count+1\n那么这种非原子的操作方式就可能带来race condition了，如下代码\n~~~\n#include <memory>\n#include <iostream>\n#include <thread>\n\nstd::shared_ptr<int> p1 (new int(5));\n\nvoid func1(){\n  std::shared_ptr<int> p2;\n  p2 = p1;\n  std::cout << *p2 << std::endl;\n}\n\nvoid func2(){\n  std::shared_ptr<int> p3;\n  p1 = p3;\n}\n\nint main(){\n  std::thread t1(func1);\n  std::thread t2(func2);\n  t1.join();\n  t2.join();\n}\n~~~\n当线程1执行p2 = p1的时候，首先他会把p1管理对象的指针赋值给p2，但这个时候，线程2来了，他的p1 = p3的赋值操作，导致p1原来管理的int(5)变成了1个没人指向的对象，所以其对应的引用计数也为0，且这个原来的对象就被析构了，此时p1所指的引用计数对象，他的count是2，再下一步，来到线程1，p2 = p1指令继续赋值，把p1的新的引用计数对象赋给了p2，那么这个引用计数对象的count就是3了，但此时p2所指的是那个已经被析构了的int(5),这个时候我们再解引用p2，就会报错了，如图：\n![](/images/shared_ptr线程安全/dump.png)\n中间的那个偶尔的段错误吐核就是啦\n所以这里要记住：shared_ptr的实现机制，最核心的就是使用2个指针，指向1个被管理对象和1个与之关联的引用计数对象，在赋值的时候是分2步的非原子操作，所以这个时候一定要加锁使其原子化\n\n","slug":"shared-ptr线程安全","published":1,"updated":"2022-09-05T07:55:00.570Z","comments":1,"photos":[],"link":"","_id":"cl7ogwsy80000d6pvbb47fdys","content":"<p>shared_ptr众所周知的智能指针，其允许多个指针指向同一内存对象，且在引用计数为0的时候自动析构被管理的对象，但是，在多线程的环境下，他的操作不是线程安全的，<br>原因在于，其管理对象的方式是通过指针去管理，而其底层的引用计数本身也是一个指针，指向一个真正的计数对象，当我们执行如下代码的时候</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;A&gt; a1 (new A));</span><br><span class=\"line\">shared_ptr&lt;A&gt; a2 = a1;</span><br></pre></td></tr></table></figure>\n<p>a2在构造的时候，是分为2步的，第1步是让a2管理的A对象指向a1管理的对象，第2步是让a2的引用计数也指向a1的引用计数对象，然后再把count+1<br>那么这种非原子的操作方式就可能带来race condition了，如下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;memory&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">std::shared_ptr&lt;int&gt; p1 (new int(5));</span><br><span class=\"line\"></span><br><span class=\"line\">void func1()&#123;</span><br><span class=\"line\">  std::shared_ptr&lt;int&gt; p2;</span><br><span class=\"line\">  p2 = p1;</span><br><span class=\"line\">  std::cout &lt;&lt; *p2 &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void func2()&#123;</span><br><span class=\"line\">  std::shared_ptr&lt;int&gt; p3;</span><br><span class=\"line\">  p1 = p3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">  std::thread t1(func1);</span><br><span class=\"line\">  std::thread t2(func2);</span><br><span class=\"line\">  t1.join();</span><br><span class=\"line\">  t2.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当线程1执行p2 = p1的时候，首先他会把p1管理对象的指针赋值给p2，但这个时候，线程2来了，他的p1 = p3的赋值操作，导致p1原来管理的int(5)变成了1个没人指向的对象，所以其对应的引用计数也为0，且这个原来的对象就被析构了，此时p1所指的引用计数对象，他的count是2，再下一步，来到线程1，p2 = p1指令继续赋值，把p1的新的引用计数对象赋给了p2，那么这个引用计数对象的count就是3了，但此时p2所指的是那个已经被析构了的int(5),这个时候我们再解引用p2，就会报错了，如图：<br><img src=\"/images/shared_ptr%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/dump.png\"><br>中间的那个偶尔的段错误吐核就是啦<br>所以这里要记住：shared_ptr的实现机制，最核心的就是使用2个指针，指向1个被管理对象和1个与之关联的引用计数对象，在赋值的时候是分2步的非原子操作，所以这个时候一定要加锁使其原子化</p>\n","site":{"data":{}},"excerpt":"","more":"<p>shared_ptr众所周知的智能指针，其允许多个指针指向同一内存对象，且在引用计数为0的时候自动析构被管理的对象，但是，在多线程的环境下，他的操作不是线程安全的，<br>原因在于，其管理对象的方式是通过指针去管理，而其底层的引用计数本身也是一个指针，指向一个真正的计数对象，当我们执行如下代码的时候</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;A&gt; a1 (new A));</span><br><span class=\"line\">shared_ptr&lt;A&gt; a2 = a1;</span><br></pre></td></tr></table></figure>\n<p>a2在构造的时候，是分为2步的，第1步是让a2管理的A对象指向a1管理的对象，第2步是让a2的引用计数也指向a1的引用计数对象，然后再把count+1<br>那么这种非原子的操作方式就可能带来race condition了，如下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;memory&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">std::shared_ptr&lt;int&gt; p1 (new int(5));</span><br><span class=\"line\"></span><br><span class=\"line\">void func1()&#123;</span><br><span class=\"line\">  std::shared_ptr&lt;int&gt; p2;</span><br><span class=\"line\">  p2 = p1;</span><br><span class=\"line\">  std::cout &lt;&lt; *p2 &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void func2()&#123;</span><br><span class=\"line\">  std::shared_ptr&lt;int&gt; p3;</span><br><span class=\"line\">  p1 = p3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">  std::thread t1(func1);</span><br><span class=\"line\">  std::thread t2(func2);</span><br><span class=\"line\">  t1.join();</span><br><span class=\"line\">  t2.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当线程1执行p2 = p1的时候，首先他会把p1管理对象的指针赋值给p2，但这个时候，线程2来了，他的p1 = p3的赋值操作，导致p1原来管理的int(5)变成了1个没人指向的对象，所以其对应的引用计数也为0，且这个原来的对象就被析构了，此时p1所指的引用计数对象，他的count是2，再下一步，来到线程1，p2 = p1指令继续赋值，把p1的新的引用计数对象赋给了p2，那么这个引用计数对象的count就是3了，但此时p2所指的是那个已经被析构了的int(5),这个时候我们再解引用p2，就会报错了，如图：<br><img src=\"/images/shared_ptr%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/dump.png\"><br>中间的那个偶尔的段错误吐核就是啦<br>所以这里要记住：shared_ptr的实现机制，最核心的就是使用2个指针，指向1个被管理对象和1个与之关联的引用计数对象，在赋值的时候是分2步的非原子操作，所以这个时候一定要加锁使其原子化</p>\n"},{"layout":"init","title":"局部静态对象","date":"2022-09-05T15:35:19.000Z","_content":"\n\n\nc++11规定，在一个函数内的局部静态变量(local static),它的初始化是必须线程安全的，也就是说，它的初始化过程是加锁的，其他线程在其初始化过程中是被阻塞的，否则就可能说1个线程在初始化过程中在还没赋值之前，另1个线程也开始初始化，最后就造成了重复构造，具体如下代码\n~~~\n#include <thread>\n#include <iostream>\n#include <mutex>\nclass A {\npublic:\nA(){ std::cout << \"constructing\" << std::endl; }\n\n};\n\nA& getA(){\n  static A a;\n  return a;\n}\n\nstd::mutex lock;\nvoid func(){\n  A a = getA();\n  std::unique_lock<std::mutex> mylock (lock);\n  std::cout << &a << std::endl;\n}\n\nint main(){\n  std::thread thread_list[10];\n  for (int i = 0; i < 10; i++){\n    thread_list[i] = std::thread(func);\n  }\n  for (int i = 0; i < 10; i++){\n    thread_list[i].join();\n  }\n}\n~~~\n![](/images/local_static/res.png)\n\n可以看到，这个对象只被正确地构造了1次，其他线程都引用同一个对象\n这种方式是c++实现单例模式的最佳手段，因为它就是这么简单\n","source":"_posts/局部静态对象.md","raw":"---\nlayout: init\ntitle: 局部静态对象\ndate: 2022-09-05 23:35:19\ntags: c++\n---\n\n\n\nc++11规定，在一个函数内的局部静态变量(local static),它的初始化是必须线程安全的，也就是说，它的初始化过程是加锁的，其他线程在其初始化过程中是被阻塞的，否则就可能说1个线程在初始化过程中在还没赋值之前，另1个线程也开始初始化，最后就造成了重复构造，具体如下代码\n~~~\n#include <thread>\n#include <iostream>\n#include <mutex>\nclass A {\npublic:\nA(){ std::cout << \"constructing\" << std::endl; }\n\n};\n\nA& getA(){\n  static A a;\n  return a;\n}\n\nstd::mutex lock;\nvoid func(){\n  A a = getA();\n  std::unique_lock<std::mutex> mylock (lock);\n  std::cout << &a << std::endl;\n}\n\nint main(){\n  std::thread thread_list[10];\n  for (int i = 0; i < 10; i++){\n    thread_list[i] = std::thread(func);\n  }\n  for (int i = 0; i < 10; i++){\n    thread_list[i].join();\n  }\n}\n~~~\n![](/images/local_static/res.png)\n\n可以看到，这个对象只被正确地构造了1次，其他线程都引用同一个对象\n这种方式是c++实现单例模式的最佳手段，因为它就是这么简单\n","slug":"局部静态对象","published":1,"updated":"2022-09-05T15:43:58.446Z","comments":1,"photos":[],"link":"","_id":"cl7oxnq8n00001apvcxtcc7f4","content":"<p>c++11规定，在一个函数内的局部静态变量(local static),它的初始化是必须线程安全的，也就是说，它的初始化过程是加锁的，其他线程在其初始化过程中是被阻塞的，否则就可能说1个线程在初始化过程中在还没赋值之前，另1个线程也开始初始化，最后就造成了重复构造，具体如下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;mutex&gt;</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">A()&#123; std::cout &lt;&lt; &quot;constructing&quot; &lt;&lt; std::endl; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">A&amp; getA()&#123;</span><br><span class=\"line\">  static A a;</span><br><span class=\"line\">  return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::mutex lock;</span><br><span class=\"line\">void func()&#123;</span><br><span class=\"line\">  A a = getA();</span><br><span class=\"line\">  std::unique_lock&lt;std::mutex&gt; mylock (lock);</span><br><span class=\"line\">  std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">  std::thread thread_list[10];</span><br><span class=\"line\">  for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">    thread_list[i] = std::thread(func);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">    thread_list[i].join();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/local_static/res.png\"></p>\n<p>可以看到，这个对象只被正确地构造了1次，其他线程都引用同一个对象<br>这种方式是c++实现单例模式的最佳手段，因为它就是这么简单</p>\n","site":{"data":{}},"excerpt":"","more":"<p>c++11规定，在一个函数内的局部静态变量(local static),它的初始化是必须线程安全的，也就是说，它的初始化过程是加锁的，其他线程在其初始化过程中是被阻塞的，否则就可能说1个线程在初始化过程中在还没赋值之前，另1个线程也开始初始化，最后就造成了重复构造，具体如下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;mutex&gt;</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">A()&#123; std::cout &lt;&lt; &quot;constructing&quot; &lt;&lt; std::endl; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">A&amp; getA()&#123;</span><br><span class=\"line\">  static A a;</span><br><span class=\"line\">  return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::mutex lock;</span><br><span class=\"line\">void func()&#123;</span><br><span class=\"line\">  A a = getA();</span><br><span class=\"line\">  std::unique_lock&lt;std::mutex&gt; mylock (lock);</span><br><span class=\"line\">  std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">  std::thread thread_list[10];</span><br><span class=\"line\">  for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">    thread_list[i] = std::thread(func);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">    thread_list[i].join();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/local_static/res.png\"></p>\n<p>可以看到，这个对象只被正确地构造了1次，其他线程都引用同一个对象<br>这种方式是c++实现单例模式的最佳手段，因为它就是这么简单</p>\n"},{"title":"一个可扩展哈希代码阅读","date":"2022-09-07T11:36:00.000Z","_content":"\n可扩展哈希一般是用在数据库中管理1条1条的record的，虽然现在很多都是用B+树了\n这个主要是做15-445的project时接触到的，project2需要实现1个可扩展哈希\n静态的哈希随着记录的增多，其冲突的概率也越来越大，此时如果能动态扩容就能优化性能了\n可扩展哈希的主要成员就2个，一个是bucket，它内部存放的就是1条1条的记录，一般初始化的时候就指定他的可存放记录的数目，多个bucket就构成了整个hash表\n第2个是directory，他是1个可以扩展的数组，每个成员都是指针，指向对应的bucket，其对应的bucket就是通过哈希函数算出对应的下标，且可能会有多个成员指向同个bucket的情况，这个后面再说\n还有的就是2个重要的概念：global depth和local depth，前者是directory的成员，它指明了每个bucket最大的local depth，也限制了其管理的bucket指针数组的大小，例如说global depth是5的时候，他的bucket数组最多就有32个，而local depth是每个bucket的成员，他指明了找到该bucket需要的位数，例如说\n\n这里我分析的是https://github.com/nitish6174/extendible-hashing/blob/master/main.cpp\n里面的代码，内容还是比较好懂的\n接下来首先是他的bucket部分，这个比较简单，就是一些常规的增删查改操作，\n\n~~~\nBucket::Bucket(int depth, int size)\n{\n    this->depth = depth;\n    this->size = size;\n}\n\nint Bucket::insert(int key, string value)\n{\n    std::map<int,string>::iterator it;\n    it = values.find(key);\n    if(it!=values.end())\n        return -1;\n    if(isFull())\n        return 0;\n    values[key] = value;\n    return 1;\n}\n\nint Bucket::remove(int key)\n{\n    std::map<int,string>::iterator it;\n    it = values.find(key);\n    if(it!=values.end())\n    {\n        values.erase(it);\n        return 1;\n    }\n    else\n    {\n        cout<<\"Cannot remove : This key does not exists\"<<endl;\n        return 0;\n    }\n}\n\nint Bucket::update(int key, string value)\n{\n    std::map<int,string>::iterator it;\n    it = values.find(key);\n    if(it!=values.end())\n    {\n        values[key] = value;\n        cout<<\"Value updated\"<<endl;\n        return 1;\n    }\n    else\n    {\n        cout<<\"Cannot update : This key does not exists\"<<endl;\n        return 0;\n    }\n}\n\nvoid Bucket::search(int key)\n{\n    std::map<int,string>::iterator it;\n    it = values.find(key);\n    if(it!=values.end())\n    {\n        cout<<\"Value = \"<<it->second<<endl;\n    }\n    else\n    {\n        cout<<\"This key does not exists\"<<endl;\n    }\n}\n\nint Bucket::isFull(void)\n{\n    if(values.size()==size)\n        return 1;\n    else\n        return 0;\n}\n\nint Bucket::isEmpty(void)\n{\n    if(values.size()==0)\n        return 1;\n    else\n        return 0;\n}\n\nint Bucket::getDepth(void)\n{\n    return depth;\n}\n\nint Bucket::increaseDepth(void)\n{\n    depth++;\n    return depth;\n}\n\nint Bucket::decreaseDepth(void)\n{\n    depth--;\n    return depth;\n}\n\nstd::map<int, string> Bucket::copy(void)\n{\n    std::map<int, string> temp(values.begin(),values.end());\n    return temp;\n}\n\nvoid Bucket::clear(void)\n{\n    values.clear();\n}\n\nvoid Bucket::display()\n{\n    std::map<int,string>::iterator it;\n    for(it=values.begin();it!=values.end();it++)\n        cout<<it->first<<\" \";\n    cout<<endl;\n}\n~~~\n\n接下来就是directory的内容，首先是他的构造函数\n~~~\nDirectory::Directory(int depth, int bucket_size)\n{\n    this->global_depth = depth;\n    this->bucket_size = bucket_size;\n    for(int i = 0 ; i < 1<<depth ; i++ )\n    {\n        buckets.push_back(new Bucket(depth,bucket_size));\n    }\n}\n~~~\n可以看到，他一开始的local depth和global depth是一样的，其哈希函数如下：\n~~~\nint Directory::hash(int n)\n{\n    return n&((1<<global_depth)-1);\n}\n~~~\n很直白的，就是取n的二进制位的最后global depth位做为哈希值，例如说当global depth为3时，上面就是n&7（111）了\n下面是一个取pair的函数\n~~~\nint Directory::pairIndex(int bucket_no, int depth)\n{\n    return bucket_no^(1<<(depth-1));\n}\n~~~\n这个是在桶进行split的时候调用的，这里在被调用时被分裂的桶的bucket_no+1才等于参数depth，例如说bucket_no是6（110）的时候，depth是4，那么做取异操作后，返回的是14（1110），和原来的6（0110）相比，就是在增加的哈希位上不同了，这里具体为啥这么做见后面的grow就知道了\n~~~\nvoid Directory::grow(void)\n{\n    for(int i = 0 ; i < 1<<global_depth ; i++ )\n        buckets.push_back(buckets[i]);\n    global_depth++;\n}\n~~~\ngrow函数是在bucket分裂时发现他分裂后的local depth比global depth还大时调用的，调用后bucket数组翻倍，而且他翻倍后多出来的数组元素，比如说原来是n个，现在2n个，第n+1个和第1个指向同1个bucket，因为push_back会生成原来指针的副本，他也指向原来的指针所指对象，所以grow的过程并没有真正的创建bucket对象，只是多出了一些类似占位符的东西。而且看到这里上面的pairindex函数就明白了，pair指的就是这里的指针11对应的关系，bucket数组的第6个和第14个都指向同1个bucket对象，我们取得他的下标，给他赋予真正的新的bucket对象（见下面的split)\n~~~\nvoid Directory::split(int bucket_no)\n{\n    int local_depth,pair_index,index_diff,dir_size,i;\n    map<int, string> temp;\n    map<int, string>::iterator it;\n\n    local_depth = buckets[bucket_no]->increaseDepth();\n    if(local_depth>global_depth)\n        grow();\n    pair_index = pairIndex(bucket_no,local_depth);\n    buckets[pair_index] = new Bucket(local_depth,bucket_size);\n    temp = buckets[bucket_no]->copy();\n    buckets[bucket_no]->clear();\n    index_diff = 1<<local_depth;\n    dir_size = 1<<global_depth;\n    for( i=pair_index-index_diff ; i>=0 ; i-=index_diff )\n        buckets[i] = buckets[pair_index];\n    for( i=pair_index+index_diff ; i<dir_size ; i+=index_diff )\n        buckets[i] = buckets[pair_index];\n    for(it=temp.begin();it!=temp.end();it++)\n        insert((*it).first,(*it).second,1);\n}\n~~~\n首先是调用要分裂的那个bucket的increasedepth函数，他的local depth+1了，如果需要扩容调用grow函数，接着是找到指向同1个bucket的bucket_no(pairindex函数)，然后在他上面真正的创建1个新的bucket，然后把需要分裂的那个桶的内容赋值给temp变量并清空，准备后面的分配，而接下来的操作则是bucket数组里的某几个指向新建立的bucket，这里我们具体以一个例子说明\n假设一开始global depth和local depth都是3，后来有某个桶7（111）他要split，发现global depth不够，于是需要grow，然后就走上述流程，接着算出index_diff和dir_size都是16，pair_index是15（1111），那么很明显2个for循环都不满足条件不执行，因为除了7和15外就没有哪个bucket_no指向相关的桶了，但假如后来桶7（0111，这个时候是4层了）又不够了，又要扩容了，global depth就变成5了，一切如上照旧；后来桶7又不够用。又分裂了，global depth变为6了，不过这个时候和原来8个桶相比，只多了3个桶而已\n到了后面，终于是1个local depth是3的桶要分裂了，假设他是6（110），他发现global depth够用，就不用grow了，他的pair_index是14（1110），index_diff是16，dir_size是64，第1个for没走，但第2个，他会遍历30（011110），46（101110），62（111110），这3个桶都指向新分裂出来的桶，原本他们指向的和6一样的桶，至于为啥这么做，我的想法是，当global depth比local depth多到1定程度时，指向同1个桶的哈希下标是有很多的，这个时候就需要新生成的桶来分担一些，例如上面的6，在没分裂前，后3位是110的桶的下标都指向了6,的桶，分裂后，后四位是0110的依旧，但1110的则被分配去新的桶了，假如不这么做的话，到后面可能就出现某些桶需要频繁地分裂的结果\n接下来就是insert函数，其实现如下\n~~~\nvoid Directory::insert(int key,string value,bool reinserted)\n{\n    int bucket_no = hash(key);\n    int status = buckets[bucket_no]->insert(key,value);\n    if(status==1)\n    {\n        if(!reinserted)\n            cout<<\"Inserted key \"<<key<<\" in bucket \"<<bucket_id(bucket_no)<<endl;\n        else\n            cout<<\"Moved key \"<<key<<\" to bucket \"<<bucket_id(bucket_no)<<endl;\n    }\n    else if(status==0)\n    {\n        split(bucket_no);\n        insert(key,value,reinserted);\n    }\n    else\n    {\n        cout<<\"Key \"<<key<<\" already exists in bucket \"<<bucket_id(bucket_no)<<endl;\n    }\n}\n~~~\n首先是计算哈希值，例如说上面的例子继续下去，此时的global depth是6，这里根据上面的例子，对于后4位是1110的，他们会指向同1个桶，而后4位是0110的，他们会指向另外1个桶，可万一他原本就要溢出的桶里面，每条记录的后4位都是0110呢，这个时候他们就都走到同1个桶了，就又溢出了，这个时候上面代码就根据insert的返回值判断是否溢出，溢出了，则要对bucket_no这个桶再一次split，例如说我们假设的6（0110，现在是4位local depth），6的pair index这个时候是22了（10110），split也顺带把54指向了新生成的桶（110110，接下来就是根据5位二进制去判断了，因为我们原本假设他们后4位都是0110，现在就进一步地根据第5位是0还是1去判断走哪个桶了，如果还溢出，就继续分裂，知道没有溢出为止。\n总结目前上述内容，就是一种平衡吧，当global depth是6的时候，在6（110）这个下标的桶还没分裂前，有8个哈希下标会指向他，分裂的同时也应该能使得new出来的桶分担一些\n那接下来有分必有合，shrink操作函数如下\n~~~\nvoid Directory::shrink(void)\n{\n    int i,flag=1;\n    for( i=0 ; i<buckets.size() ; i++ )\n    {\n        if(buckets[i]->getDepth()==global_depth)\n        {\n            flag=0;\n            return;\n        }\n    }\n    global_depth--;\n    for(i = 0 ; i < 1<<global_depth ; i++ )\n        buckets.pop_back();\n}\n~~~\n如果有1个桶的local depth和global depth一样，就无法缩小了，原因可以看到后面他缩小的操作，实际上就是把后半部分的bucket给去掉了，而能没有后果的去掉的前提是，这些bucket指向的对象完全和前半部分的一样，但假如其中某个桶的local depth和global depth一样，说明是经过了split中的new Bucket(local_depth,bucket_size)操作，导致这后半部分有某个桶他指向了新的对象，也就无法删除了，\n下面是merge函数\n~~~\nvoid Directory::merge(int bucket_no)\n{\n    int local_depth,pair_index,index_diff,dir_size,i;\n\n    local_depth = buckets[bucket_no]->getDepth();\n    pair_index = pairIndex(bucket_no,local_depth);\n    index_diff = 1<<local_depth;\n    dir_size = 1<<global_depth;\n\n    if( buckets[pair_index]->getDepth() == local_depth )\n    {\n        buckets[pair_index]->decreaseDepth();\n        delete(buckets[bucket_no]);\n        buckets[bucket_no] = buckets[pair_index];\n        for( i=bucket_no-index_diff ; i>=0 ; i-=index_diff )\n            buckets[i] = buckets[pair_index];\n        for( i=bucket_no+index_diff ; i<dir_size ; i+=index_diff )\n            buckets[i] = buckets[pair_index];\n    }\n}\n~~~\n这里就是split反过来，例如说上面的例子，我想merge22，他的pair index是6，且他们的local depth都是5，这个时候就可以走if里面的流程，把这个local depth减1，然后删去22这个桶，且让6所指的桶的指针给了22，然后就是把那些原来指向22的桶现在指向6，就是和上面split一样的思路\n下面是remove函数\n~~~\nvoid Directory::remove(int key,int mode)\n{\n    int bucket_no = hash(key);\n    if(buckets[bucket_no]->remove(key))\n        cout<<\"Deleted key \"<<key<<\" from bucket \"<<bucket_id(bucket_no)<<endl;\n    if(mode>0)\n    {\n        if(buckets[bucket_no]->isEmpty() && buckets[bucket_no]->getDepth()>1)\n            merge(bucket_no);\n    }\n    if(mode>1)\n    {\n        shrink();\n    }\n}\n~~~\nmode是用户输入的，根据他来判断是要merge（删去某个桶）还是直接对半砍去\n剩下的几个没列出来的也只是很简单的操作，这个代码也就分析完咯，下面就开始做project2捏\n","source":"_posts/一个可扩展哈希代码阅读.md","raw":"---\ntitle: 一个可扩展哈希代码阅读\ndate: 2022-09-07 19:36:00\ntags: 小组件\n---\n\n可扩展哈希一般是用在数据库中管理1条1条的record的，虽然现在很多都是用B+树了\n这个主要是做15-445的project时接触到的，project2需要实现1个可扩展哈希\n静态的哈希随着记录的增多，其冲突的概率也越来越大，此时如果能动态扩容就能优化性能了\n可扩展哈希的主要成员就2个，一个是bucket，它内部存放的就是1条1条的记录，一般初始化的时候就指定他的可存放记录的数目，多个bucket就构成了整个hash表\n第2个是directory，他是1个可以扩展的数组，每个成员都是指针，指向对应的bucket，其对应的bucket就是通过哈希函数算出对应的下标，且可能会有多个成员指向同个bucket的情况，这个后面再说\n还有的就是2个重要的概念：global depth和local depth，前者是directory的成员，它指明了每个bucket最大的local depth，也限制了其管理的bucket指针数组的大小，例如说global depth是5的时候，他的bucket数组最多就有32个，而local depth是每个bucket的成员，他指明了找到该bucket需要的位数，例如说\n\n这里我分析的是https://github.com/nitish6174/extendible-hashing/blob/master/main.cpp\n里面的代码，内容还是比较好懂的\n接下来首先是他的bucket部分，这个比较简单，就是一些常规的增删查改操作，\n\n~~~\nBucket::Bucket(int depth, int size)\n{\n    this->depth = depth;\n    this->size = size;\n}\n\nint Bucket::insert(int key, string value)\n{\n    std::map<int,string>::iterator it;\n    it = values.find(key);\n    if(it!=values.end())\n        return -1;\n    if(isFull())\n        return 0;\n    values[key] = value;\n    return 1;\n}\n\nint Bucket::remove(int key)\n{\n    std::map<int,string>::iterator it;\n    it = values.find(key);\n    if(it!=values.end())\n    {\n        values.erase(it);\n        return 1;\n    }\n    else\n    {\n        cout<<\"Cannot remove : This key does not exists\"<<endl;\n        return 0;\n    }\n}\n\nint Bucket::update(int key, string value)\n{\n    std::map<int,string>::iterator it;\n    it = values.find(key);\n    if(it!=values.end())\n    {\n        values[key] = value;\n        cout<<\"Value updated\"<<endl;\n        return 1;\n    }\n    else\n    {\n        cout<<\"Cannot update : This key does not exists\"<<endl;\n        return 0;\n    }\n}\n\nvoid Bucket::search(int key)\n{\n    std::map<int,string>::iterator it;\n    it = values.find(key);\n    if(it!=values.end())\n    {\n        cout<<\"Value = \"<<it->second<<endl;\n    }\n    else\n    {\n        cout<<\"This key does not exists\"<<endl;\n    }\n}\n\nint Bucket::isFull(void)\n{\n    if(values.size()==size)\n        return 1;\n    else\n        return 0;\n}\n\nint Bucket::isEmpty(void)\n{\n    if(values.size()==0)\n        return 1;\n    else\n        return 0;\n}\n\nint Bucket::getDepth(void)\n{\n    return depth;\n}\n\nint Bucket::increaseDepth(void)\n{\n    depth++;\n    return depth;\n}\n\nint Bucket::decreaseDepth(void)\n{\n    depth--;\n    return depth;\n}\n\nstd::map<int, string> Bucket::copy(void)\n{\n    std::map<int, string> temp(values.begin(),values.end());\n    return temp;\n}\n\nvoid Bucket::clear(void)\n{\n    values.clear();\n}\n\nvoid Bucket::display()\n{\n    std::map<int,string>::iterator it;\n    for(it=values.begin();it!=values.end();it++)\n        cout<<it->first<<\" \";\n    cout<<endl;\n}\n~~~\n\n接下来就是directory的内容，首先是他的构造函数\n~~~\nDirectory::Directory(int depth, int bucket_size)\n{\n    this->global_depth = depth;\n    this->bucket_size = bucket_size;\n    for(int i = 0 ; i < 1<<depth ; i++ )\n    {\n        buckets.push_back(new Bucket(depth,bucket_size));\n    }\n}\n~~~\n可以看到，他一开始的local depth和global depth是一样的，其哈希函数如下：\n~~~\nint Directory::hash(int n)\n{\n    return n&((1<<global_depth)-1);\n}\n~~~\n很直白的，就是取n的二进制位的最后global depth位做为哈希值，例如说当global depth为3时，上面就是n&7（111）了\n下面是一个取pair的函数\n~~~\nint Directory::pairIndex(int bucket_no, int depth)\n{\n    return bucket_no^(1<<(depth-1));\n}\n~~~\n这个是在桶进行split的时候调用的，这里在被调用时被分裂的桶的bucket_no+1才等于参数depth，例如说bucket_no是6（110）的时候，depth是4，那么做取异操作后，返回的是14（1110），和原来的6（0110）相比，就是在增加的哈希位上不同了，这里具体为啥这么做见后面的grow就知道了\n~~~\nvoid Directory::grow(void)\n{\n    for(int i = 0 ; i < 1<<global_depth ; i++ )\n        buckets.push_back(buckets[i]);\n    global_depth++;\n}\n~~~\ngrow函数是在bucket分裂时发现他分裂后的local depth比global depth还大时调用的，调用后bucket数组翻倍，而且他翻倍后多出来的数组元素，比如说原来是n个，现在2n个，第n+1个和第1个指向同1个bucket，因为push_back会生成原来指针的副本，他也指向原来的指针所指对象，所以grow的过程并没有真正的创建bucket对象，只是多出了一些类似占位符的东西。而且看到这里上面的pairindex函数就明白了，pair指的就是这里的指针11对应的关系，bucket数组的第6个和第14个都指向同1个bucket对象，我们取得他的下标，给他赋予真正的新的bucket对象（见下面的split)\n~~~\nvoid Directory::split(int bucket_no)\n{\n    int local_depth,pair_index,index_diff,dir_size,i;\n    map<int, string> temp;\n    map<int, string>::iterator it;\n\n    local_depth = buckets[bucket_no]->increaseDepth();\n    if(local_depth>global_depth)\n        grow();\n    pair_index = pairIndex(bucket_no,local_depth);\n    buckets[pair_index] = new Bucket(local_depth,bucket_size);\n    temp = buckets[bucket_no]->copy();\n    buckets[bucket_no]->clear();\n    index_diff = 1<<local_depth;\n    dir_size = 1<<global_depth;\n    for( i=pair_index-index_diff ; i>=0 ; i-=index_diff )\n        buckets[i] = buckets[pair_index];\n    for( i=pair_index+index_diff ; i<dir_size ; i+=index_diff )\n        buckets[i] = buckets[pair_index];\n    for(it=temp.begin();it!=temp.end();it++)\n        insert((*it).first,(*it).second,1);\n}\n~~~\n首先是调用要分裂的那个bucket的increasedepth函数，他的local depth+1了，如果需要扩容调用grow函数，接着是找到指向同1个bucket的bucket_no(pairindex函数)，然后在他上面真正的创建1个新的bucket，然后把需要分裂的那个桶的内容赋值给temp变量并清空，准备后面的分配，而接下来的操作则是bucket数组里的某几个指向新建立的bucket，这里我们具体以一个例子说明\n假设一开始global depth和local depth都是3，后来有某个桶7（111）他要split，发现global depth不够，于是需要grow，然后就走上述流程，接着算出index_diff和dir_size都是16，pair_index是15（1111），那么很明显2个for循环都不满足条件不执行，因为除了7和15外就没有哪个bucket_no指向相关的桶了，但假如后来桶7（0111，这个时候是4层了）又不够了，又要扩容了，global depth就变成5了，一切如上照旧；后来桶7又不够用。又分裂了，global depth变为6了，不过这个时候和原来8个桶相比，只多了3个桶而已\n到了后面，终于是1个local depth是3的桶要分裂了，假设他是6（110），他发现global depth够用，就不用grow了，他的pair_index是14（1110），index_diff是16，dir_size是64，第1个for没走，但第2个，他会遍历30（011110），46（101110），62（111110），这3个桶都指向新分裂出来的桶，原本他们指向的和6一样的桶，至于为啥这么做，我的想法是，当global depth比local depth多到1定程度时，指向同1个桶的哈希下标是有很多的，这个时候就需要新生成的桶来分担一些，例如上面的6，在没分裂前，后3位是110的桶的下标都指向了6,的桶，分裂后，后四位是0110的依旧，但1110的则被分配去新的桶了，假如不这么做的话，到后面可能就出现某些桶需要频繁地分裂的结果\n接下来就是insert函数，其实现如下\n~~~\nvoid Directory::insert(int key,string value,bool reinserted)\n{\n    int bucket_no = hash(key);\n    int status = buckets[bucket_no]->insert(key,value);\n    if(status==1)\n    {\n        if(!reinserted)\n            cout<<\"Inserted key \"<<key<<\" in bucket \"<<bucket_id(bucket_no)<<endl;\n        else\n            cout<<\"Moved key \"<<key<<\" to bucket \"<<bucket_id(bucket_no)<<endl;\n    }\n    else if(status==0)\n    {\n        split(bucket_no);\n        insert(key,value,reinserted);\n    }\n    else\n    {\n        cout<<\"Key \"<<key<<\" already exists in bucket \"<<bucket_id(bucket_no)<<endl;\n    }\n}\n~~~\n首先是计算哈希值，例如说上面的例子继续下去，此时的global depth是6，这里根据上面的例子，对于后4位是1110的，他们会指向同1个桶，而后4位是0110的，他们会指向另外1个桶，可万一他原本就要溢出的桶里面，每条记录的后4位都是0110呢，这个时候他们就都走到同1个桶了，就又溢出了，这个时候上面代码就根据insert的返回值判断是否溢出，溢出了，则要对bucket_no这个桶再一次split，例如说我们假设的6（0110，现在是4位local depth），6的pair index这个时候是22了（10110），split也顺带把54指向了新生成的桶（110110，接下来就是根据5位二进制去判断了，因为我们原本假设他们后4位都是0110，现在就进一步地根据第5位是0还是1去判断走哪个桶了，如果还溢出，就继续分裂，知道没有溢出为止。\n总结目前上述内容，就是一种平衡吧，当global depth是6的时候，在6（110）这个下标的桶还没分裂前，有8个哈希下标会指向他，分裂的同时也应该能使得new出来的桶分担一些\n那接下来有分必有合，shrink操作函数如下\n~~~\nvoid Directory::shrink(void)\n{\n    int i,flag=1;\n    for( i=0 ; i<buckets.size() ; i++ )\n    {\n        if(buckets[i]->getDepth()==global_depth)\n        {\n            flag=0;\n            return;\n        }\n    }\n    global_depth--;\n    for(i = 0 ; i < 1<<global_depth ; i++ )\n        buckets.pop_back();\n}\n~~~\n如果有1个桶的local depth和global depth一样，就无法缩小了，原因可以看到后面他缩小的操作，实际上就是把后半部分的bucket给去掉了，而能没有后果的去掉的前提是，这些bucket指向的对象完全和前半部分的一样，但假如其中某个桶的local depth和global depth一样，说明是经过了split中的new Bucket(local_depth,bucket_size)操作，导致这后半部分有某个桶他指向了新的对象，也就无法删除了，\n下面是merge函数\n~~~\nvoid Directory::merge(int bucket_no)\n{\n    int local_depth,pair_index,index_diff,dir_size,i;\n\n    local_depth = buckets[bucket_no]->getDepth();\n    pair_index = pairIndex(bucket_no,local_depth);\n    index_diff = 1<<local_depth;\n    dir_size = 1<<global_depth;\n\n    if( buckets[pair_index]->getDepth() == local_depth )\n    {\n        buckets[pair_index]->decreaseDepth();\n        delete(buckets[bucket_no]);\n        buckets[bucket_no] = buckets[pair_index];\n        for( i=bucket_no-index_diff ; i>=0 ; i-=index_diff )\n            buckets[i] = buckets[pair_index];\n        for( i=bucket_no+index_diff ; i<dir_size ; i+=index_diff )\n            buckets[i] = buckets[pair_index];\n    }\n}\n~~~\n这里就是split反过来，例如说上面的例子，我想merge22，他的pair index是6，且他们的local depth都是5，这个时候就可以走if里面的流程，把这个local depth减1，然后删去22这个桶，且让6所指的桶的指针给了22，然后就是把那些原来指向22的桶现在指向6，就是和上面split一样的思路\n下面是remove函数\n~~~\nvoid Directory::remove(int key,int mode)\n{\n    int bucket_no = hash(key);\n    if(buckets[bucket_no]->remove(key))\n        cout<<\"Deleted key \"<<key<<\" from bucket \"<<bucket_id(bucket_no)<<endl;\n    if(mode>0)\n    {\n        if(buckets[bucket_no]->isEmpty() && buckets[bucket_no]->getDepth()>1)\n            merge(bucket_no);\n    }\n    if(mode>1)\n    {\n        shrink();\n    }\n}\n~~~\nmode是用户输入的，根据他来判断是要merge（删去某个桶）还是直接对半砍去\n剩下的几个没列出来的也只是很简单的操作，这个代码也就分析完咯，下面就开始做project2捏\n","slug":"一个可扩展哈希代码阅读","published":1,"updated":"2022-09-07T13:38:29.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ro22ol0000wwpvbi2vhuad","content":"<p>可扩展哈希一般是用在数据库中管理1条1条的record的，虽然现在很多都是用B+树了<br>这个主要是做15-445的project时接触到的，project2需要实现1个可扩展哈希<br>静态的哈希随着记录的增多，其冲突的概率也越来越大，此时如果能动态扩容就能优化性能了<br>可扩展哈希的主要成员就2个，一个是bucket，它内部存放的就是1条1条的记录，一般初始化的时候就指定他的可存放记录的数目，多个bucket就构成了整个hash表<br>第2个是directory，他是1个可以扩展的数组，每个成员都是指针，指向对应的bucket，其对应的bucket就是通过哈希函数算出对应的下标，且可能会有多个成员指向同个bucket的情况，这个后面再说<br>还有的就是2个重要的概念：global depth和local depth，前者是directory的成员，它指明了每个bucket最大的local depth，也限制了其管理的bucket指针数组的大小，例如说global depth是5的时候，他的bucket数组最多就有32个，而local depth是每个bucket的成员，他指明了找到该bucket需要的位数，例如说</p>\n<p>这里我分析的是<a href=\"https://github.com/nitish6174/extendible-hashing/blob/master/main.cpp\">https://github.com/nitish6174/extendible-hashing/blob/master/main.cpp</a><br>里面的代码，内容还是比较好懂的<br>接下来首先是他的bucket部分，这个比较简单，就是一些常规的增删查改操作，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Bucket::Bucket(int depth, int size)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this-&gt;depth = depth;</span><br><span class=\"line\">    this-&gt;size = size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::insert(int key, string value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::map&lt;int,string&gt;::iterator it;</span><br><span class=\"line\">    it = values.find(key);</span><br><span class=\"line\">    if(it!=values.end())</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    if(isFull())</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    values[key] = value;</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::remove(int key)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::map&lt;int,string&gt;::iterator it;</span><br><span class=\"line\">    it = values.find(key);</span><br><span class=\"line\">    if(it!=values.end())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        values.erase(it);</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;Cannot remove : This key does not exists&quot;&lt;&lt;endl;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::update(int key, string value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::map&lt;int,string&gt;::iterator it;</span><br><span class=\"line\">    it = values.find(key);</span><br><span class=\"line\">    if(it!=values.end())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        values[key] = value;</span><br><span class=\"line\">        cout&lt;&lt;&quot;Value updated&quot;&lt;&lt;endl;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;Cannot update : This key does not exists&quot;&lt;&lt;endl;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Bucket::search(int key)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::map&lt;int,string&gt;::iterator it;</span><br><span class=\"line\">    it = values.find(key);</span><br><span class=\"line\">    if(it!=values.end())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;Value = &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;This key does not exists&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::isFull(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(values.size()==size)</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::isEmpty(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(values.size()==0)</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::getDepth(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return depth;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::increaseDepth(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    depth++;</span><br><span class=\"line\">    return depth;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::decreaseDepth(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    depth--;</span><br><span class=\"line\">    return depth;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::map&lt;int, string&gt; Bucket::copy(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::map&lt;int, string&gt; temp(values.begin(),values.end());</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Bucket::clear(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    values.clear();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Bucket::display()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::map&lt;int,string&gt;::iterator it;</span><br><span class=\"line\">    for(it=values.begin();it!=values.end();it++)</span><br><span class=\"line\">        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;;</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就是directory的内容，首先是他的构造函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Directory::Directory(int depth, int bucket_size)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this-&gt;global_depth = depth;</span><br><span class=\"line\">    this-&gt;bucket_size = bucket_size;</span><br><span class=\"line\">    for(int i = 0 ; i &lt; 1&lt;&lt;depth ; i++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buckets.push_back(new Bucket(depth,bucket_size));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，他一开始的local depth和global depth是一样的，其哈希函数如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int Directory::hash(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return n&amp;((1&lt;&lt;global_depth)-1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很直白的，就是取n的二进制位的最后global depth位做为哈希值，例如说当global depth为3时，上面就是n&amp;7（111）了<br>下面是一个取pair的函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int Directory::pairIndex(int bucket_no, int depth)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return bucket_no^(1&lt;&lt;(depth-1));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个是在桶进行split的时候调用的，这里在被调用时被分裂的桶的bucket_no+1才等于参数depth，例如说bucket_no是6（110）的时候，depth是4，那么做取异操作后，返回的是14（1110），和原来的6（0110）相比，就是在增加的哈希位上不同了，这里具体为啥这么做见后面的grow就知道了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Directory::grow(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(int i = 0 ; i &lt; 1&lt;&lt;global_depth ; i++ )</span><br><span class=\"line\">        buckets.push_back(buckets[i]);</span><br><span class=\"line\">    global_depth++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>grow函数是在bucket分裂时发现他分裂后的local depth比global depth还大时调用的，调用后bucket数组翻倍，而且他翻倍后多出来的数组元素，比如说原来是n个，现在2n个，第n+1个和第1个指向同1个bucket，因为push_back会生成原来指针的副本，他也指向原来的指针所指对象，所以grow的过程并没有真正的创建bucket对象，只是多出了一些类似占位符的东西。而且看到这里上面的pairindex函数就明白了，pair指的就是这里的指针11对应的关系，bucket数组的第6个和第14个都指向同1个bucket对象，我们取得他的下标，给他赋予真正的新的bucket对象（见下面的split)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Directory::split(int bucket_no)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int local_depth,pair_index,index_diff,dir_size,i;</span><br><span class=\"line\">    map&lt;int, string&gt; temp;</span><br><span class=\"line\">    map&lt;int, string&gt;::iterator it;</span><br><span class=\"line\"></span><br><span class=\"line\">    local_depth = buckets[bucket_no]-&gt;increaseDepth();</span><br><span class=\"line\">    if(local_depth&gt;global_depth)</span><br><span class=\"line\">        grow();</span><br><span class=\"line\">    pair_index = pairIndex(bucket_no,local_depth);</span><br><span class=\"line\">    buckets[pair_index] = new Bucket(local_depth,bucket_size);</span><br><span class=\"line\">    temp = buckets[bucket_no]-&gt;copy();</span><br><span class=\"line\">    buckets[bucket_no]-&gt;clear();</span><br><span class=\"line\">    index_diff = 1&lt;&lt;local_depth;</span><br><span class=\"line\">    dir_size = 1&lt;&lt;global_depth;</span><br><span class=\"line\">    for( i=pair_index-index_diff ; i&gt;=0 ; i-=index_diff )</span><br><span class=\"line\">        buckets[i] = buckets[pair_index];</span><br><span class=\"line\">    for( i=pair_index+index_diff ; i&lt;dir_size ; i+=index_diff )</span><br><span class=\"line\">        buckets[i] = buckets[pair_index];</span><br><span class=\"line\">    for(it=temp.begin();it!=temp.end();it++)</span><br><span class=\"line\">        insert((*it).first,(*it).second,1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先是调用要分裂的那个bucket的increasedepth函数，他的local depth+1了，如果需要扩容调用grow函数，接着是找到指向同1个bucket的bucket_no(pairindex函数)，然后在他上面真正的创建1个新的bucket，然后把需要分裂的那个桶的内容赋值给temp变量并清空，准备后面的分配，而接下来的操作则是bucket数组里的某几个指向新建立的bucket，这里我们具体以一个例子说明<br>假设一开始global depth和local depth都是3，后来有某个桶7（111）他要split，发现global depth不够，于是需要grow，然后就走上述流程，接着算出index_diff和dir_size都是16，pair_index是15（1111），那么很明显2个for循环都不满足条件不执行，因为除了7和15外就没有哪个bucket_no指向相关的桶了，但假如后来桶7（0111，这个时候是4层了）又不够了，又要扩容了，global depth就变成5了，一切如上照旧；后来桶7又不够用。又分裂了，global depth变为6了，不过这个时候和原来8个桶相比，只多了3个桶而已<br>到了后面，终于是1个local depth是3的桶要分裂了，假设他是6（110），他发现global depth够用，就不用grow了，他的pair_index是14（1110），index_diff是16，dir_size是64，第1个for没走，但第2个，他会遍历30（011110），46（101110），62（111110），这3个桶都指向新分裂出来的桶，原本他们指向的和6一样的桶，至于为啥这么做，我的想法是，当global depth比local depth多到1定程度时，指向同1个桶的哈希下标是有很多的，这个时候就需要新生成的桶来分担一些，例如上面的6，在没分裂前，后3位是110的桶的下标都指向了6,的桶，分裂后，后四位是0110的依旧，但1110的则被分配去新的桶了，假如不这么做的话，到后面可能就出现某些桶需要频繁地分裂的结果<br>接下来就是insert函数，其实现如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Directory::insert(int key,string value,bool reinserted)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int bucket_no = hash(key);</span><br><span class=\"line\">    int status = buckets[bucket_no]-&gt;insert(key,value);</span><br><span class=\"line\">    if(status==1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(!reinserted)</span><br><span class=\"line\">            cout&lt;&lt;&quot;Inserted key &quot;&lt;&lt;key&lt;&lt;&quot; in bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            cout&lt;&lt;&quot;Moved key &quot;&lt;&lt;key&lt;&lt;&quot; to bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if(status==0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        split(bucket_no);</span><br><span class=\"line\">        insert(key,value,reinserted);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;Key &quot;&lt;&lt;key&lt;&lt;&quot; already exists in bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先是计算哈希值，例如说上面的例子继续下去，此时的global depth是6，这里根据上面的例子，对于后4位是1110的，他们会指向同1个桶，而后4位是0110的，他们会指向另外1个桶，可万一他原本就要溢出的桶里面，每条记录的后4位都是0110呢，这个时候他们就都走到同1个桶了，就又溢出了，这个时候上面代码就根据insert的返回值判断是否溢出，溢出了，则要对bucket_no这个桶再一次split，例如说我们假设的6（0110，现在是4位local depth），6的pair index这个时候是22了（10110），split也顺带把54指向了新生成的桶（110110，接下来就是根据5位二进制去判断了，因为我们原本假设他们后4位都是0110，现在就进一步地根据第5位是0还是1去判断走哪个桶了，如果还溢出，就继续分裂，知道没有溢出为止。<br>总结目前上述内容，就是一种平衡吧，当global depth是6的时候，在6（110）这个下标的桶还没分裂前，有8个哈希下标会指向他，分裂的同时也应该能使得new出来的桶分担一些<br>那接下来有分必有合，shrink操作函数如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Directory::shrink(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i,flag=1;</span><br><span class=\"line\">    for( i=0 ; i&lt;buckets.size() ; i++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(buckets[i]-&gt;getDepth()==global_depth)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            flag=0;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    global_depth--;</span><br><span class=\"line\">    for(i = 0 ; i &lt; 1&lt;&lt;global_depth ; i++ )</span><br><span class=\"line\">        buckets.pop_back();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果有1个桶的local depth和global depth一样，就无法缩小了，原因可以看到后面他缩小的操作，实际上就是把后半部分的bucket给去掉了，而能没有后果的去掉的前提是，这些bucket指向的对象完全和前半部分的一样，但假如其中某个桶的local depth和global depth一样，说明是经过了split中的new Bucket(local_depth,bucket_size)操作，导致这后半部分有某个桶他指向了新的对象，也就无法删除了，<br>下面是merge函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Directory::merge(int bucket_no)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int local_depth,pair_index,index_diff,dir_size,i;</span><br><span class=\"line\"></span><br><span class=\"line\">    local_depth = buckets[bucket_no]-&gt;getDepth();</span><br><span class=\"line\">    pair_index = pairIndex(bucket_no,local_depth);</span><br><span class=\"line\">    index_diff = 1&lt;&lt;local_depth;</span><br><span class=\"line\">    dir_size = 1&lt;&lt;global_depth;</span><br><span class=\"line\"></span><br><span class=\"line\">    if( buckets[pair_index]-&gt;getDepth() == local_depth )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buckets[pair_index]-&gt;decreaseDepth();</span><br><span class=\"line\">        delete(buckets[bucket_no]);</span><br><span class=\"line\">        buckets[bucket_no] = buckets[pair_index];</span><br><span class=\"line\">        for( i=bucket_no-index_diff ; i&gt;=0 ; i-=index_diff )</span><br><span class=\"line\">            buckets[i] = buckets[pair_index];</span><br><span class=\"line\">        for( i=bucket_no+index_diff ; i&lt;dir_size ; i+=index_diff )</span><br><span class=\"line\">            buckets[i] = buckets[pair_index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就是split反过来，例如说上面的例子，我想merge22，他的pair index是6，且他们的local depth都是5，这个时候就可以走if里面的流程，把这个local depth减1，然后删去22这个桶，且让6所指的桶的指针给了22，然后就是把那些原来指向22的桶现在指向6，就是和上面split一样的思路<br>下面是remove函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Directory::remove(int key,int mode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int bucket_no = hash(key);</span><br><span class=\"line\">    if(buckets[bucket_no]-&gt;remove(key))</span><br><span class=\"line\">        cout&lt;&lt;&quot;Deleted key &quot;&lt;&lt;key&lt;&lt;&quot; from bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl;</span><br><span class=\"line\">    if(mode&gt;0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(buckets[bucket_no]-&gt;isEmpty() &amp;&amp; buckets[bucket_no]-&gt;getDepth()&gt;1)</span><br><span class=\"line\">            merge(bucket_no);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(mode&gt;1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        shrink();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>mode是用户输入的，根据他来判断是要merge（删去某个桶）还是直接对半砍去<br>剩下的几个没列出来的也只是很简单的操作，这个代码也就分析完咯，下面就开始做project2捏</p>\n","site":{"data":{}},"excerpt":"","more":"<p>可扩展哈希一般是用在数据库中管理1条1条的record的，虽然现在很多都是用B+树了<br>这个主要是做15-445的project时接触到的，project2需要实现1个可扩展哈希<br>静态的哈希随着记录的增多，其冲突的概率也越来越大，此时如果能动态扩容就能优化性能了<br>可扩展哈希的主要成员就2个，一个是bucket，它内部存放的就是1条1条的记录，一般初始化的时候就指定他的可存放记录的数目，多个bucket就构成了整个hash表<br>第2个是directory，他是1个可以扩展的数组，每个成员都是指针，指向对应的bucket，其对应的bucket就是通过哈希函数算出对应的下标，且可能会有多个成员指向同个bucket的情况，这个后面再说<br>还有的就是2个重要的概念：global depth和local depth，前者是directory的成员，它指明了每个bucket最大的local depth，也限制了其管理的bucket指针数组的大小，例如说global depth是5的时候，他的bucket数组最多就有32个，而local depth是每个bucket的成员，他指明了找到该bucket需要的位数，例如说</p>\n<p>这里我分析的是<a href=\"https://github.com/nitish6174/extendible-hashing/blob/master/main.cpp\">https://github.com/nitish6174/extendible-hashing/blob/master/main.cpp</a><br>里面的代码，内容还是比较好懂的<br>接下来首先是他的bucket部分，这个比较简单，就是一些常规的增删查改操作，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Bucket::Bucket(int depth, int size)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this-&gt;depth = depth;</span><br><span class=\"line\">    this-&gt;size = size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::insert(int key, string value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::map&lt;int,string&gt;::iterator it;</span><br><span class=\"line\">    it = values.find(key);</span><br><span class=\"line\">    if(it!=values.end())</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    if(isFull())</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    values[key] = value;</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::remove(int key)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::map&lt;int,string&gt;::iterator it;</span><br><span class=\"line\">    it = values.find(key);</span><br><span class=\"line\">    if(it!=values.end())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        values.erase(it);</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;Cannot remove : This key does not exists&quot;&lt;&lt;endl;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::update(int key, string value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::map&lt;int,string&gt;::iterator it;</span><br><span class=\"line\">    it = values.find(key);</span><br><span class=\"line\">    if(it!=values.end())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        values[key] = value;</span><br><span class=\"line\">        cout&lt;&lt;&quot;Value updated&quot;&lt;&lt;endl;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;Cannot update : This key does not exists&quot;&lt;&lt;endl;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Bucket::search(int key)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::map&lt;int,string&gt;::iterator it;</span><br><span class=\"line\">    it = values.find(key);</span><br><span class=\"line\">    if(it!=values.end())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;Value = &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;This key does not exists&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::isFull(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(values.size()==size)</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::isEmpty(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(values.size()==0)</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::getDepth(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return depth;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::increaseDepth(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    depth++;</span><br><span class=\"line\">    return depth;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int Bucket::decreaseDepth(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    depth--;</span><br><span class=\"line\">    return depth;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::map&lt;int, string&gt; Bucket::copy(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::map&lt;int, string&gt; temp(values.begin(),values.end());</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Bucket::clear(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    values.clear();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Bucket::display()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::map&lt;int,string&gt;::iterator it;</span><br><span class=\"line\">    for(it=values.begin();it!=values.end();it++)</span><br><span class=\"line\">        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;;</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就是directory的内容，首先是他的构造函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Directory::Directory(int depth, int bucket_size)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this-&gt;global_depth = depth;</span><br><span class=\"line\">    this-&gt;bucket_size = bucket_size;</span><br><span class=\"line\">    for(int i = 0 ; i &lt; 1&lt;&lt;depth ; i++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buckets.push_back(new Bucket(depth,bucket_size));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，他一开始的local depth和global depth是一样的，其哈希函数如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int Directory::hash(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return n&amp;((1&lt;&lt;global_depth)-1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很直白的，就是取n的二进制位的最后global depth位做为哈希值，例如说当global depth为3时，上面就是n&amp;7（111）了<br>下面是一个取pair的函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int Directory::pairIndex(int bucket_no, int depth)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return bucket_no^(1&lt;&lt;(depth-1));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个是在桶进行split的时候调用的，这里在被调用时被分裂的桶的bucket_no+1才等于参数depth，例如说bucket_no是6（110）的时候，depth是4，那么做取异操作后，返回的是14（1110），和原来的6（0110）相比，就是在增加的哈希位上不同了，这里具体为啥这么做见后面的grow就知道了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Directory::grow(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(int i = 0 ; i &lt; 1&lt;&lt;global_depth ; i++ )</span><br><span class=\"line\">        buckets.push_back(buckets[i]);</span><br><span class=\"line\">    global_depth++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>grow函数是在bucket分裂时发现他分裂后的local depth比global depth还大时调用的，调用后bucket数组翻倍，而且他翻倍后多出来的数组元素，比如说原来是n个，现在2n个，第n+1个和第1个指向同1个bucket，因为push_back会生成原来指针的副本，他也指向原来的指针所指对象，所以grow的过程并没有真正的创建bucket对象，只是多出了一些类似占位符的东西。而且看到这里上面的pairindex函数就明白了，pair指的就是这里的指针11对应的关系，bucket数组的第6个和第14个都指向同1个bucket对象，我们取得他的下标，给他赋予真正的新的bucket对象（见下面的split)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Directory::split(int bucket_no)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int local_depth,pair_index,index_diff,dir_size,i;</span><br><span class=\"line\">    map&lt;int, string&gt; temp;</span><br><span class=\"line\">    map&lt;int, string&gt;::iterator it;</span><br><span class=\"line\"></span><br><span class=\"line\">    local_depth = buckets[bucket_no]-&gt;increaseDepth();</span><br><span class=\"line\">    if(local_depth&gt;global_depth)</span><br><span class=\"line\">        grow();</span><br><span class=\"line\">    pair_index = pairIndex(bucket_no,local_depth);</span><br><span class=\"line\">    buckets[pair_index] = new Bucket(local_depth,bucket_size);</span><br><span class=\"line\">    temp = buckets[bucket_no]-&gt;copy();</span><br><span class=\"line\">    buckets[bucket_no]-&gt;clear();</span><br><span class=\"line\">    index_diff = 1&lt;&lt;local_depth;</span><br><span class=\"line\">    dir_size = 1&lt;&lt;global_depth;</span><br><span class=\"line\">    for( i=pair_index-index_diff ; i&gt;=0 ; i-=index_diff )</span><br><span class=\"line\">        buckets[i] = buckets[pair_index];</span><br><span class=\"line\">    for( i=pair_index+index_diff ; i&lt;dir_size ; i+=index_diff )</span><br><span class=\"line\">        buckets[i] = buckets[pair_index];</span><br><span class=\"line\">    for(it=temp.begin();it!=temp.end();it++)</span><br><span class=\"line\">        insert((*it).first,(*it).second,1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先是调用要分裂的那个bucket的increasedepth函数，他的local depth+1了，如果需要扩容调用grow函数，接着是找到指向同1个bucket的bucket_no(pairindex函数)，然后在他上面真正的创建1个新的bucket，然后把需要分裂的那个桶的内容赋值给temp变量并清空，准备后面的分配，而接下来的操作则是bucket数组里的某几个指向新建立的bucket，这里我们具体以一个例子说明<br>假设一开始global depth和local depth都是3，后来有某个桶7（111）他要split，发现global depth不够，于是需要grow，然后就走上述流程，接着算出index_diff和dir_size都是16，pair_index是15（1111），那么很明显2个for循环都不满足条件不执行，因为除了7和15外就没有哪个bucket_no指向相关的桶了，但假如后来桶7（0111，这个时候是4层了）又不够了，又要扩容了，global depth就变成5了，一切如上照旧；后来桶7又不够用。又分裂了，global depth变为6了，不过这个时候和原来8个桶相比，只多了3个桶而已<br>到了后面，终于是1个local depth是3的桶要分裂了，假设他是6（110），他发现global depth够用，就不用grow了，他的pair_index是14（1110），index_diff是16，dir_size是64，第1个for没走，但第2个，他会遍历30（011110），46（101110），62（111110），这3个桶都指向新分裂出来的桶，原本他们指向的和6一样的桶，至于为啥这么做，我的想法是，当global depth比local depth多到1定程度时，指向同1个桶的哈希下标是有很多的，这个时候就需要新生成的桶来分担一些，例如上面的6，在没分裂前，后3位是110的桶的下标都指向了6,的桶，分裂后，后四位是0110的依旧，但1110的则被分配去新的桶了，假如不这么做的话，到后面可能就出现某些桶需要频繁地分裂的结果<br>接下来就是insert函数，其实现如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Directory::insert(int key,string value,bool reinserted)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int bucket_no = hash(key);</span><br><span class=\"line\">    int status = buckets[bucket_no]-&gt;insert(key,value);</span><br><span class=\"line\">    if(status==1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(!reinserted)</span><br><span class=\"line\">            cout&lt;&lt;&quot;Inserted key &quot;&lt;&lt;key&lt;&lt;&quot; in bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            cout&lt;&lt;&quot;Moved key &quot;&lt;&lt;key&lt;&lt;&quot; to bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if(status==0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        split(bucket_no);</span><br><span class=\"line\">        insert(key,value,reinserted);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;Key &quot;&lt;&lt;key&lt;&lt;&quot; already exists in bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先是计算哈希值，例如说上面的例子继续下去，此时的global depth是6，这里根据上面的例子，对于后4位是1110的，他们会指向同1个桶，而后4位是0110的，他们会指向另外1个桶，可万一他原本就要溢出的桶里面，每条记录的后4位都是0110呢，这个时候他们就都走到同1个桶了，就又溢出了，这个时候上面代码就根据insert的返回值判断是否溢出，溢出了，则要对bucket_no这个桶再一次split，例如说我们假设的6（0110，现在是4位local depth），6的pair index这个时候是22了（10110），split也顺带把54指向了新生成的桶（110110，接下来就是根据5位二进制去判断了，因为我们原本假设他们后4位都是0110，现在就进一步地根据第5位是0还是1去判断走哪个桶了，如果还溢出，就继续分裂，知道没有溢出为止。<br>总结目前上述内容，就是一种平衡吧，当global depth是6的时候，在6（110）这个下标的桶还没分裂前，有8个哈希下标会指向他，分裂的同时也应该能使得new出来的桶分担一些<br>那接下来有分必有合，shrink操作函数如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Directory::shrink(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i,flag=1;</span><br><span class=\"line\">    for( i=0 ; i&lt;buckets.size() ; i++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(buckets[i]-&gt;getDepth()==global_depth)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            flag=0;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    global_depth--;</span><br><span class=\"line\">    for(i = 0 ; i &lt; 1&lt;&lt;global_depth ; i++ )</span><br><span class=\"line\">        buckets.pop_back();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果有1个桶的local depth和global depth一样，就无法缩小了，原因可以看到后面他缩小的操作，实际上就是把后半部分的bucket给去掉了，而能没有后果的去掉的前提是，这些bucket指向的对象完全和前半部分的一样，但假如其中某个桶的local depth和global depth一样，说明是经过了split中的new Bucket(local_depth,bucket_size)操作，导致这后半部分有某个桶他指向了新的对象，也就无法删除了，<br>下面是merge函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Directory::merge(int bucket_no)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int local_depth,pair_index,index_diff,dir_size,i;</span><br><span class=\"line\"></span><br><span class=\"line\">    local_depth = buckets[bucket_no]-&gt;getDepth();</span><br><span class=\"line\">    pair_index = pairIndex(bucket_no,local_depth);</span><br><span class=\"line\">    index_diff = 1&lt;&lt;local_depth;</span><br><span class=\"line\">    dir_size = 1&lt;&lt;global_depth;</span><br><span class=\"line\"></span><br><span class=\"line\">    if( buckets[pair_index]-&gt;getDepth() == local_depth )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buckets[pair_index]-&gt;decreaseDepth();</span><br><span class=\"line\">        delete(buckets[bucket_no]);</span><br><span class=\"line\">        buckets[bucket_no] = buckets[pair_index];</span><br><span class=\"line\">        for( i=bucket_no-index_diff ; i&gt;=0 ; i-=index_diff )</span><br><span class=\"line\">            buckets[i] = buckets[pair_index];</span><br><span class=\"line\">        for( i=bucket_no+index_diff ; i&lt;dir_size ; i+=index_diff )</span><br><span class=\"line\">            buckets[i] = buckets[pair_index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就是split反过来，例如说上面的例子，我想merge22，他的pair index是6，且他们的local depth都是5，这个时候就可以走if里面的流程，把这个local depth减1，然后删去22这个桶，且让6所指的桶的指针给了22，然后就是把那些原来指向22的桶现在指向6，就是和上面split一样的思路<br>下面是remove函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Directory::remove(int key,int mode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int bucket_no = hash(key);</span><br><span class=\"line\">    if(buckets[bucket_no]-&gt;remove(key))</span><br><span class=\"line\">        cout&lt;&lt;&quot;Deleted key &quot;&lt;&lt;key&lt;&lt;&quot; from bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl;</span><br><span class=\"line\">    if(mode&gt;0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(buckets[bucket_no]-&gt;isEmpty() &amp;&amp; buckets[bucket_no]-&gt;getDepth()&gt;1)</span><br><span class=\"line\">            merge(bucket_no);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(mode&gt;1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        shrink();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>mode是用户输入的，根据他来判断是要merge（删去某个桶）还是直接对半砍去<br>剩下的几个没列出来的也只是很简单的操作，这个代码也就分析完咯，下面就开始做project2捏</p>\n"},{"title":"引用折叠","date":"2022-09-07T13:39:48.000Z","_content":"\n所谓的万能引用主要是用在以下2种场合：\n第1种是模板如下：\n~~~\ntemplate<typename T>\nvoid func(T&& t){...}\n~~~\n以上代码中的&&并不是右值引用的意思，他是表示说这个t肯定是一个引用类型，但具体是左值引用还是右值引用我们得根据传进来的参数确定\n那如何根据传进来的参数确定呢，这里就用到了引用折叠了，具体而言，当T被推导出来是右值时，T&&是一个右值引用（&& && 折叠为了&&），而其他情况都是折叠为&，即左值引用\n为了验证，我们可以用完美转发来验证一下\n~~~\n#include <iostream>\nvoid print(int& t){\n  std::cout << \"left\" << std::endl;\n}\n\n\nvoid print(int&& t){\n  std::cout << \"right\" << std::endl;\n}\n\ntemplate<typename T>\nvoid func(T&& t){\n  print(std::forward<T>(t));\n}\nint main(){\n  int x = 10;\n  func(x);\n  func(12);\n  func(std::move(x));\n  int& y = x;\n  func(y);\n}\n~~~\n以上代码第1个显示是left，x是一个左值为什么被推导为左值引用呢，因为在func的参数里，传进来的T&&必须被解释为1个引用，那T就可以是int，int&，int&&，只有int&能被推断为左值(int& &&折叠为&)，第2个则是right，T是实例化为int，第3个为right，T为int&&，第4个T为int&，折叠为&，所以结果是left\n\n第2种使用万能引用的场合是在auto推断中，如\n~~~\nauto&& i = 3； //auto推断为int，i为int&&类型，即右值引用\nauto&& j = i; // auto推断为int&，i为int&，即左值引用\n~~~\n\n","source":"_posts/引用折叠.md","raw":"---\ntitle: 引用折叠\ndate: 2022-09-07 21:39:48\ntags: c++\n---\n\n所谓的万能引用主要是用在以下2种场合：\n第1种是模板如下：\n~~~\ntemplate<typename T>\nvoid func(T&& t){...}\n~~~\n以上代码中的&&并不是右值引用的意思，他是表示说这个t肯定是一个引用类型，但具体是左值引用还是右值引用我们得根据传进来的参数确定\n那如何根据传进来的参数确定呢，这里就用到了引用折叠了，具体而言，当T被推导出来是右值时，T&&是一个右值引用（&& && 折叠为了&&），而其他情况都是折叠为&，即左值引用\n为了验证，我们可以用完美转发来验证一下\n~~~\n#include <iostream>\nvoid print(int& t){\n  std::cout << \"left\" << std::endl;\n}\n\n\nvoid print(int&& t){\n  std::cout << \"right\" << std::endl;\n}\n\ntemplate<typename T>\nvoid func(T&& t){\n  print(std::forward<T>(t));\n}\nint main(){\n  int x = 10;\n  func(x);\n  func(12);\n  func(std::move(x));\n  int& y = x;\n  func(y);\n}\n~~~\n以上代码第1个显示是left，x是一个左值为什么被推导为左值引用呢，因为在func的参数里，传进来的T&&必须被解释为1个引用，那T就可以是int，int&，int&&，只有int&能被推断为左值(int& &&折叠为&)，第2个则是right，T是实例化为int，第3个为right，T为int&&，第4个T为int&，折叠为&，所以结果是left\n\n第2种使用万能引用的场合是在auto推断中，如\n~~~\nauto&& i = 3； //auto推断为int，i为int&&类型，即右值引用\nauto&& j = i; // auto推断为int&，i为int&，即左值引用\n~~~\n\n","slug":"引用折叠","published":1,"updated":"2022-09-07T15:41:30.508Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7rsg8tn0000y4pva3yf5yk8","content":"<p>所谓的万能引用主要是用在以下2种场合：<br>第1种是模板如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(T&amp;&amp; t)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码中的&amp;&amp;并不是右值引用的意思，他是表示说这个t肯定是一个引用类型，但具体是左值引用还是右值引用我们得根据传进来的参数确定<br>那如何根据传进来的参数确定呢，这里就用到了引用折叠了，具体而言，当T被推导出来是右值时，T&amp;&amp;是一个右值引用（&amp;&amp; &amp;&amp; 折叠为了&amp;&amp;），而其他情况都是折叠为&amp;，即左值引用<br>为了验证，我们可以用完美转发来验证一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">void print(int&amp; t)&#123;</span><br><span class=\"line\">  std::cout &lt;&lt; &quot;left&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void print(int&amp;&amp; t)&#123;</span><br><span class=\"line\">  std::cout &lt;&lt; &quot;right&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(T&amp;&amp; t)&#123;</span><br><span class=\"line\">  print(std::forward&lt;T&gt;(t));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">  int x = 10;</span><br><span class=\"line\">  func(x);</span><br><span class=\"line\">  func(12);</span><br><span class=\"line\">  func(std::move(x));</span><br><span class=\"line\">  int&amp; y = x;</span><br><span class=\"line\">  func(y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码第1个显示是left，x是一个左值为什么被推导为左值引用呢，因为在func的参数里，传进来的T&amp;&amp;必须被解释为1个引用，那T就可以是int，int&amp;，int&amp;&amp;，只有int&amp;能被推断为左值(int&amp; &amp;&amp;折叠为&amp;)，第2个则是right，T是实例化为int，第3个为right，T为int&amp;&amp;，第4个T为int&amp;，折叠为&amp;，所以结果是left</p>\n<p>第2种使用万能引用的场合是在auto推断中，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto&amp;&amp; i = 3； //auto推断为int，i为int&amp;&amp;类型，即右值引用</span><br><span class=\"line\">auto&amp;&amp; j = i; // auto推断为int&amp;，i为int&amp;，即左值引用</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>所谓的万能引用主要是用在以下2种场合：<br>第1种是模板如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(T&amp;&amp; t)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码中的&amp;&amp;并不是右值引用的意思，他是表示说这个t肯定是一个引用类型，但具体是左值引用还是右值引用我们得根据传进来的参数确定<br>那如何根据传进来的参数确定呢，这里就用到了引用折叠了，具体而言，当T被推导出来是右值时，T&amp;&amp;是一个右值引用（&amp;&amp; &amp;&amp; 折叠为了&amp;&amp;），而其他情况都是折叠为&amp;，即左值引用<br>为了验证，我们可以用完美转发来验证一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">void print(int&amp; t)&#123;</span><br><span class=\"line\">  std::cout &lt;&lt; &quot;left&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void print(int&amp;&amp; t)&#123;</span><br><span class=\"line\">  std::cout &lt;&lt; &quot;right&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(T&amp;&amp; t)&#123;</span><br><span class=\"line\">  print(std::forward&lt;T&gt;(t));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">  int x = 10;</span><br><span class=\"line\">  func(x);</span><br><span class=\"line\">  func(12);</span><br><span class=\"line\">  func(std::move(x));</span><br><span class=\"line\">  int&amp; y = x;</span><br><span class=\"line\">  func(y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码第1个显示是left，x是一个左值为什么被推导为左值引用呢，因为在func的参数里，传进来的T&amp;&amp;必须被解释为1个引用，那T就可以是int，int&amp;，int&amp;&amp;，只有int&amp;能被推断为左值(int&amp; &amp;&amp;折叠为&amp;)，第2个则是right，T是实例化为int，第3个为right，T为int&amp;&amp;，第4个T为int&amp;，折叠为&amp;，所以结果是left</p>\n<p>第2种使用万能引用的场合是在auto推断中，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto&amp;&amp; i = 3； //auto推断为int，i为int&amp;&amp;类型，即右值引用</span><br><span class=\"line\">auto&amp;&amp; j = i; // auto推断为int&amp;，i为int&amp;，即左值引用</span><br></pre></td></tr></table></figure>\n\n"},{"title":"函数返回类型后置","date":"2022-09-07T15:51:57.000Z","_content":"\n返回类型后置，主要的用处在于某些函数他返回的类型可能很复杂，例如返回一个函数指针等，如下\n~~~\ntypedef void(* ret)(int,double);\nret myfunc(){...}\n~~~\n为了更加简洁，我们可以这么写\n\n~~~\nauto myfunc() -> void(*)(int,double){\n  ...\n}\n~~~\n其中的auto只是个占位符，真正的返回类型在后面，感觉和Python的写法很像捏\n\n除此之外，我们还可以用decltype来推导函数的返回类型，如下：\n~~~\ntemplate<typename T1, typename T2>\nauto func(T1 t1, T2 t2)->decltype(t1 + t2){\n  return t1 + t2;\n}\n~~~\n那么生成的模板函数就会根据t1+t2的实际类型决定返回类型了\nc++也允许decltype放在函数名之前表示返回类型如下：\n~~~\ntemplate<typename T1, typename T2>\ndecltype(T1() + T2()) func(T1 t1, T2 t2){\n  return t1 + t2;\n}\n~~~\n这么写虽然说也可以，但实际不这么建议使用，1是他需要要求T1和T2有无参构造函数，2是不够简洁\n\n","source":"_posts/函数返回类型后置.md","raw":"---\ntitle: 函数返回类型后置\ndate: 2022-09-07 23:51:57\ntags: c++\n---\n\n返回类型后置，主要的用处在于某些函数他返回的类型可能很复杂，例如返回一个函数指针等，如下\n~~~\ntypedef void(* ret)(int,double);\nret myfunc(){...}\n~~~\n为了更加简洁，我们可以这么写\n\n~~~\nauto myfunc() -> void(*)(int,double){\n  ...\n}\n~~~\n其中的auto只是个占位符，真正的返回类型在后面，感觉和Python的写法很像捏\n\n除此之外，我们还可以用decltype来推导函数的返回类型，如下：\n~~~\ntemplate<typename T1, typename T2>\nauto func(T1 t1, T2 t2)->decltype(t1 + t2){\n  return t1 + t2;\n}\n~~~\n那么生成的模板函数就会根据t1+t2的实际类型决定返回类型了\nc++也允许decltype放在函数名之前表示返回类型如下：\n~~~\ntemplate<typename T1, typename T2>\ndecltype(T1() + T2()) func(T1 t1, T2 t2){\n  return t1 + t2;\n}\n~~~\n这么写虽然说也可以，但实际不这么建议使用，1是他需要要求T1和T2有无参构造函数，2是不够简洁\n\n","slug":"函数返回类型后置","published":1,"updated":"2022-09-07T16:03:59.521Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7rt965c00003qpvcqak7ik5","content":"<p>返回类型后置，主要的用处在于某些函数他返回的类型可能很复杂，例如返回一个函数指针等，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef void(* ret)(int,double);</span><br><span class=\"line\">ret myfunc()&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>为了更加简洁，我们可以这么写</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto myfunc() -&gt; void(*)(int,double)&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中的auto只是个占位符，真正的返回类型在后面，感觉和Python的写法很像捏</p>\n<p>除此之外，我们还可以用decltype来推导函数的返回类型，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T1, typename T2&gt;</span><br><span class=\"line\">auto func(T1 t1, T2 t2)-&gt;decltype(t1 + t2)&#123;</span><br><span class=\"line\">  return t1 + t2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么生成的模板函数就会根据t1+t2的实际类型决定返回类型了<br>c++也允许decltype放在函数名之前表示返回类型如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T1, typename T2&gt;</span><br><span class=\"line\">decltype(T1() + T2()) func(T1 t1, T2 t2)&#123;</span><br><span class=\"line\">  return t1 + t2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这么写虽然说也可以，但实际不这么建议使用，1是他需要要求T1和T2有无参构造函数，2是不够简洁</p>\n","site":{"data":{}},"excerpt":"","more":"<p>返回类型后置，主要的用处在于某些函数他返回的类型可能很复杂，例如返回一个函数指针等，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef void(* ret)(int,double);</span><br><span class=\"line\">ret myfunc()&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>为了更加简洁，我们可以这么写</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto myfunc() -&gt; void(*)(int,double)&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中的auto只是个占位符，真正的返回类型在后面，感觉和Python的写法很像捏</p>\n<p>除此之外，我们还可以用decltype来推导函数的返回类型，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T1, typename T2&gt;</span><br><span class=\"line\">auto func(T1 t1, T2 t2)-&gt;decltype(t1 + t2)&#123;</span><br><span class=\"line\">  return t1 + t2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么生成的模板函数就会根据t1+t2的实际类型决定返回类型了<br>c++也允许decltype放在函数名之前表示返回类型如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T1, typename T2&gt;</span><br><span class=\"line\">decltype(T1() + T2()) func(T1 t1, T2 t2)&#123;</span><br><span class=\"line\">  return t1 + t2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这么写虽然说也可以，但实际不这么建议使用，1是他需要要求T1和T2有无参构造函数，2是不够简洁</p>\n"},{"title":"4种c++风格的类型转换","date":"2022-09-09T01:21:56.000Z","_content":"\nreinterpret_cast<typename1>(value),他可以把一个指针转化为另外1种指针，也可以把1个整型值赋给一个指针，其最本质在于不修改value的底层二进制位，只是修改了去解释他的方法，比如说同一个二进制数，我用整数补码（int）和float类型那个ieee标准去解释结果肯定不同\n~~~\n#include <iostream>\nint main(){\nint a = 0;\nint* p = &a;\nchar* p2 = reinterpret_cast<char *>(p);\n*p2 = '1';\n\nstd::cout << a << std::endl;\n}\n~~~\n上面代码的输出结果为49，正好是a的asci值，首先他会把p这个int指针强制转换为char类型的指针，而且他指向了a的最低位（在我们机器上是小端存储的的），我们解引用赋值，其实就是在a的最低位字节上赋值了整数49，当用char的方式去解读时读出来的就是'a',int则是49了，\n还有另外一种使用方式就是把一个整数赋值给一个指针，然后这个指针就指向这个地址了，\n~~~\nint* p;\nint address = 0x12345678;\np = reinterpret_cast<int*>(address);\n~~~\n当然这种得是你能访问这个地址才行\n\n而这种强制转换在leveldb中的fixedint编码中就使用了，如下：\n~~~\ninline void EncodeFixed32(char* dst, uint32_t value) {\n    uint8_t* const buffer = reinterpret_cast<uint8_t*>(dst);\n    buffer[0] = static_cast<uint8_t>(value);\n    buffer[1] = static_cast<uint8_t>(value >> 8);\n    buffer[2] = static_cast<uint8_t>(value >> 16);\n    buffer[3] = static_cast<uint8_t>(value >> 24);\n}\n~~~\n首先他把dst这个指针重新解释为1个指向uint8_t类型的指针然后赋值给buffer，现在buffer和dst指向同一个内存地址了，只不过他们解释这个地址里的东西的方式不同了，然后就是依次把value的每个字节的值写入buffer，也就是dst中，decode的则是反过来\n~~~\ninline uint32_t DecodeFixed32(const char* ptr) {\n  const uint8_t* const buffer = reinterpret_cast<const uint8_t*>(ptr);\n\n  // Recent clang and gcc optimize this to a single mov / ldr instruction.\n  return (static_cast<uint32_t>(buffer[0])) |\n         (static_cast<uint32_t>(buffer[1]) << 8) |\n         (static_cast<uint32_t>(buffer[2]) << 16) |\n         (static_cast<uint32_t>(buffer[3]) << 24);\n}\n~~~\n\n然后就是static_cast,基本等价于隐式转换，可以用在空指针转化为任意指针，可以用在整形和浮点数之间，对于继承的机制来说，可以把子类转化为父类，父类则不能反过来变为子类的，\n\nconst_cast\n\nconst_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。\n它的使用场景我目前了解的具体是在与const string这种相关的函数签名上，具体而言，大家都知道只有const string &才能引用一个右值（在不想写右值引用的情况下），而为了能让函数能接受(\"ww\",\"ee\")这种参数，我们就不得不把函数的参数声明为const string&，那这个时候他就很有可能也返回一个const string &，但往往我们并不需要这种const的限制，所以我们就可以写个没有cosnt约束的函数，在其内部使用const_cast添加或移去他的常量性，如下：\n~~~\n#include <iostream>\n#include <string>\nusing namespace std;\n\n\nconst string & shorter(const string & s1, const string & s2){\n  cout <<\" this is const\" << endl;\n  return s1;\n}\n\nstring & shorter(string & s1, string & s2){\n cout <<\"this is non const\" << endl;\n auto &res = shorter(const_cast<const string &>(s1), const_cast<const string &>(s2));\n return const_cast<string &>(res);\n\n}\n\nint main(){\n string s1(\"ww\");\n string s2(\"Ee\");\n shorter(s1,s2);\n shorter(\"ww\",\"ee\");\n}\n~~~\n这样子不管进来的是什么样的内容，就都能处理了，\n\n\ndynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。\n\ndynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。\n","source":"_posts/4种c-风格的类型转换.md","raw":"---\ntitle: 4种c++风格的类型转换\ndate: 2022-09-09 09:21:56\ntags: c++\n---\n\nreinterpret_cast<typename1>(value),他可以把一个指针转化为另外1种指针，也可以把1个整型值赋给一个指针，其最本质在于不修改value的底层二进制位，只是修改了去解释他的方法，比如说同一个二进制数，我用整数补码（int）和float类型那个ieee标准去解释结果肯定不同\n~~~\n#include <iostream>\nint main(){\nint a = 0;\nint* p = &a;\nchar* p2 = reinterpret_cast<char *>(p);\n*p2 = '1';\n\nstd::cout << a << std::endl;\n}\n~~~\n上面代码的输出结果为49，正好是a的asci值，首先他会把p这个int指针强制转换为char类型的指针，而且他指向了a的最低位（在我们机器上是小端存储的的），我们解引用赋值，其实就是在a的最低位字节上赋值了整数49，当用char的方式去解读时读出来的就是'a',int则是49了，\n还有另外一种使用方式就是把一个整数赋值给一个指针，然后这个指针就指向这个地址了，\n~~~\nint* p;\nint address = 0x12345678;\np = reinterpret_cast<int*>(address);\n~~~\n当然这种得是你能访问这个地址才行\n\n而这种强制转换在leveldb中的fixedint编码中就使用了，如下：\n~~~\ninline void EncodeFixed32(char* dst, uint32_t value) {\n    uint8_t* const buffer = reinterpret_cast<uint8_t*>(dst);\n    buffer[0] = static_cast<uint8_t>(value);\n    buffer[1] = static_cast<uint8_t>(value >> 8);\n    buffer[2] = static_cast<uint8_t>(value >> 16);\n    buffer[3] = static_cast<uint8_t>(value >> 24);\n}\n~~~\n首先他把dst这个指针重新解释为1个指向uint8_t类型的指针然后赋值给buffer，现在buffer和dst指向同一个内存地址了，只不过他们解释这个地址里的东西的方式不同了，然后就是依次把value的每个字节的值写入buffer，也就是dst中，decode的则是反过来\n~~~\ninline uint32_t DecodeFixed32(const char* ptr) {\n  const uint8_t* const buffer = reinterpret_cast<const uint8_t*>(ptr);\n\n  // Recent clang and gcc optimize this to a single mov / ldr instruction.\n  return (static_cast<uint32_t>(buffer[0])) |\n         (static_cast<uint32_t>(buffer[1]) << 8) |\n         (static_cast<uint32_t>(buffer[2]) << 16) |\n         (static_cast<uint32_t>(buffer[3]) << 24);\n}\n~~~\n\n然后就是static_cast,基本等价于隐式转换，可以用在空指针转化为任意指针，可以用在整形和浮点数之间，对于继承的机制来说，可以把子类转化为父类，父类则不能反过来变为子类的，\n\nconst_cast\n\nconst_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。\n它的使用场景我目前了解的具体是在与const string这种相关的函数签名上，具体而言，大家都知道只有const string &才能引用一个右值（在不想写右值引用的情况下），而为了能让函数能接受(\"ww\",\"ee\")这种参数，我们就不得不把函数的参数声明为const string&，那这个时候他就很有可能也返回一个const string &，但往往我们并不需要这种const的限制，所以我们就可以写个没有cosnt约束的函数，在其内部使用const_cast添加或移去他的常量性，如下：\n~~~\n#include <iostream>\n#include <string>\nusing namespace std;\n\n\nconst string & shorter(const string & s1, const string & s2){\n  cout <<\" this is const\" << endl;\n  return s1;\n}\n\nstring & shorter(string & s1, string & s2){\n cout <<\"this is non const\" << endl;\n auto &res = shorter(const_cast<const string &>(s1), const_cast<const string &>(s2));\n return const_cast<string &>(res);\n\n}\n\nint main(){\n string s1(\"ww\");\n string s2(\"Ee\");\n shorter(s1,s2);\n shorter(\"ww\",\"ee\");\n}\n~~~\n这样子不管进来的是什么样的内容，就都能处理了，\n\n\ndynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。\n\ndynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。\n","slug":"4种c-风格的类型转换","published":1,"updated":"2022-09-09T13:14:29.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ui5zz60000c6pv9my57qhv","content":"<p>reinterpret_cast<typename1>(value),他可以把一个指针转化为另外1种指针，也可以把1个整型值赋给一个指针，其最本质在于不修改value的底层二进制位，只是修改了去解释他的方法，比如说同一个二进制数，我用整数补码（int）和float类型那个ieee标准去解释结果肯定不同</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">int a = 0;</span><br><span class=\"line\">int* p = &amp;a;</span><br><span class=\"line\">char* p2 = reinterpret_cast&lt;char *&gt;(p);</span><br><span class=\"line\">*p2 = &#x27;1&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码的输出结果为49，正好是a的asci值，首先他会把p这个int指针强制转换为char类型的指针，而且他指向了a的最低位（在我们机器上是小端存储的的），我们解引用赋值，其实就是在a的最低位字节上赋值了整数49，当用char的方式去解读时读出来的就是’a’,int则是49了，<br>还有另外一种使用方式就是把一个整数赋值给一个指针，然后这个指针就指向这个地址了，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int* p;</span><br><span class=\"line\">int address = 0x12345678;</span><br><span class=\"line\">p = reinterpret_cast&lt;int*&gt;(address);</span><br></pre></td></tr></table></figure>\n<p>当然这种得是你能访问这个地址才行</p>\n<p>而这种强制转换在leveldb中的fixedint编码中就使用了，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inline void EncodeFixed32(char* dst, uint32_t value) &#123;</span><br><span class=\"line\">    uint8_t* const buffer = reinterpret_cast&lt;uint8_t*&gt;(dst);</span><br><span class=\"line\">    buffer[0] = static_cast&lt;uint8_t&gt;(value);</span><br><span class=\"line\">    buffer[1] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 8);</span><br><span class=\"line\">    buffer[2] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 16);</span><br><span class=\"line\">    buffer[3] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 24);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先他把dst这个指针重新解释为1个指向uint8_t类型的指针然后赋值给buffer，现在buffer和dst指向同一个内存地址了，只不过他们解释这个地址里的东西的方式不同了，然后就是依次把value的每个字节的值写入buffer，也就是dst中，decode的则是反过来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inline uint32_t DecodeFixed32(const char* ptr) &#123;</span><br><span class=\"line\">  const uint8_t* const buffer = reinterpret_cast&lt;const uint8_t*&gt;(ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">  // Recent clang and gcc optimize this to a single mov / ldr instruction.</span><br><span class=\"line\">  return (static_cast&lt;uint32_t&gt;(buffer[0])) |</span><br><span class=\"line\">         (static_cast&lt;uint32_t&gt;(buffer[1]) &lt;&lt; 8) |</span><br><span class=\"line\">         (static_cast&lt;uint32_t&gt;(buffer[2]) &lt;&lt; 16) |</span><br><span class=\"line\">         (static_cast&lt;uint32_t&gt;(buffer[3]) &lt;&lt; 24);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后就是static_cast,基本等价于隐式转换，可以用在空指针转化为任意指针，可以用在整形和浮点数之间，对于继承的机制来说，可以把子类转化为父类，父类则不能反过来变为子类的，</p>\n<p>const_cast</p>\n<p>const_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。<br>它的使用场景我目前了解的具体是在与const string这种相关的函数签名上，具体而言，大家都知道只有const string &amp;才能引用一个右值（在不想写右值引用的情况下），而为了能让函数能接受(“ww”,”ee”)这种参数，我们就不得不把函数的参数声明为const string&amp;，那这个时候他就很有可能也返回一个const string &amp;，但往往我们并不需要这种const的限制，所以我们就可以写个没有cosnt约束的函数，在其内部使用const_cast添加或移去他的常量性，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const string &amp; shorter(const string &amp; s1, const string &amp; s2)&#123;</span><br><span class=\"line\">  cout &lt;&lt;&quot; this is const&quot; &lt;&lt; endl;</span><br><span class=\"line\">  return s1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">string &amp; shorter(string &amp; s1, string &amp; s2)&#123;</span><br><span class=\"line\"> cout &lt;&lt;&quot;this is non const&quot; &lt;&lt; endl;</span><br><span class=\"line\"> auto &amp;res = shorter(const_cast&lt;const string &amp;&gt;(s1), const_cast&lt;const string &amp;&gt;(s2));</span><br><span class=\"line\"> return const_cast&lt;string &amp;&gt;(res);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\"> string s1(&quot;ww&quot;);</span><br><span class=\"line\"> string s2(&quot;Ee&quot;);</span><br><span class=\"line\"> shorter(s1,s2);</span><br><span class=\"line\"> shorter(&quot;ww&quot;,&quot;ee&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样子不管进来的是什么样的内容，就都能处理了，</p>\n<p>dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。</p>\n<p>dynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>reinterpret_cast<typename1>(value),他可以把一个指针转化为另外1种指针，也可以把1个整型值赋给一个指针，其最本质在于不修改value的底层二进制位，只是修改了去解释他的方法，比如说同一个二进制数，我用整数补码（int）和float类型那个ieee标准去解释结果肯定不同</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">int a = 0;</span><br><span class=\"line\">int* p = &amp;a;</span><br><span class=\"line\">char* p2 = reinterpret_cast&lt;char *&gt;(p);</span><br><span class=\"line\">*p2 = &#x27;1&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码的输出结果为49，正好是a的asci值，首先他会把p这个int指针强制转换为char类型的指针，而且他指向了a的最低位（在我们机器上是小端存储的的），我们解引用赋值，其实就是在a的最低位字节上赋值了整数49，当用char的方式去解读时读出来的就是’a’,int则是49了，<br>还有另外一种使用方式就是把一个整数赋值给一个指针，然后这个指针就指向这个地址了，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int* p;</span><br><span class=\"line\">int address = 0x12345678;</span><br><span class=\"line\">p = reinterpret_cast&lt;int*&gt;(address);</span><br></pre></td></tr></table></figure>\n<p>当然这种得是你能访问这个地址才行</p>\n<p>而这种强制转换在leveldb中的fixedint编码中就使用了，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inline void EncodeFixed32(char* dst, uint32_t value) &#123;</span><br><span class=\"line\">    uint8_t* const buffer = reinterpret_cast&lt;uint8_t*&gt;(dst);</span><br><span class=\"line\">    buffer[0] = static_cast&lt;uint8_t&gt;(value);</span><br><span class=\"line\">    buffer[1] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 8);</span><br><span class=\"line\">    buffer[2] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 16);</span><br><span class=\"line\">    buffer[3] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 24);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先他把dst这个指针重新解释为1个指向uint8_t类型的指针然后赋值给buffer，现在buffer和dst指向同一个内存地址了，只不过他们解释这个地址里的东西的方式不同了，然后就是依次把value的每个字节的值写入buffer，也就是dst中，decode的则是反过来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inline uint32_t DecodeFixed32(const char* ptr) &#123;</span><br><span class=\"line\">  const uint8_t* const buffer = reinterpret_cast&lt;const uint8_t*&gt;(ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">  // Recent clang and gcc optimize this to a single mov / ldr instruction.</span><br><span class=\"line\">  return (static_cast&lt;uint32_t&gt;(buffer[0])) |</span><br><span class=\"line\">         (static_cast&lt;uint32_t&gt;(buffer[1]) &lt;&lt; 8) |</span><br><span class=\"line\">         (static_cast&lt;uint32_t&gt;(buffer[2]) &lt;&lt; 16) |</span><br><span class=\"line\">         (static_cast&lt;uint32_t&gt;(buffer[3]) &lt;&lt; 24);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后就是static_cast,基本等价于隐式转换，可以用在空指针转化为任意指针，可以用在整形和浮点数之间，对于继承的机制来说，可以把子类转化为父类，父类则不能反过来变为子类的，</p>\n<p>const_cast</p>\n<p>const_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。<br>它的使用场景我目前了解的具体是在与const string这种相关的函数签名上，具体而言，大家都知道只有const string &amp;才能引用一个右值（在不想写右值引用的情况下），而为了能让函数能接受(“ww”,”ee”)这种参数，我们就不得不把函数的参数声明为const string&amp;，那这个时候他就很有可能也返回一个const string &amp;，但往往我们并不需要这种const的限制，所以我们就可以写个没有cosnt约束的函数，在其内部使用const_cast添加或移去他的常量性，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const string &amp; shorter(const string &amp; s1, const string &amp; s2)&#123;</span><br><span class=\"line\">  cout &lt;&lt;&quot; this is const&quot; &lt;&lt; endl;</span><br><span class=\"line\">  return s1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">string &amp; shorter(string &amp; s1, string &amp; s2)&#123;</span><br><span class=\"line\"> cout &lt;&lt;&quot;this is non const&quot; &lt;&lt; endl;</span><br><span class=\"line\"> auto &amp;res = shorter(const_cast&lt;const string &amp;&gt;(s1), const_cast&lt;const string &amp;&gt;(s2));</span><br><span class=\"line\"> return const_cast&lt;string &amp;&gt;(res);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\"> string s1(&quot;ww&quot;);</span><br><span class=\"line\"> string s2(&quot;Ee&quot;);</span><br><span class=\"line\"> shorter(s1,s2);</span><br><span class=\"line\"> shorter(&quot;ww&quot;,&quot;ee&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样子不管进来的是什么样的内容，就都能处理了，</p>\n<p>dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。</p>\n<p>dynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。</p>\n"},{"title":"CRTP与静态多态","date":"2022-09-09T01:01:39.000Z","_content":"CuriouslyRecurringTemplatePattern，简称CRTP，是一种实现静态多态的机制，简单而言，他的核心在于：父类是一个模板类，派生类会继承父类，且以派生类自身作为父类的模板参数，如下：\n~~~\ntemplate<typename T>\nclass Base{\npublic:\n  void print(){\n    static_cast<T*>(*this)->imp();\n  }\n  void imp(){\n    std::cout << \"this is base\" << std::endl;\n  }\n};\n\nclass Son1: public Base<Son1>{\n  void imp(){\n    std::cout << \"this is son 1\" << std::endl;\n  }\n};\n\nclass Son2: public Base<Son2>{\n  void imp(){\n    std::cout << \"this is son 2\" << std::endl;\n  }\n};\n\ntemplate<typename T>\nvoid func(T & t){\n  t.print();\n}\n~~~\n\n当我传入func的对象是Son1时， Base实例化为Son1，print中的static_cast就会把this指针强制转换为Son1*，也就能调用Son1自己实现的函数了，不过这里严格意义上来说并不算是多态，因为每个派生类继承的是各自实例化后的模板类，使用static_cast就能把从基类去访问派生类的成员函数了\n似乎llvm的visitor模式采用的就是这种捏，tvm中的貌似也有涉及这种设计，后续再看\n","source":"_posts/CRTP与静态多态.md","raw":"---\ntitle: CRTP与静态多态\ndate: 2022-09-09 09:01:39\ntags: c++\n---\nCuriouslyRecurringTemplatePattern，简称CRTP，是一种实现静态多态的机制，简单而言，他的核心在于：父类是一个模板类，派生类会继承父类，且以派生类自身作为父类的模板参数，如下：\n~~~\ntemplate<typename T>\nclass Base{\npublic:\n  void print(){\n    static_cast<T*>(*this)->imp();\n  }\n  void imp(){\n    std::cout << \"this is base\" << std::endl;\n  }\n};\n\nclass Son1: public Base<Son1>{\n  void imp(){\n    std::cout << \"this is son 1\" << std::endl;\n  }\n};\n\nclass Son2: public Base<Son2>{\n  void imp(){\n    std::cout << \"this is son 2\" << std::endl;\n  }\n};\n\ntemplate<typename T>\nvoid func(T & t){\n  t.print();\n}\n~~~\n\n当我传入func的对象是Son1时， Base实例化为Son1，print中的static_cast就会把this指针强制转换为Son1*，也就能调用Son1自己实现的函数了，不过这里严格意义上来说并不算是多态，因为每个派生类继承的是各自实例化后的模板类，使用static_cast就能把从基类去访问派生类的成员函数了\n似乎llvm的visitor模式采用的就是这种捏，tvm中的貌似也有涉及这种设计，后续再看\n","slug":"CRTP与静态多态","published":1,"updated":"2022-09-09T01:21:33.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ui5zzd0001c6pv9drh4nqm","content":"<p>CuriouslyRecurringTemplatePattern，简称CRTP，是一种实现静态多态的机制，简单而言，他的核心在于：父类是一个模板类，派生类会继承父类，且以派生类自身作为父类的模板参数，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">class Base&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">  void print()&#123;</span><br><span class=\"line\">    static_cast&lt;T*&gt;(*this)-&gt;imp();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void imp()&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;this is base&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Son1: public Base&lt;Son1&gt;&#123;</span><br><span class=\"line\">  void imp()&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;this is son 1&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Son2: public Base&lt;Son2&gt;&#123;</span><br><span class=\"line\">  void imp()&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;this is son 2&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(T &amp; t)&#123;</span><br><span class=\"line\">  t.print();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我传入func的对象是Son1时， Base实例化为Son1，print中的static_cast就会把this指针强制转换为Son1*，也就能调用Son1自己实现的函数了，不过这里严格意义上来说并不算是多态，因为每个派生类继承的是各自实例化后的模板类，使用static_cast就能把从基类去访问派生类的成员函数了<br>似乎llvm的visitor模式采用的就是这种捏，tvm中的貌似也有涉及这种设计，后续再看</p>\n","site":{"data":{}},"excerpt":"","more":"<p>CuriouslyRecurringTemplatePattern，简称CRTP，是一种实现静态多态的机制，简单而言，他的核心在于：父类是一个模板类，派生类会继承父类，且以派生类自身作为父类的模板参数，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">class Base&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">  void print()&#123;</span><br><span class=\"line\">    static_cast&lt;T*&gt;(*this)-&gt;imp();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void imp()&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;this is base&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Son1: public Base&lt;Son1&gt;&#123;</span><br><span class=\"line\">  void imp()&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;this is son 1&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Son2: public Base&lt;Son2&gt;&#123;</span><br><span class=\"line\">  void imp()&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;this is son 2&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(T &amp; t)&#123;</span><br><span class=\"line\">  t.print();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我传入func的对象是Son1时， Base实例化为Son1，print中的static_cast就会把this指针强制转换为Son1*，也就能调用Son1自己实现的函数了，不过这里严格意义上来说并不算是多态，因为每个派生类继承的是各自实例化后的模板类，使用static_cast就能把从基类去访问派生类的成员函数了<br>似乎llvm的visitor模式采用的就是这种捏，tvm中的貌似也有涉及这种设计，后续再看</p>\n"},{"title":"leveldb源码系列1-skiplist","date":"2022-09-09T02:24:02.000Z","_content":"\n本文分析的是leveldb中的跳表skip list的实现，他会把user key和user value打包成一个更大的key塞入list中\n跳表的一个例子如下图\n\n\n可以看到，每一个node，它都有不同的高度，且每个节点都在第0层都有出现，第0层就像最简单的链表一样，而到了上面的层数节点的个数越来越少，就像树状结构那种，跳表的许多操作都能在logn的复杂度下完成，\nleveldb的主要结构包括skiplist，内部是由一系列的node构成的，他还实现了一个iterator用于遍历\n接下来首先看node的实现\n~~~\ntemplate <typename Key, class Comparator>\nstruct SkipList<Key, Comparator>::Node {\n  explicit Node(const Key& k) : key(k) {}\n\n  Key const key;\n\n  // Accessors/mutators for links.  Wrapped in methods so we can\n  // add the appropriate barriers as necessary.\n  Node* Next(int n) {\n    assert(n >= 0);\n    // Use an 'acquire load' so that we observe a fully initialized\n    // version of the returned Node.\n    return next_[n].load(std::memory_order_acquire);\n  }\n  void SetNext(int n, Node* x) {\n    assert(n >= 0);\n    // Use a 'release store' so that anybody who reads through this\n    // pointer observes a fully initialized version of the inserted node.\n    next_[n].store(x, std::memory_order_release);\n  }\n\n  // No-barrier variants that can be safely used in a few locations.\n  Node* NoBarrier_Next(int n) {\n    assert(n >= 0);\n    return next_[n].load(std::memory_order_relaxed);\n  }\n  void NoBarrier_SetNext(int n, Node* x) {\n    assert(n >= 0);\n    next_[n].store(x, std::memory_order_relaxed);\n  }\n   private:\n  // Array of length equal to the node height.  next_[0] is lowest level link.\n  // 1) 这里提前声明并申请了一个内存，用于存储第 0 层的数据，因为第 0 层必然存在数据。\n  // 2) 这里的数组长度其实就是层高，假设 next_ 长度为 n，那么就会从 next_[n-1] 开始查找。\n  // 3) 因为 skip list 的 level 并不会太大，使用数组存储 Node 指针的话对 CPU 内存更友好\n  // https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf\n  std::atomic<Node*> next_[1];\n};\n~~~\n第一部分主要是1个显式的构造函数，指定某个键并初始化key这个成员数据，然后是他的next_数组，这个数组主要是用来存放该结点的每一层的next结点的指针的，指定为1是因为必然要在第0层有该结点，接下来是他的2个无锁操作和2个不用内存屏障的操作，next这个无锁操作使用了next_这个原子对象的load函数，且指定了memory_order_acquire,那么在这个语句之前的都不会被重排到他后面了，而setnext则是store函数，指定了memory_order_release，则该语句后面的内容都不会重排到他前面去，\n后面的2个则是使用了memory_order_relaxed,他只保证这条语句他是原子的，语句前后怎么重排都没有限制\n接下来是一个生成新结点的函数\n\n~~~\ntemplate <typename Key, class Comparator>\ntypename SkipList<Key, Comparator>::Node* SkipList<Key, Comparator>::NewNode(\n    const Key& key, int height) {\n  // 内存分配时只需要再分配 level - 1 层，因为第 0 层已经预先分配完毕了。\n  char* const node_memory = arena_->AllocateAligned(\n      sizeof(Node) + sizeof(std::atomic<Node*>) * (height - 1));\n  // 这里是 placement new 的写法，在现有的内存上进行 new object\n  return new (node_memory) Node(key);\n}\n~~~\n第2行开头的typename是为了告诉编译器，后面这个::Node是一个类型，那么整个函数的返回值就是NOde*了，首先分配内存，然后在这个内存上placement new，调用node的构造函数了\n\n接下来是skiplist的成员函数\n第一个是生成随机层数的函数\n~~~\ntemplate <typename Key, class Comparator>\nint SkipList<Key, Comparator>::RandomHeight() {\n  // Increase height with probability 1 in kBranching\n  static const unsigned int kBranching = 4;\n  int height = 1;\n  while (height < kMaxHeight && ((rnd_.Next() % kBranching) == 0)) {\n    height++;\n  }\n  assert(height > 0);\n  assert(height <= kMaxHeight);\n  return height;\n}\n~~~\n首先初始化height为1，接着以1/4的概率使得while成立（在height比kmaxheight小的情况下），这样子第1层的node个数就大致是第0的1/4了，后面的层数以此类推，而用1/4这个概率貌似也是提出跳表的论文中建议的？\n接下来是一个key的大小顺序的函数\n~~~\ntemplate <typename Key, class Comparator>\nbool SkipList<Key, Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {\n  // null n is considered infinite\n  return (n != nullptr) && (compare_(n->key, key) < 0);\n}\n~~~\n当要比较的对象（比如说是next节点指向的某一层对象）不为空且compare比较器得到的结果小于0时，说明这个key在顺序上是在n后面的，\n\n接下来就是查找在每一层上\n~~~\ntemplate <typename Key, class Comparator>\ntypename SkipList<Key, Comparator>::Node*\nSkipList<Key, Comparator>::FindGreaterOrEqual(const Key& key,\n                                              Node** prev) const {\n  Node* x = head_;\n  int level = GetMaxHeight() - 1;\n  while (true) {\n    /* 获取当前 level 层的下一个节点 */\n    Node* next = x->Next(level);\n\n    if (KeyIsAfterNode(key, next)) {\n      // Keep searching in this list\n      x = next;\n    } else {\n      // prev 数组主要记录的就是每一层的 prev 节点，主要用于插入和删除时使用\n      if (prev != nullptr) prev[level] = x;\n      if (level == 0) {\n        return next;\n      } else {\n        // Switch to next list\n        level--;\n      }\n    }\n  }\n}\n~~~\n其中的GetMaxHeight函数获取的是当前结点的层数，我们从这个节点的最高层开始找，不断获取他的next节点，判断这个node他\n\n\n\n","source":"_posts/leveldb源码系列1-skiplist.md","raw":"---\ntitle: leveldb源码系列1-skiplist\ndate: 2022-09-09 10:24:02\ntags: leveldb\n---\n\n本文分析的是leveldb中的跳表skip list的实现，他会把user key和user value打包成一个更大的key塞入list中\n跳表的一个例子如下图\n\n\n可以看到，每一个node，它都有不同的高度，且每个节点都在第0层都有出现，第0层就像最简单的链表一样，而到了上面的层数节点的个数越来越少，就像树状结构那种，跳表的许多操作都能在logn的复杂度下完成，\nleveldb的主要结构包括skiplist，内部是由一系列的node构成的，他还实现了一个iterator用于遍历\n接下来首先看node的实现\n~~~\ntemplate <typename Key, class Comparator>\nstruct SkipList<Key, Comparator>::Node {\n  explicit Node(const Key& k) : key(k) {}\n\n  Key const key;\n\n  // Accessors/mutators for links.  Wrapped in methods so we can\n  // add the appropriate barriers as necessary.\n  Node* Next(int n) {\n    assert(n >= 0);\n    // Use an 'acquire load' so that we observe a fully initialized\n    // version of the returned Node.\n    return next_[n].load(std::memory_order_acquire);\n  }\n  void SetNext(int n, Node* x) {\n    assert(n >= 0);\n    // Use a 'release store' so that anybody who reads through this\n    // pointer observes a fully initialized version of the inserted node.\n    next_[n].store(x, std::memory_order_release);\n  }\n\n  // No-barrier variants that can be safely used in a few locations.\n  Node* NoBarrier_Next(int n) {\n    assert(n >= 0);\n    return next_[n].load(std::memory_order_relaxed);\n  }\n  void NoBarrier_SetNext(int n, Node* x) {\n    assert(n >= 0);\n    next_[n].store(x, std::memory_order_relaxed);\n  }\n   private:\n  // Array of length equal to the node height.  next_[0] is lowest level link.\n  // 1) 这里提前声明并申请了一个内存，用于存储第 0 层的数据，因为第 0 层必然存在数据。\n  // 2) 这里的数组长度其实就是层高，假设 next_ 长度为 n，那么就会从 next_[n-1] 开始查找。\n  // 3) 因为 skip list 的 level 并不会太大，使用数组存储 Node 指针的话对 CPU 内存更友好\n  // https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf\n  std::atomic<Node*> next_[1];\n};\n~~~\n第一部分主要是1个显式的构造函数，指定某个键并初始化key这个成员数据，然后是他的next_数组，这个数组主要是用来存放该结点的每一层的next结点的指针的，指定为1是因为必然要在第0层有该结点，接下来是他的2个无锁操作和2个不用内存屏障的操作，next这个无锁操作使用了next_这个原子对象的load函数，且指定了memory_order_acquire,那么在这个语句之前的都不会被重排到他后面了，而setnext则是store函数，指定了memory_order_release，则该语句后面的内容都不会重排到他前面去，\n后面的2个则是使用了memory_order_relaxed,他只保证这条语句他是原子的，语句前后怎么重排都没有限制\n接下来是一个生成新结点的函数\n\n~~~\ntemplate <typename Key, class Comparator>\ntypename SkipList<Key, Comparator>::Node* SkipList<Key, Comparator>::NewNode(\n    const Key& key, int height) {\n  // 内存分配时只需要再分配 level - 1 层，因为第 0 层已经预先分配完毕了。\n  char* const node_memory = arena_->AllocateAligned(\n      sizeof(Node) + sizeof(std::atomic<Node*>) * (height - 1));\n  // 这里是 placement new 的写法，在现有的内存上进行 new object\n  return new (node_memory) Node(key);\n}\n~~~\n第2行开头的typename是为了告诉编译器，后面这个::Node是一个类型，那么整个函数的返回值就是NOde*了，首先分配内存，然后在这个内存上placement new，调用node的构造函数了\n\n接下来是skiplist的成员函数\n第一个是生成随机层数的函数\n~~~\ntemplate <typename Key, class Comparator>\nint SkipList<Key, Comparator>::RandomHeight() {\n  // Increase height with probability 1 in kBranching\n  static const unsigned int kBranching = 4;\n  int height = 1;\n  while (height < kMaxHeight && ((rnd_.Next() % kBranching) == 0)) {\n    height++;\n  }\n  assert(height > 0);\n  assert(height <= kMaxHeight);\n  return height;\n}\n~~~\n首先初始化height为1，接着以1/4的概率使得while成立（在height比kmaxheight小的情况下），这样子第1层的node个数就大致是第0的1/4了，后面的层数以此类推，而用1/4这个概率貌似也是提出跳表的论文中建议的？\n接下来是一个key的大小顺序的函数\n~~~\ntemplate <typename Key, class Comparator>\nbool SkipList<Key, Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {\n  // null n is considered infinite\n  return (n != nullptr) && (compare_(n->key, key) < 0);\n}\n~~~\n当要比较的对象（比如说是next节点指向的某一层对象）不为空且compare比较器得到的结果小于0时，说明这个key在顺序上是在n后面的，\n\n接下来就是查找在每一层上\n~~~\ntemplate <typename Key, class Comparator>\ntypename SkipList<Key, Comparator>::Node*\nSkipList<Key, Comparator>::FindGreaterOrEqual(const Key& key,\n                                              Node** prev) const {\n  Node* x = head_;\n  int level = GetMaxHeight() - 1;\n  while (true) {\n    /* 获取当前 level 层的下一个节点 */\n    Node* next = x->Next(level);\n\n    if (KeyIsAfterNode(key, next)) {\n      // Keep searching in this list\n      x = next;\n    } else {\n      // prev 数组主要记录的就是每一层的 prev 节点，主要用于插入和删除时使用\n      if (prev != nullptr) prev[level] = x;\n      if (level == 0) {\n        return next;\n      } else {\n        // Switch to next list\n        level--;\n      }\n    }\n  }\n}\n~~~\n其中的GetMaxHeight函数获取的是当前结点的层数，我们从这个节点的最高层开始找，不断获取他的next节点，判断这个node他\n\n\n\n","slug":"leveldb源码系列1-skiplist","published":1,"updated":"2022-09-09T13:16:49.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ui5zzg0003c6pv2m0z8zfq","content":"<p>本文分析的是leveldb中的跳表skip list的实现，他会把user key和user value打包成一个更大的key塞入list中<br>跳表的一个例子如下图</p>\n<p>可以看到，每一个node，它都有不同的高度，且每个节点都在第0层都有出现，第0层就像最简单的链表一样，而到了上面的层数节点的个数越来越少，就像树状结构那种，跳表的许多操作都能在logn的复杂度下完成，<br>leveldb的主要结构包括skiplist，内部是由一系列的node构成的，他还实现了一个iterator用于遍历<br>接下来首先看node的实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename Key, class Comparator&gt;</span><br><span class=\"line\">struct SkipList&lt;Key, Comparator&gt;::Node &#123;</span><br><span class=\"line\">  explicit Node(const Key&amp; k) : key(k) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Key const key;</span><br><span class=\"line\"></span><br><span class=\"line\">  // Accessors/mutators for links.  Wrapped in methods so we can</span><br><span class=\"line\">  // add the appropriate barriers as necessary.</span><br><span class=\"line\">  Node* Next(int n) &#123;</span><br><span class=\"line\">    assert(n &gt;= 0);</span><br><span class=\"line\">    // Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span><br><span class=\"line\">    // version of the returned Node.</span><br><span class=\"line\">    return next_[n].load(std::memory_order_acquire);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void SetNext(int n, Node* x) &#123;</span><br><span class=\"line\">    assert(n &gt;= 0);</span><br><span class=\"line\">    // Use a &#x27;release store&#x27; so that anybody who reads through this</span><br><span class=\"line\">    // pointer observes a fully initialized version of the inserted node.</span><br><span class=\"line\">    next_[n].store(x, std::memory_order_release);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // No-barrier variants that can be safely used in a few locations.</span><br><span class=\"line\">  Node* NoBarrier_Next(int n) &#123;</span><br><span class=\"line\">    assert(n &gt;= 0);</span><br><span class=\"line\">    return next_[n].load(std::memory_order_relaxed);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void NoBarrier_SetNext(int n, Node* x) &#123;</span><br><span class=\"line\">    assert(n &gt;= 0);</span><br><span class=\"line\">    next_[n].store(x, std::memory_order_relaxed);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   private:</span><br><span class=\"line\">  // Array of length equal to the node height.  next_[0] is lowest level link.</span><br><span class=\"line\">  // 1) 这里提前声明并申请了一个内存，用于存储第 0 层的数据，因为第 0 层必然存在数据。</span><br><span class=\"line\">  // 2) 这里的数组长度其实就是层高，假设 next_ 长度为 n，那么就会从 next_[n-1] 开始查找。</span><br><span class=\"line\">  // 3) 因为 skip list 的 level 并不会太大，使用数组存储 Node 指针的话对 CPU 内存更友好</span><br><span class=\"line\">  // https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf</span><br><span class=\"line\">  std::atomic&lt;Node*&gt; next_[1];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>第一部分主要是1个显式的构造函数，指定某个键并初始化key这个成员数据，然后是他的next_数组，这个数组主要是用来存放该结点的每一层的next结点的指针的，指定为1是因为必然要在第0层有该结点，接下来是他的2个无锁操作和2个不用内存屏障的操作，next这个无锁操作使用了next_这个原子对象的load函数，且指定了memory_order_acquire,那么在这个语句之前的都不会被重排到他后面了，而setnext则是store函数，指定了memory_order_release，则该语句后面的内容都不会重排到他前面去，<br>后面的2个则是使用了memory_order_relaxed,他只保证这条语句他是原子的，语句前后怎么重排都没有限制<br>接下来是一个生成新结点的函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename Key, class Comparator&gt;</span><br><span class=\"line\">typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::NewNode(</span><br><span class=\"line\">    const Key&amp; key, int height) &#123;</span><br><span class=\"line\">  // 内存分配时只需要再分配 level - 1 层，因为第 0 层已经预先分配完毕了。</span><br><span class=\"line\">  char* const node_memory = arena_-&gt;AllocateAligned(</span><br><span class=\"line\">      sizeof(Node) + sizeof(std::atomic&lt;Node*&gt;) * (height - 1));</span><br><span class=\"line\">  // 这里是 placement new 的写法，在现有的内存上进行 new object</span><br><span class=\"line\">  return new (node_memory) Node(key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第2行开头的typename是为了告诉编译器，后面这个::Node是一个类型，那么整个函数的返回值就是NOde*了，首先分配内存，然后在这个内存上placement new，调用node的构造函数了</p>\n<p>接下来是skiplist的成员函数<br>第一个是生成随机层数的函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename Key, class Comparator&gt;</span><br><span class=\"line\">int SkipList&lt;Key, Comparator&gt;::RandomHeight() &#123;</span><br><span class=\"line\">  // Increase height with probability 1 in kBranching</span><br><span class=\"line\">  static const unsigned int kBranching = 4;</span><br><span class=\"line\">  int height = 1;</span><br><span class=\"line\">  while (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == 0)) &#123;</span><br><span class=\"line\">    height++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  assert(height &gt; 0);</span><br><span class=\"line\">  assert(height &lt;= kMaxHeight);</span><br><span class=\"line\">  return height;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先初始化height为1，接着以1/4的概率使得while成立（在height比kmaxheight小的情况下），这样子第1层的node个数就大致是第0的1/4了，后面的层数以此类推，而用1/4这个概率貌似也是提出跳表的论文中建议的？<br>接下来是一个key的大小顺序的函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename Key, class Comparator&gt;</span><br><span class=\"line\">bool SkipList&lt;Key, Comparator&gt;::KeyIsAfterNode(const Key&amp; key, Node* n) const &#123;</span><br><span class=\"line\">  // null n is considered infinite</span><br><span class=\"line\">  return (n != nullptr) &amp;&amp; (compare_(n-&gt;key, key) &lt; 0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当要比较的对象（比如说是next节点指向的某一层对象）不为空且compare比较器得到的结果小于0时，说明这个key在顺序上是在n后面的，</p>\n<p>接下来就是查找在每一层上</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename Key, class Comparator&gt;</span><br><span class=\"line\">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class=\"line\">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(const Key&amp; key,</span><br><span class=\"line\">                                              Node** prev) const &#123;</span><br><span class=\"line\">  Node* x = head_;</span><br><span class=\"line\">  int level = GetMaxHeight() - 1;</span><br><span class=\"line\">  while (true) &#123;</span><br><span class=\"line\">    /* 获取当前 level 层的下一个节点 */</span><br><span class=\"line\">    Node* next = x-&gt;Next(level);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (KeyIsAfterNode(key, next)) &#123;</span><br><span class=\"line\">      // Keep searching in this list</span><br><span class=\"line\">      x = next;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // prev 数组主要记录的就是每一层的 prev 节点，主要用于插入和删除时使用</span><br><span class=\"line\">      if (prev != nullptr) prev[level] = x;</span><br><span class=\"line\">      if (level == 0) &#123;</span><br><span class=\"line\">        return next;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        // Switch to next list</span><br><span class=\"line\">        level--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中的GetMaxHeight函数获取的是当前结点的层数，我们从这个节点的最高层开始找，不断获取他的next节点，判断这个node他</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文分析的是leveldb中的跳表skip list的实现，他会把user key和user value打包成一个更大的key塞入list中<br>跳表的一个例子如下图</p>\n<p>可以看到，每一个node，它都有不同的高度，且每个节点都在第0层都有出现，第0层就像最简单的链表一样，而到了上面的层数节点的个数越来越少，就像树状结构那种，跳表的许多操作都能在logn的复杂度下完成，<br>leveldb的主要结构包括skiplist，内部是由一系列的node构成的，他还实现了一个iterator用于遍历<br>接下来首先看node的实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename Key, class Comparator&gt;</span><br><span class=\"line\">struct SkipList&lt;Key, Comparator&gt;::Node &#123;</span><br><span class=\"line\">  explicit Node(const Key&amp; k) : key(k) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Key const key;</span><br><span class=\"line\"></span><br><span class=\"line\">  // Accessors/mutators for links.  Wrapped in methods so we can</span><br><span class=\"line\">  // add the appropriate barriers as necessary.</span><br><span class=\"line\">  Node* Next(int n) &#123;</span><br><span class=\"line\">    assert(n &gt;= 0);</span><br><span class=\"line\">    // Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span><br><span class=\"line\">    // version of the returned Node.</span><br><span class=\"line\">    return next_[n].load(std::memory_order_acquire);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void SetNext(int n, Node* x) &#123;</span><br><span class=\"line\">    assert(n &gt;= 0);</span><br><span class=\"line\">    // Use a &#x27;release store&#x27; so that anybody who reads through this</span><br><span class=\"line\">    // pointer observes a fully initialized version of the inserted node.</span><br><span class=\"line\">    next_[n].store(x, std::memory_order_release);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // No-barrier variants that can be safely used in a few locations.</span><br><span class=\"line\">  Node* NoBarrier_Next(int n) &#123;</span><br><span class=\"line\">    assert(n &gt;= 0);</span><br><span class=\"line\">    return next_[n].load(std::memory_order_relaxed);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void NoBarrier_SetNext(int n, Node* x) &#123;</span><br><span class=\"line\">    assert(n &gt;= 0);</span><br><span class=\"line\">    next_[n].store(x, std::memory_order_relaxed);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   private:</span><br><span class=\"line\">  // Array of length equal to the node height.  next_[0] is lowest level link.</span><br><span class=\"line\">  // 1) 这里提前声明并申请了一个内存，用于存储第 0 层的数据，因为第 0 层必然存在数据。</span><br><span class=\"line\">  // 2) 这里的数组长度其实就是层高，假设 next_ 长度为 n，那么就会从 next_[n-1] 开始查找。</span><br><span class=\"line\">  // 3) 因为 skip list 的 level 并不会太大，使用数组存储 Node 指针的话对 CPU 内存更友好</span><br><span class=\"line\">  // https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf</span><br><span class=\"line\">  std::atomic&lt;Node*&gt; next_[1];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>第一部分主要是1个显式的构造函数，指定某个键并初始化key这个成员数据，然后是他的next_数组，这个数组主要是用来存放该结点的每一层的next结点的指针的，指定为1是因为必然要在第0层有该结点，接下来是他的2个无锁操作和2个不用内存屏障的操作，next这个无锁操作使用了next_这个原子对象的load函数，且指定了memory_order_acquire,那么在这个语句之前的都不会被重排到他后面了，而setnext则是store函数，指定了memory_order_release，则该语句后面的内容都不会重排到他前面去，<br>后面的2个则是使用了memory_order_relaxed,他只保证这条语句他是原子的，语句前后怎么重排都没有限制<br>接下来是一个生成新结点的函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename Key, class Comparator&gt;</span><br><span class=\"line\">typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::NewNode(</span><br><span class=\"line\">    const Key&amp; key, int height) &#123;</span><br><span class=\"line\">  // 内存分配时只需要再分配 level - 1 层，因为第 0 层已经预先分配完毕了。</span><br><span class=\"line\">  char* const node_memory = arena_-&gt;AllocateAligned(</span><br><span class=\"line\">      sizeof(Node) + sizeof(std::atomic&lt;Node*&gt;) * (height - 1));</span><br><span class=\"line\">  // 这里是 placement new 的写法，在现有的内存上进行 new object</span><br><span class=\"line\">  return new (node_memory) Node(key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第2行开头的typename是为了告诉编译器，后面这个::Node是一个类型，那么整个函数的返回值就是NOde*了，首先分配内存，然后在这个内存上placement new，调用node的构造函数了</p>\n<p>接下来是skiplist的成员函数<br>第一个是生成随机层数的函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename Key, class Comparator&gt;</span><br><span class=\"line\">int SkipList&lt;Key, Comparator&gt;::RandomHeight() &#123;</span><br><span class=\"line\">  // Increase height with probability 1 in kBranching</span><br><span class=\"line\">  static const unsigned int kBranching = 4;</span><br><span class=\"line\">  int height = 1;</span><br><span class=\"line\">  while (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == 0)) &#123;</span><br><span class=\"line\">    height++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  assert(height &gt; 0);</span><br><span class=\"line\">  assert(height &lt;= kMaxHeight);</span><br><span class=\"line\">  return height;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先初始化height为1，接着以1/4的概率使得while成立（在height比kmaxheight小的情况下），这样子第1层的node个数就大致是第0的1/4了，后面的层数以此类推，而用1/4这个概率貌似也是提出跳表的论文中建议的？<br>接下来是一个key的大小顺序的函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename Key, class Comparator&gt;</span><br><span class=\"line\">bool SkipList&lt;Key, Comparator&gt;::KeyIsAfterNode(const Key&amp; key, Node* n) const &#123;</span><br><span class=\"line\">  // null n is considered infinite</span><br><span class=\"line\">  return (n != nullptr) &amp;&amp; (compare_(n-&gt;key, key) &lt; 0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当要比较的对象（比如说是next节点指向的某一层对象）不为空且compare比较器得到的结果小于0时，说明这个key在顺序上是在n后面的，</p>\n<p>接下来就是查找在每一层上</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename Key, class Comparator&gt;</span><br><span class=\"line\">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class=\"line\">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(const Key&amp; key,</span><br><span class=\"line\">                                              Node** prev) const &#123;</span><br><span class=\"line\">  Node* x = head_;</span><br><span class=\"line\">  int level = GetMaxHeight() - 1;</span><br><span class=\"line\">  while (true) &#123;</span><br><span class=\"line\">    /* 获取当前 level 层的下一个节点 */</span><br><span class=\"line\">    Node* next = x-&gt;Next(level);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (KeyIsAfterNode(key, next)) &#123;</span><br><span class=\"line\">      // Keep searching in this list</span><br><span class=\"line\">      x = next;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // prev 数组主要记录的就是每一层的 prev 节点，主要用于插入和删除时使用</span><br><span class=\"line\">      if (prev != nullptr) prev[level] = x;</span><br><span class=\"line\">      if (level == 0) &#123;</span><br><span class=\"line\">        return next;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        // Switch to next list</span><br><span class=\"line\">        level--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中的GetMaxHeight函数获取的是当前结点的层数，我们从这个节点的最高层开始找，不断获取他的next节点，判断这个node他</p>\n"},{"title":"tvm系列1——te代码阅读","date":"2022-09-08T05:06:11.000Z","_content":"\n\n这篇是想探索一下tvm的te的compute和schedule具体的实现代码，\n~~~\nn = te.var(\"n\")\nA = te.placeholder((n,), name=\"A\")\nB = te.placeholder((n,), name=\"B\")\nC = te.compute(A.shape, lambda i: A[i] + B[i], name=\"C\")\n~~~\n上面这段假如熟悉tvm的应该再熟悉不过了，首先第1句话，返回的是tvm.tir.Var的数据类型的变量，这个是tir上的数据结构，后面再解析\n下面的A和B的placeholder如下\n~~~\ndef placeholder(shape, dtype=None, name=\"placeholder\"):\n    shape = (shape,) if isinstance(shape, tvm.tir.PrimExpr) else shape\n    dtype = \"float32\" if dtype is None else dtype\n    return _ffi_api.Placeholder(shape, dtype, name)\n~~~\n这个tvm.tir.PrimExpr是tir大多数类的父类，然后就会调用ffi机制去使用c++写的代码，这里也没啥可以说的，返回的就是\n\n到了compute，这里源码的一开始一大段都是处理参数变量名称的，不用理会，这里他会if else到最后，直接把argspec.args当做arg——names，这里他是使用inspect的getfullargspec去获取一个lambda表达式的所有信息的\n到下面\ndim_var = [tvm.tir.IterVar((0, s), x, 0) for x, s in zip(arg_names, shape[:out_ndim])]\n    body = fcompute(*[v.var for v in dim_var])\n\nout_ndim是第1个参数的维度，这里是1，然后s是只有1个，就是n，会用他们去构造IterVar，第1个参数是这个iter的范围，第2个是这个iter的标识，第3个是这个iter的类型，源码中写着他是datapar，应该是一般的那种iter这里构造出来的dim_var打印如下：\n~~~\n~~~\n接下来的body部分的var其实就是上面的第2个参数，fcompute就是C中的lambda表达式，首先把var的列表给解包，在调用fcompute这个可调用对象，就是上面C的lambda表达式，这里我们再写1个看看\n~~~\nn = te.var(\"n\")\nA = te.placeholder((n,n), name=\"A\")\nB = te.placeholder((n,n), name=\"B\")\nC = te.compute(A.shape, lambda i,j: A[i,j] + B[i,j], name=\"C\")\n~~~\n这里返回的body的类型是tvm.tir.expr.Add,主要是因为A和B都是tvm.te.Tensor,他们继承自ExprOp类，而这个类又写了一堆魔法方法，重载了一系列的运算符，比如说这里的+运算符，写了__add__函数后，最终调用这个函数\n假如说在compute中，有te.sum这种reduce操作的，还会识别出其中达到reduce_axis,\n","source":"_posts/tvm系列1——te代码阅读.md","raw":"---\ntitle: tvm系列1——te代码阅读\ndate: 2022-09-08 13:06:11\ntags: tvm\n---\n\n\n这篇是想探索一下tvm的te的compute和schedule具体的实现代码，\n~~~\nn = te.var(\"n\")\nA = te.placeholder((n,), name=\"A\")\nB = te.placeholder((n,), name=\"B\")\nC = te.compute(A.shape, lambda i: A[i] + B[i], name=\"C\")\n~~~\n上面这段假如熟悉tvm的应该再熟悉不过了，首先第1句话，返回的是tvm.tir.Var的数据类型的变量，这个是tir上的数据结构，后面再解析\n下面的A和B的placeholder如下\n~~~\ndef placeholder(shape, dtype=None, name=\"placeholder\"):\n    shape = (shape,) if isinstance(shape, tvm.tir.PrimExpr) else shape\n    dtype = \"float32\" if dtype is None else dtype\n    return _ffi_api.Placeholder(shape, dtype, name)\n~~~\n这个tvm.tir.PrimExpr是tir大多数类的父类，然后就会调用ffi机制去使用c++写的代码，这里也没啥可以说的，返回的就是\n\n到了compute，这里源码的一开始一大段都是处理参数变量名称的，不用理会，这里他会if else到最后，直接把argspec.args当做arg——names，这里他是使用inspect的getfullargspec去获取一个lambda表达式的所有信息的\n到下面\ndim_var = [tvm.tir.IterVar((0, s), x, 0) for x, s in zip(arg_names, shape[:out_ndim])]\n    body = fcompute(*[v.var for v in dim_var])\n\nout_ndim是第1个参数的维度，这里是1，然后s是只有1个，就是n，会用他们去构造IterVar，第1个参数是这个iter的范围，第2个是这个iter的标识，第3个是这个iter的类型，源码中写着他是datapar，应该是一般的那种iter这里构造出来的dim_var打印如下：\n~~~\n~~~\n接下来的body部分的var其实就是上面的第2个参数，fcompute就是C中的lambda表达式，首先把var的列表给解包，在调用fcompute这个可调用对象，就是上面C的lambda表达式，这里我们再写1个看看\n~~~\nn = te.var(\"n\")\nA = te.placeholder((n,n), name=\"A\")\nB = te.placeholder((n,n), name=\"B\")\nC = te.compute(A.shape, lambda i,j: A[i,j] + B[i,j], name=\"C\")\n~~~\n这里返回的body的类型是tvm.tir.expr.Add,主要是因为A和B都是tvm.te.Tensor,他们继承自ExprOp类，而这个类又写了一堆魔法方法，重载了一系列的运算符，比如说这里的+运算符，写了__add__函数后，最终调用这个函数\n假如说在compute中，有te.sum这种reduce操作的，还会识别出其中达到reduce_axis,\n","slug":"tvm系列1——te代码阅读","published":1,"updated":"2022-09-09T14:41:15.922Z","_id":"cl7ui5zzh0005c6pv5qw88b4p","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这篇是想探索一下tvm的te的compute和schedule具体的实现代码，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = te.var(&quot;n&quot;)</span><br><span class=\"line\">A = te.placeholder((n,), name=&quot;A&quot;)</span><br><span class=\"line\">B = te.placeholder((n,), name=&quot;B&quot;)</span><br><span class=\"line\">C = te.compute(A.shape, lambda i: A[i] + B[i], name=&quot;C&quot;)</span><br></pre></td></tr></table></figure>\n<p>上面这段假如熟悉tvm的应该再熟悉不过了，首先第1句话，返回的是tvm.tir.Var的数据类型的变量，这个是tir上的数据结构，后面再解析<br>下面的A和B的placeholder如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def placeholder(shape, dtype=None, name=&quot;placeholder&quot;):</span><br><span class=\"line\">    shape = (shape,) if isinstance(shape, tvm.tir.PrimExpr) else shape</span><br><span class=\"line\">    dtype = &quot;float32&quot; if dtype is None else dtype</span><br><span class=\"line\">    return _ffi_api.Placeholder(shape, dtype, name)</span><br></pre></td></tr></table></figure>\n<p>这个tvm.tir.PrimExpr是tir大多数类的父类，然后就会调用ffi机制去使用c++写的代码，这里也没啥可以说的，返回的就是</p>\n<p>到了compute，这里源码的一开始一大段都是处理参数变量名称的，不用理会，这里他会if else到最后，直接把argspec.args当做arg——names，这里他是使用inspect的getfullargspec去获取一个lambda表达式的所有信息的<br>到下面<br>dim_var = [tvm.tir.IterVar((0, s), x, 0) for x, s in zip(arg_names, shape[:out_ndim])]<br>    body = fcompute(*[v.var for v in dim_var])</p>\n<p>out_ndim是第1个参数的维度，这里是1，然后s是只有1个，就是n，会用他们去构造IterVar，第1个参数是这个iter的范围，第2个是这个iter的标识，第3个是这个iter的类型，源码中写着他是datapar，应该是一般的那种iter这里构造出来的dim_var打印如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~~~</span><br><span class=\"line\">接下来的body部分的var其实就是上面的第2个参数，fcompute就是C中的lambda表达式，首先把var的列表给解包，在调用fcompute这个可调用对象，就是上面C的lambda表达式，这里我们再写1个看看</span><br></pre></td></tr></table></figure>\n<p>n = te.var(“n”)<br>A = te.placeholder((n,n), name=”A”)<br>B = te.placeholder((n,n), name=”B”)<br>C = te.compute(A.shape, lambda i,j: A[i,j] + B[i,j], name=”C”)</p>\n<pre><code>这里返回的body的类型是tvm.tir.expr.Add,主要是因为A和B都是tvm.te.Tensor,他们继承自ExprOp类，而这个类又写了一堆魔法方法，重载了一系列的运算符，比如说这里的+运算符，写了__add__函数后，最终调用这个函数\n假如说在compute中，有te.sum这种reduce操作的，还会识别出其中达到reduce_axis,\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>这篇是想探索一下tvm的te的compute和schedule具体的实现代码，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = te.var(&quot;n&quot;)</span><br><span class=\"line\">A = te.placeholder((n,), name=&quot;A&quot;)</span><br><span class=\"line\">B = te.placeholder((n,), name=&quot;B&quot;)</span><br><span class=\"line\">C = te.compute(A.shape, lambda i: A[i] + B[i], name=&quot;C&quot;)</span><br></pre></td></tr></table></figure>\n<p>上面这段假如熟悉tvm的应该再熟悉不过了，首先第1句话，返回的是tvm.tir.Var的数据类型的变量，这个是tir上的数据结构，后面再解析<br>下面的A和B的placeholder如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def placeholder(shape, dtype=None, name=&quot;placeholder&quot;):</span><br><span class=\"line\">    shape = (shape,) if isinstance(shape, tvm.tir.PrimExpr) else shape</span><br><span class=\"line\">    dtype = &quot;float32&quot; if dtype is None else dtype</span><br><span class=\"line\">    return _ffi_api.Placeholder(shape, dtype, name)</span><br></pre></td></tr></table></figure>\n<p>这个tvm.tir.PrimExpr是tir大多数类的父类，然后就会调用ffi机制去使用c++写的代码，这里也没啥可以说的，返回的就是</p>\n<p>到了compute，这里源码的一开始一大段都是处理参数变量名称的，不用理会，这里他会if else到最后，直接把argspec.args当做arg——names，这里他是使用inspect的getfullargspec去获取一个lambda表达式的所有信息的<br>到下面<br>dim_var = [tvm.tir.IterVar((0, s), x, 0) for x, s in zip(arg_names, shape[:out_ndim])]<br>    body = fcompute(*[v.var for v in dim_var])</p>\n<p>out_ndim是第1个参数的维度，这里是1，然后s是只有1个，就是n，会用他们去构造IterVar，第1个参数是这个iter的范围，第2个是这个iter的标识，第3个是这个iter的类型，源码中写着他是datapar，应该是一般的那种iter这里构造出来的dim_var打印如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~~~</span><br><span class=\"line\">接下来的body部分的var其实就是上面的第2个参数，fcompute就是C中的lambda表达式，首先把var的列表给解包，在调用fcompute这个可调用对象，就是上面C的lambda表达式，这里我们再写1个看看</span><br></pre></td></tr></table></figure>\n<p>n = te.var(“n”)<br>A = te.placeholder((n,n), name=”A”)<br>B = te.placeholder((n,n), name=”B”)<br>C = te.compute(A.shape, lambda i,j: A[i,j] + B[i,j], name=”C”)</p>\n<pre><code>这里返回的body的类型是tvm.tir.expr.Add,主要是因为A和B都是tvm.te.Tensor,他们继承自ExprOp类，而这个类又写了一堆魔法方法，重载了一系列的运算符，比如说这里的+运算符，写了__add__函数后，最终调用这个函数\n假如说在compute中，有te.sum这种reduce操作的，还会识别出其中达到reduce_axis,\n</code></pre>\n"},{"title":"effective modern c ++ 1-3","date":"2022-09-12T08:24:12.000Z","_content":"\n条款1是对模板参数推导的几个细则，具体以下代码\n~~~\ntemplate <typename T>\nvoid func(ParamType param){}\n~~~\n使用func(expr)去调用时，它会推导T和param的形别，这2种有的时候是一样的，有的时候由于常量这些标识而不同，例如\n~~~\ntemplate <typename T>\nvoid func(const T& param){}\n~~~\n在使用一个int 变量i去调用func时，T是iNT,而PARAMTYPE是const int&\n具体则分三种情况去讨论\n第1种是paramtype是一个非万能引用，此时的判断方法是：如果expr具有引用，把引用给忽略，然后再去推导，如下\n~~~\ntemplate <typename T>\nvoid func(T& param){}\n\nint x = 2;\nconst int cx = x;\nconst int& rx = x;\n~~~\n那么在调用func的时候，对x，T是int，paramtype是int&，而后面2个T是const int，而paramtype是const int&，因为第3个expr的引用是会被忽略的，这里也可以看出，持有T&的模板，它能保证传进来的对量的常量性能被捕获\n第2种是paramtype是一个万能引用，如\n~~~\ntemplate<typename T>\nvoid func(T&& param){}\n~~~\n这个时候就使用引用折叠，可知如果传进来的expr是左值，T和paramtype都会推导为左值引用，如果expr是右值，则根据1的规矩即可\n\n第3种情况就是paramtype不是引用，那么就是说函数是按值传参的，他复制了一个新的对象，此时他对expr，会忽视他的const，volatile和引用，所以对上面的，x，cx，rx，如果模板声明如下\n~~~\ntemplate<typename T>\nvoid func(T param)\n~~~\n那么T和paramtype最终都是int，这个也是可以理解的——本身传进来后我是构建的新的对象，不会对外面的一切造成干扰\n这里还有1种特殊情况，即指向常量的常量指针，const int * const ptr,那么传进来之后，*右边的const会被忽略，因为传进来的本质是1个地址，这个值就像前面那个const int一样，所以他就被忽略了，那么进来后，T会被推导为const int*，指向常量的指针\n最后就是关于数组的问题了，这里直接结论如下：\n当paramtype是T param时，数组形参会退化为1个指针例如\ntemplate<typename T>\nvoid func(T param)\nconst char name[] = \"22\";\n此时把name传进来时，T会推导为const char*\n但假如paramtype是个引用，T则会推导为const char[3],而paramtype则是cost char（&）[13]\n我们可以用这一特性去推导数组长度\n~~~\ntemplate<typename T, int N>\nconstexpr int getlen(T(&)[N]) noexcept{\n    return N;\n}\nint main(){\n int x[2] = {2,3};\n char y[getlen(x)];\n}\n~~~\n条款2是auto推导的规则，他的规则上和模板推导的基本一致，但有一点很特别，在使用c++11引入的初始化方式中，如下\n~~~\nauto x{3};\nauto x={3};\n~~~\n此时auto推导型别会推导出std:: initializer_list<int>，且其中只有1个元素的变量，所以如下代码编译是会失败的\n~~~\nauto y{2,3,3.0};\n~~~\n因为对std:: initializer_list<T>的T推导不出是什么\n这里的本质是有2次推导，第1个是推导出y的型别为std:: initializer_list（因为使用了大括号去初始化），第2次是推导std:: initializer_list<T>的T的类型，而如果我们想利用模板去实现这一点是做不到的，因为auto他本身对大括号初始化就假定了第1次推导必定是std:: initializer_list，而模板没办法，所以如果真要用模板，可以这么实现\n~~~\ntemplate<typename T>\nvoid func(std:: initializer_list<T> list);\n~~~\n对于func({2,3,3})的调用，上面模板就起效了\n最后还补充了1点，在c++14的标准中，可以单独用auto去说明函数返回值/lambda表达式的形参需要推导，但此时他是使用模板推导去推导的，所以说返回值不能使用大括号\n\n条款3是decltype的使用\n一般的，对于大多数std的容器，其[]的使用会返回对应位置的元素的引用，除了vector<bool>以外，\n而在c++14中，正如在条款2中提到的，我们可以只使用auto不加decltype去推导返回值类型，此时使用的是模板类型的推导，那以下代码就有问题了\n~~~\ntemplate<typename container, typename index>\nauto getindex(container & c,index i){\n    return c[i];\n}\n...\n std::vector<int> vec {3,4,4};\n getindex(vec,2) = 10;\n ...\n~~~\n上面的代码执行如下：首先这里采用的是模板推导，且auto没有&或者&&的修饰，即采用条款1种的第3种规则，此时型参的一切引用都会被忽略，即c[i]返回的int&被看成是int，那么T和paramtype就是int了，此时返回的是1个临时值，是个右值，不能放在等号左侧，所以很明显他会报错\n~~~\nerror: lvalue required as left operand of assignment\n  getindex(vec,2) = 10;\n~~~\n解决方法是把auto改成decltype（auto），告诉他说推导过程用的是decltype的规则，而他对于int&就是推导为int&，或者我们直接使用后置类型推导，也比较清晰\n那这里还有1个不完美的在于，getindex他只能接受1个左值容器，对于一些右值容器，比如说一些工厂函数的返回值，我们直接传入，此时需要用万能引用和完美转发去解决\n~~~\ntemplate<typename container, typename index>\ndecltype(auto) func(container && c, index i){\n    return std::forward<container>(c)[i];\n}\n~~~\n除此之外，decltype还有一个坑，如果decltype（sth），sth仅仅只是1个变量名，如x，一切如旧；但假如sth是(x),c++仍把他看做是左值表达式，此时decltype必须推导出是一个引用类型，那么对下列代码\n~~~\ndecltype(auto) func(){\n    int x = 2;\n    return (x);\n}\n~~~\n他会返回1个局部变量的引用，这是一个危险的未定义行为，所以使用decltype一定要小心，里面的东西到底是什么\n","source":"_posts/effective-modern-c-1-3.md","raw":"---\ntitle: effective modern c ++ 1-3\ndate: 2022-09-12 16:24:12\ntags: effective_modern_c++\n---\n\n条款1是对模板参数推导的几个细则，具体以下代码\n~~~\ntemplate <typename T>\nvoid func(ParamType param){}\n~~~\n使用func(expr)去调用时，它会推导T和param的形别，这2种有的时候是一样的，有的时候由于常量这些标识而不同，例如\n~~~\ntemplate <typename T>\nvoid func(const T& param){}\n~~~\n在使用一个int 变量i去调用func时，T是iNT,而PARAMTYPE是const int&\n具体则分三种情况去讨论\n第1种是paramtype是一个非万能引用，此时的判断方法是：如果expr具有引用，把引用给忽略，然后再去推导，如下\n~~~\ntemplate <typename T>\nvoid func(T& param){}\n\nint x = 2;\nconst int cx = x;\nconst int& rx = x;\n~~~\n那么在调用func的时候，对x，T是int，paramtype是int&，而后面2个T是const int，而paramtype是const int&，因为第3个expr的引用是会被忽略的，这里也可以看出，持有T&的模板，它能保证传进来的对量的常量性能被捕获\n第2种是paramtype是一个万能引用，如\n~~~\ntemplate<typename T>\nvoid func(T&& param){}\n~~~\n这个时候就使用引用折叠，可知如果传进来的expr是左值，T和paramtype都会推导为左值引用，如果expr是右值，则根据1的规矩即可\n\n第3种情况就是paramtype不是引用，那么就是说函数是按值传参的，他复制了一个新的对象，此时他对expr，会忽视他的const，volatile和引用，所以对上面的，x，cx，rx，如果模板声明如下\n~~~\ntemplate<typename T>\nvoid func(T param)\n~~~\n那么T和paramtype最终都是int，这个也是可以理解的——本身传进来后我是构建的新的对象，不会对外面的一切造成干扰\n这里还有1种特殊情况，即指向常量的常量指针，const int * const ptr,那么传进来之后，*右边的const会被忽略，因为传进来的本质是1个地址，这个值就像前面那个const int一样，所以他就被忽略了，那么进来后，T会被推导为const int*，指向常量的指针\n最后就是关于数组的问题了，这里直接结论如下：\n当paramtype是T param时，数组形参会退化为1个指针例如\ntemplate<typename T>\nvoid func(T param)\nconst char name[] = \"22\";\n此时把name传进来时，T会推导为const char*\n但假如paramtype是个引用，T则会推导为const char[3],而paramtype则是cost char（&）[13]\n我们可以用这一特性去推导数组长度\n~~~\ntemplate<typename T, int N>\nconstexpr int getlen(T(&)[N]) noexcept{\n    return N;\n}\nint main(){\n int x[2] = {2,3};\n char y[getlen(x)];\n}\n~~~\n条款2是auto推导的规则，他的规则上和模板推导的基本一致，但有一点很特别，在使用c++11引入的初始化方式中，如下\n~~~\nauto x{3};\nauto x={3};\n~~~\n此时auto推导型别会推导出std:: initializer_list<int>，且其中只有1个元素的变量，所以如下代码编译是会失败的\n~~~\nauto y{2,3,3.0};\n~~~\n因为对std:: initializer_list<T>的T推导不出是什么\n这里的本质是有2次推导，第1个是推导出y的型别为std:: initializer_list（因为使用了大括号去初始化），第2次是推导std:: initializer_list<T>的T的类型，而如果我们想利用模板去实现这一点是做不到的，因为auto他本身对大括号初始化就假定了第1次推导必定是std:: initializer_list，而模板没办法，所以如果真要用模板，可以这么实现\n~~~\ntemplate<typename T>\nvoid func(std:: initializer_list<T> list);\n~~~\n对于func({2,3,3})的调用，上面模板就起效了\n最后还补充了1点，在c++14的标准中，可以单独用auto去说明函数返回值/lambda表达式的形参需要推导，但此时他是使用模板推导去推导的，所以说返回值不能使用大括号\n\n条款3是decltype的使用\n一般的，对于大多数std的容器，其[]的使用会返回对应位置的元素的引用，除了vector<bool>以外，\n而在c++14中，正如在条款2中提到的，我们可以只使用auto不加decltype去推导返回值类型，此时使用的是模板类型的推导，那以下代码就有问题了\n~~~\ntemplate<typename container, typename index>\nauto getindex(container & c,index i){\n    return c[i];\n}\n...\n std::vector<int> vec {3,4,4};\n getindex(vec,2) = 10;\n ...\n~~~\n上面的代码执行如下：首先这里采用的是模板推导，且auto没有&或者&&的修饰，即采用条款1种的第3种规则，此时型参的一切引用都会被忽略，即c[i]返回的int&被看成是int，那么T和paramtype就是int了，此时返回的是1个临时值，是个右值，不能放在等号左侧，所以很明显他会报错\n~~~\nerror: lvalue required as left operand of assignment\n  getindex(vec,2) = 10;\n~~~\n解决方法是把auto改成decltype（auto），告诉他说推导过程用的是decltype的规则，而他对于int&就是推导为int&，或者我们直接使用后置类型推导，也比较清晰\n那这里还有1个不完美的在于，getindex他只能接受1个左值容器，对于一些右值容器，比如说一些工厂函数的返回值，我们直接传入，此时需要用万能引用和完美转发去解决\n~~~\ntemplate<typename container, typename index>\ndecltype(auto) func(container && c, index i){\n    return std::forward<container>(c)[i];\n}\n~~~\n除此之外，decltype还有一个坑，如果decltype（sth），sth仅仅只是1个变量名，如x，一切如旧；但假如sth是(x),c++仍把他看做是左值表达式，此时decltype必须推导出是一个引用类型，那么对下列代码\n~~~\ndecltype(auto) func(){\n    int x = 2;\n    return (x);\n}\n~~~\n他会返回1个局部变量的引用，这是一个危险的未定义行为，所以使用decltype一定要小心，里面的东西到底是什么\n","slug":"effective-modern-c-1-3","published":1,"updated":"2022-09-12T08:24:39.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yi1p530000capvccema4df","content":"<p>条款1是对模板参数推导的几个细则，具体以下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void func(ParamType param)&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>使用func(expr)去调用时，它会推导T和param的形别，这2种有的时候是一样的，有的时候由于常量这些标识而不同，例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void func(const T&amp; param)&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>在使用一个int 变量i去调用func时，T是iNT,而PARAMTYPE是const int&amp;<br>具体则分三种情况去讨论<br>第1种是paramtype是一个非万能引用，此时的判断方法是：如果expr具有引用，把引用给忽略，然后再去推导，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void func(T&amp; param)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int x = 2;</span><br><span class=\"line\">const int cx = x;</span><br><span class=\"line\">const int&amp; rx = x;</span><br></pre></td></tr></table></figure>\n<p>那么在调用func的时候，对x，T是int，paramtype是int&amp;，而后面2个T是const int，而paramtype是const int&amp;，因为第3个expr的引用是会被忽略的，这里也可以看出，持有T&amp;的模板，它能保证传进来的对量的常量性能被捕获<br>第2种是paramtype是一个万能引用，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(T&amp;&amp; param)&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>这个时候就使用引用折叠，可知如果传进来的expr是左值，T和paramtype都会推导为左值引用，如果expr是右值，则根据1的规矩即可</p>\n<p>第3种情况就是paramtype不是引用，那么就是说函数是按值传参的，他复制了一个新的对象，此时他对expr，会忽视他的const，volatile和引用，所以对上面的，x，cx，rx，如果模板声明如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(T param)</span><br></pre></td></tr></table></figure>\n<p>那么T和paramtype最终都是int，这个也是可以理解的——本身传进来后我是构建的新的对象，不会对外面的一切造成干扰<br>这里还有1种特殊情况，即指向常量的常量指针，const int * const ptr,那么传进来之后，<em>右边的const会被忽略，因为传进来的本质是1个地址，这个值就像前面那个const int一样，所以他就被忽略了，那么进来后，T会被推导为const int</em>，指向常量的指针<br>最后就是关于数组的问题了，这里直接结论如下：<br>当paramtype是T param时，数组形参会退化为1个指针例如<br>template<typename T><br>void func(T param)<br>const char name[] = “22”;<br>此时把name传进来时，T会推导为const char*<br>但假如paramtype是个引用，T则会推导为const char[3],而paramtype则是cost char（&amp;）[13]<br>我们可以用这一特性去推导数组长度</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T, int N&gt;</span><br><span class=\"line\">constexpr int getlen(T(&amp;)[N]) noexcept&#123;</span><br><span class=\"line\">    return N;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\"> int x[2] = &#123;2,3&#125;;</span><br><span class=\"line\"> char y[getlen(x)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>条款2是auto推导的规则，他的规则上和模板推导的基本一致，但有一点很特别，在使用c++11引入的初始化方式中，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto x&#123;3&#125;;</span><br><span class=\"line\">auto x=&#123;3&#125;;</span><br></pre></td></tr></table></figure>\n<p>此时auto推导型别会推导出std:: initializer_list<int>，且其中只有1个元素的变量，所以如下代码编译是会失败的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto y&#123;2,3,3.0&#125;;</span><br></pre></td></tr></table></figure>\n<p>因为对std:: initializer_list<T>的T推导不出是什么<br>这里的本质是有2次推导，第1个是推导出y的型别为std:: initializer_list（因为使用了大括号去初始化），第2次是推导std:: initializer_list<T>的T的类型，而如果我们想利用模板去实现这一点是做不到的，因为auto他本身对大括号初始化就假定了第1次推导必定是std:: initializer_list，而模板没办法，所以如果真要用模板，可以这么实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(std:: initializer_list&lt;T&gt; list);</span><br></pre></td></tr></table></figure>\n<p>对于func({2,3,3})的调用，上面模板就起效了<br>最后还补充了1点，在c++14的标准中，可以单独用auto去说明函数返回值/lambda表达式的形参需要推导，但此时他是使用模板推导去推导的，所以说返回值不能使用大括号</p>\n<p>条款3是decltype的使用<br>一般的，对于大多数std的容器，其[]的使用会返回对应位置的元素的引用，除了vector<bool>以外，<br>而在c++14中，正如在条款2中提到的，我们可以只使用auto不加decltype去推导返回值类型，此时使用的是模板类型的推导，那以下代码就有问题了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename container, typename index&gt;</span><br><span class=\"line\">auto getindex(container &amp; c,index i)&#123;</span><br><span class=\"line\">    return c[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"> std::vector&lt;int&gt; vec &#123;3,4,4&#125;;</span><br><span class=\"line\"> getindex(vec,2) = 10;</span><br><span class=\"line\"> ...</span><br></pre></td></tr></table></figure>\n<p>上面的代码执行如下：首先这里采用的是模板推导，且auto没有&amp;或者&amp;&amp;的修饰，即采用条款1种的第3种规则，此时型参的一切引用都会被忽略，即c[i]返回的int&amp;被看成是int，那么T和paramtype就是int了，此时返回的是1个临时值，是个右值，不能放在等号左侧，所以很明显他会报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error: lvalue required as left operand of assignment</span><br><span class=\"line\">  getindex(vec,2) = 10;</span><br></pre></td></tr></table></figure>\n<p>解决方法是把auto改成decltype（auto），告诉他说推导过程用的是decltype的规则，而他对于int&amp;就是推导为int&amp;，或者我们直接使用后置类型推导，也比较清晰<br>那这里还有1个不完美的在于，getindex他只能接受1个左值容器，对于一些右值容器，比如说一些工厂函数的返回值，我们直接传入，此时需要用万能引用和完美转发去解决</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename container, typename index&gt;</span><br><span class=\"line\">decltype(auto) func(container &amp;&amp; c, index i)&#123;</span><br><span class=\"line\">    return std::forward&lt;container&gt;(c)[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除此之外，decltype还有一个坑，如果decltype（sth），sth仅仅只是1个变量名，如x，一切如旧；但假如sth是(x),c++仍把他看做是左值表达式，此时decltype必须推导出是一个引用类型，那么对下列代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">decltype(auto) func()&#123;</span><br><span class=\"line\">    int x = 2;</span><br><span class=\"line\">    return (x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>他会返回1个局部变量的引用，这是一个危险的未定义行为，所以使用decltype一定要小心，里面的东西到底是什么</p>\n","site":{"data":{}},"excerpt":"","more":"<p>条款1是对模板参数推导的几个细则，具体以下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void func(ParamType param)&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>使用func(expr)去调用时，它会推导T和param的形别，这2种有的时候是一样的，有的时候由于常量这些标识而不同，例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void func(const T&amp; param)&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>在使用一个int 变量i去调用func时，T是iNT,而PARAMTYPE是const int&amp;<br>具体则分三种情况去讨论<br>第1种是paramtype是一个非万能引用，此时的判断方法是：如果expr具有引用，把引用给忽略，然后再去推导，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void func(T&amp; param)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int x = 2;</span><br><span class=\"line\">const int cx = x;</span><br><span class=\"line\">const int&amp; rx = x;</span><br></pre></td></tr></table></figure>\n<p>那么在调用func的时候，对x，T是int，paramtype是int&amp;，而后面2个T是const int，而paramtype是const int&amp;，因为第3个expr的引用是会被忽略的，这里也可以看出，持有T&amp;的模板，它能保证传进来的对量的常量性能被捕获<br>第2种是paramtype是一个万能引用，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(T&amp;&amp; param)&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>这个时候就使用引用折叠，可知如果传进来的expr是左值，T和paramtype都会推导为左值引用，如果expr是右值，则根据1的规矩即可</p>\n<p>第3种情况就是paramtype不是引用，那么就是说函数是按值传参的，他复制了一个新的对象，此时他对expr，会忽视他的const，volatile和引用，所以对上面的，x，cx，rx，如果模板声明如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(T param)</span><br></pre></td></tr></table></figure>\n<p>那么T和paramtype最终都是int，这个也是可以理解的——本身传进来后我是构建的新的对象，不会对外面的一切造成干扰<br>这里还有1种特殊情况，即指向常量的常量指针，const int * const ptr,那么传进来之后，<em>右边的const会被忽略，因为传进来的本质是1个地址，这个值就像前面那个const int一样，所以他就被忽略了，那么进来后，T会被推导为const int</em>，指向常量的指针<br>最后就是关于数组的问题了，这里直接结论如下：<br>当paramtype是T param时，数组形参会退化为1个指针例如<br>template<typename T><br>void func(T param)<br>const char name[] = “22”;<br>此时把name传进来时，T会推导为const char*<br>但假如paramtype是个引用，T则会推导为const char[3],而paramtype则是cost char（&amp;）[13]<br>我们可以用这一特性去推导数组长度</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T, int N&gt;</span><br><span class=\"line\">constexpr int getlen(T(&amp;)[N]) noexcept&#123;</span><br><span class=\"line\">    return N;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\"> int x[2] = &#123;2,3&#125;;</span><br><span class=\"line\"> char y[getlen(x)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>条款2是auto推导的规则，他的规则上和模板推导的基本一致，但有一点很特别，在使用c++11引入的初始化方式中，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto x&#123;3&#125;;</span><br><span class=\"line\">auto x=&#123;3&#125;;</span><br></pre></td></tr></table></figure>\n<p>此时auto推导型别会推导出std:: initializer_list<int>，且其中只有1个元素的变量，所以如下代码编译是会失败的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto y&#123;2,3,3.0&#125;;</span><br></pre></td></tr></table></figure>\n<p>因为对std:: initializer_list<T>的T推导不出是什么<br>这里的本质是有2次推导，第1个是推导出y的型别为std:: initializer_list（因为使用了大括号去初始化），第2次是推导std:: initializer_list<T>的T的类型，而如果我们想利用模板去实现这一点是做不到的，因为auto他本身对大括号初始化就假定了第1次推导必定是std:: initializer_list，而模板没办法，所以如果真要用模板，可以这么实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(std:: initializer_list&lt;T&gt; list);</span><br></pre></td></tr></table></figure>\n<p>对于func({2,3,3})的调用，上面模板就起效了<br>最后还补充了1点，在c++14的标准中，可以单独用auto去说明函数返回值/lambda表达式的形参需要推导，但此时他是使用模板推导去推导的，所以说返回值不能使用大括号</p>\n<p>条款3是decltype的使用<br>一般的，对于大多数std的容器，其[]的使用会返回对应位置的元素的引用，除了vector<bool>以外，<br>而在c++14中，正如在条款2中提到的，我们可以只使用auto不加decltype去推导返回值类型，此时使用的是模板类型的推导，那以下代码就有问题了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename container, typename index&gt;</span><br><span class=\"line\">auto getindex(container &amp; c,index i)&#123;</span><br><span class=\"line\">    return c[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"> std::vector&lt;int&gt; vec &#123;3,4,4&#125;;</span><br><span class=\"line\"> getindex(vec,2) = 10;</span><br><span class=\"line\"> ...</span><br></pre></td></tr></table></figure>\n<p>上面的代码执行如下：首先这里采用的是模板推导，且auto没有&amp;或者&amp;&amp;的修饰，即采用条款1种的第3种规则，此时型参的一切引用都会被忽略，即c[i]返回的int&amp;被看成是int，那么T和paramtype就是int了，此时返回的是1个临时值，是个右值，不能放在等号左侧，所以很明显他会报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error: lvalue required as left operand of assignment</span><br><span class=\"line\">  getindex(vec,2) = 10;</span><br></pre></td></tr></table></figure>\n<p>解决方法是把auto改成decltype（auto），告诉他说推导过程用的是decltype的规则，而他对于int&amp;就是推导为int&amp;，或者我们直接使用后置类型推导，也比较清晰<br>那这里还有1个不完美的在于，getindex他只能接受1个左值容器，对于一些右值容器，比如说一些工厂函数的返回值，我们直接传入，此时需要用万能引用和完美转发去解决</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename container, typename index&gt;</span><br><span class=\"line\">decltype(auto) func(container &amp;&amp; c, index i)&#123;</span><br><span class=\"line\">    return std::forward&lt;container&gt;(c)[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除此之外，decltype还有一个坑，如果decltype（sth），sth仅仅只是1个变量名，如x，一切如旧；但假如sth是(x),c++仍把他看做是左值表达式，此时decltype必须推导出是一个引用类型，那么对下列代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">decltype(auto) func()&#123;</span><br><span class=\"line\">    int x = 2;</span><br><span class=\"line\">    return (x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>他会返回1个局部变量的引用，这是一个危险的未定义行为，所以使用decltype一定要小心，里面的东西到底是什么</p>\n"},{"title":"effective modern c ++ 4-6","date":"2022-09-12T12:40:52.000Z","_content":"\n\n条款4是教如何去获取类型推导结果的，第一种就是利用IDE去获取，第2种我们可以声明一个类模板但不去定义他，然后使用decltype(x)让编译器报错，如下\n~~~\ntemplate<typename T>\nclass TD;\n\n\nint main(){\n const int x = 3;\n TD<decltype(x)> xtype;\n}\n~~~\n此时编译器报错如下：\n~~~\nerror: aggregate ‘TD<const int> xtype’ has incomplete type and cannot be defined\n  TD<decltype(x)> xtype;\n~~~\n可以看到x的确被推导为const int\n还有1种就是使用type_info,在大多数情况下他是正确的，但他推导的方式是安值推导的，也就是说，引用和常量性会被忽略，所以他并不可靠，\n\n\n接下来是条款5，是开始了第2大章，关于auto的使用\n条款5具体讲了一些应用auto带来的方便与好处\n第1个就是在使用iterator的时候，如下\n~~~\ntemplate<typename It>\nvoid func(It b, It e){\n    while(b!=e){\n        typename std::iterator_traits<It>::value_type\n        val = *b;\n    }\n}\n~~~\n像上面这一段，我们使用萃取去获取这个迭代器到底指向啥东西，写起来十分的拗口麻烦，我们可以利用auto直接写成auto val = *b；\n第2个就是使用auto来保证变量一定能初始化，解决变量未初始化的行为\n~~~\nauto i; // 不能通过\nauto i = 2;\n~~~\n第3个就是使用lambda表达式时，这个lambda对象到底是个什么类型，这个是由编译器决定的，所以我们需要利用auto用来把lambda表达式赋值给某个变量名，如\n~~~\nauto lam = [](){ return 0; };\n~~~\n当然我们也可以用一个std::function去持有这个lambda，如\n~~~\nstd::function<bool(int,int)>\nmyfunc = [](int x, int y){ return true;};\n~~~\n而其缺点在于function本身就是一个对象，他本身就是需要内存的，在内存上来说auto来的更好，\n第4个就是对于一些硬件依赖的typename，比如unsigned，在32位上和在64位上不同的，单单指定某个变量是unsigned可能会在不同机器上带来出乎意料的结果，因此我们可以利用auto\n~~~\nauto size = v.size();\n~~~\n第5个还是在迭代的时候，我们对于一些容器他储存方式不熟悉带来的问题，如\n~~~\nfor(const std::pair<std::string, int> &p :m){...}\n~~~\nm是个unorder_map,他本身是由std::pair<const std::string, int>组成的，不是上面这种方式，也就是说，程序跑到这段代码，会复制容器里的每一个元素，然后引用再去指向这些临时对象，可想而知多非时间，而使用auto很容易就解决\n~~~\nfor（const auto &p:m){...}\n~~~\n当然了，auto也是得看实际的使用场景，大多数情况下使用得当能提升我们编程的效率的\n条款6 介绍的是使用auto可能遇到的坑，在这种时候就得采用传统的方式了\n第1个，就是vector<bool>这个和其他vector格格不入的对象，对于一般的vector<T>[],他能返回一个T&类型的东西，但vector<bool>他本身是特化过的，他底层是使用比特去表示这1个1个的bool，而c++又不能返回1个对比特的引用，所以他只能返回一个用来模拟bool&的reference，即std::vector<bool>::reference,他能够像bool进行隐式转换，所以对下面语句\n~~~\nvector<bool> vec{true,true};\nbool is_true = vec[0];\n~~~\n这里取出来的vec[0]实际是个std::vector<bool>::reference，但他可以转换为bool，所以没啥问题\n但假如我们使用auto去声明is_true,得到他类型就是std::vector<bool>::reference了，他就不是指代第1个元素是否为true的变量了\n书里介绍的这种情况带来的问题在于可能出现悬空指针，例如，当我们函数的返回值是个vector<bool>时，他是个临时对象，而他实现获取第1个元素的方式，有一种实现是通过指针+偏移量的方式去获取，而我们如果使用auto is_true = bool_vectroy()[0]时，is_true和临时对象的指针指向同一个东西，而临时对象在这一句话后就解析了，那is_true就指向1个被析构了的地址了，\n","source":"_posts/effective-modern-c-4-6.md","raw":"---\ntitle: effective modern c ++ 4-6\ndate: 2022-09-12 20:40:52\ntags: effective_modern_c++\n---\n\n\n条款4是教如何去获取类型推导结果的，第一种就是利用IDE去获取，第2种我们可以声明一个类模板但不去定义他，然后使用decltype(x)让编译器报错，如下\n~~~\ntemplate<typename T>\nclass TD;\n\n\nint main(){\n const int x = 3;\n TD<decltype(x)> xtype;\n}\n~~~\n此时编译器报错如下：\n~~~\nerror: aggregate ‘TD<const int> xtype’ has incomplete type and cannot be defined\n  TD<decltype(x)> xtype;\n~~~\n可以看到x的确被推导为const int\n还有1种就是使用type_info,在大多数情况下他是正确的，但他推导的方式是安值推导的，也就是说，引用和常量性会被忽略，所以他并不可靠，\n\n\n接下来是条款5，是开始了第2大章，关于auto的使用\n条款5具体讲了一些应用auto带来的方便与好处\n第1个就是在使用iterator的时候，如下\n~~~\ntemplate<typename It>\nvoid func(It b, It e){\n    while(b!=e){\n        typename std::iterator_traits<It>::value_type\n        val = *b;\n    }\n}\n~~~\n像上面这一段，我们使用萃取去获取这个迭代器到底指向啥东西，写起来十分的拗口麻烦，我们可以利用auto直接写成auto val = *b；\n第2个就是使用auto来保证变量一定能初始化，解决变量未初始化的行为\n~~~\nauto i; // 不能通过\nauto i = 2;\n~~~\n第3个就是使用lambda表达式时，这个lambda对象到底是个什么类型，这个是由编译器决定的，所以我们需要利用auto用来把lambda表达式赋值给某个变量名，如\n~~~\nauto lam = [](){ return 0; };\n~~~\n当然我们也可以用一个std::function去持有这个lambda，如\n~~~\nstd::function<bool(int,int)>\nmyfunc = [](int x, int y){ return true;};\n~~~\n而其缺点在于function本身就是一个对象，他本身就是需要内存的，在内存上来说auto来的更好，\n第4个就是对于一些硬件依赖的typename，比如unsigned，在32位上和在64位上不同的，单单指定某个变量是unsigned可能会在不同机器上带来出乎意料的结果，因此我们可以利用auto\n~~~\nauto size = v.size();\n~~~\n第5个还是在迭代的时候，我们对于一些容器他储存方式不熟悉带来的问题，如\n~~~\nfor(const std::pair<std::string, int> &p :m){...}\n~~~\nm是个unorder_map,他本身是由std::pair<const std::string, int>组成的，不是上面这种方式，也就是说，程序跑到这段代码，会复制容器里的每一个元素，然后引用再去指向这些临时对象，可想而知多非时间，而使用auto很容易就解决\n~~~\nfor（const auto &p:m){...}\n~~~\n当然了，auto也是得看实际的使用场景，大多数情况下使用得当能提升我们编程的效率的\n条款6 介绍的是使用auto可能遇到的坑，在这种时候就得采用传统的方式了\n第1个，就是vector<bool>这个和其他vector格格不入的对象，对于一般的vector<T>[],他能返回一个T&类型的东西，但vector<bool>他本身是特化过的，他底层是使用比特去表示这1个1个的bool，而c++又不能返回1个对比特的引用，所以他只能返回一个用来模拟bool&的reference，即std::vector<bool>::reference,他能够像bool进行隐式转换，所以对下面语句\n~~~\nvector<bool> vec{true,true};\nbool is_true = vec[0];\n~~~\n这里取出来的vec[0]实际是个std::vector<bool>::reference，但他可以转换为bool，所以没啥问题\n但假如我们使用auto去声明is_true,得到他类型就是std::vector<bool>::reference了，他就不是指代第1个元素是否为true的变量了\n书里介绍的这种情况带来的问题在于可能出现悬空指针，例如，当我们函数的返回值是个vector<bool>时，他是个临时对象，而他实现获取第1个元素的方式，有一种实现是通过指针+偏移量的方式去获取，而我们如果使用auto is_true = bool_vectroy()[0]时，is_true和临时对象的指针指向同一个东西，而临时对象在这一句话后就解析了，那is_true就指向1个被析构了的地址了，\n","slug":"effective-modern-c-4-6","published":1,"updated":"2022-09-12T12:41:11.369Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yr7m7b0000n4pv9ac5gwfm","content":"<p>条款4是教如何去获取类型推导结果的，第一种就是利用IDE去获取，第2种我们可以声明一个类模板但不去定义他，然后使用decltype(x)让编译器报错，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">class TD;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\"> const int x = 3;</span><br><span class=\"line\"> TD&lt;decltype(x)&gt; xtype;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时编译器报错如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error: aggregate ‘TD&lt;const int&gt; xtype’ has incomplete type and cannot be defined</span><br><span class=\"line\">  TD&lt;decltype(x)&gt; xtype;</span><br></pre></td></tr></table></figure>\n<p>可以看到x的确被推导为const int<br>还有1种就是使用type_info,在大多数情况下他是正确的，但他推导的方式是安值推导的，也就是说，引用和常量性会被忽略，所以他并不可靠，</p>\n<p>接下来是条款5，是开始了第2大章，关于auto的使用<br>条款5具体讲了一些应用auto带来的方便与好处<br>第1个就是在使用iterator的时候，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename It&gt;</span><br><span class=\"line\">void func(It b, It e)&#123;</span><br><span class=\"line\">    while(b!=e)&#123;</span><br><span class=\"line\">        typename std::iterator_traits&lt;It&gt;::value_type</span><br><span class=\"line\">        val = *b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>像上面这一段，我们使用萃取去获取这个迭代器到底指向啥东西，写起来十分的拗口麻烦，我们可以利用auto直接写成auto val = *b；<br>第2个就是使用auto来保证变量一定能初始化，解决变量未初始化的行为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto i; // 不能通过</span><br><span class=\"line\">auto i = 2;</span><br></pre></td></tr></table></figure>\n<p>第3个就是使用lambda表达式时，这个lambda对象到底是个什么类型，这个是由编译器决定的，所以我们需要利用auto用来把lambda表达式赋值给某个变量名，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto lam = []()&#123; return 0; &#125;;</span><br></pre></td></tr></table></figure>\n<p>当然我们也可以用一个std::function去持有这个lambda，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::function&lt;bool(int,int)&gt;</span><br><span class=\"line\">myfunc = [](int x, int y)&#123; return true;&#125;;</span><br></pre></td></tr></table></figure>\n<p>而其缺点在于function本身就是一个对象，他本身就是需要内存的，在内存上来说auto来的更好，<br>第4个就是对于一些硬件依赖的typename，比如unsigned，在32位上和在64位上不同的，单单指定某个变量是unsigned可能会在不同机器上带来出乎意料的结果，因此我们可以利用auto</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto size = v.size();</span><br></pre></td></tr></table></figure>\n<p>第5个还是在迭代的时候，我们对于一些容器他储存方式不熟悉带来的问题，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(const std::pair&lt;std::string, int&gt; &amp;p :m)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>m是个unorder_map,他本身是由std::pair&lt;const std::string, int&gt;组成的，不是上面这种方式，也就是说，程序跑到这段代码，会复制容器里的每一个元素，然后引用再去指向这些临时对象，可想而知多非时间，而使用auto很容易就解决</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for（const auto &amp;p:m)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>当然了，auto也是得看实际的使用场景，大多数情况下使用得当能提升我们编程的效率的<br>条款6 介绍的是使用auto可能遇到的坑，在这种时候就得采用传统的方式了<br>第1个，就是vector<bool>这个和其他vector格格不入的对象，对于一般的vector<T>[],他能返回一个T&amp;类型的东西，但vector<bool>他本身是特化过的，他底层是使用比特去表示这1个1个的bool，而c++又不能返回1个对比特的引用，所以他只能返回一个用来模拟bool&amp;的reference，即std::vector<bool>::reference,他能够像bool进行隐式转换，所以对下面语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;bool&gt; vec&#123;true,true&#125;;</span><br><span class=\"line\">bool is_true = vec[0];</span><br></pre></td></tr></table></figure>\n<p>这里取出来的vec[0]实际是个std::vector<bool>::reference，但他可以转换为bool，所以没啥问题<br>但假如我们使用auto去声明is_true,得到他类型就是std::vector<bool>::reference了，他就不是指代第1个元素是否为true的变量了<br>书里介绍的这种情况带来的问题在于可能出现悬空指针，例如，当我们函数的返回值是个vector<bool>时，他是个临时对象，而他实现获取第1个元素的方式，有一种实现是通过指针+偏移量的方式去获取，而我们如果使用auto is_true = bool_vectroy()[0]时，is_true和临时对象的指针指向同一个东西，而临时对象在这一句话后就解析了，那is_true就指向1个被析构了的地址了，</p>\n","site":{"data":{}},"excerpt":"","more":"<p>条款4是教如何去获取类型推导结果的，第一种就是利用IDE去获取，第2种我们可以声明一个类模板但不去定义他，然后使用decltype(x)让编译器报错，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">class TD;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\"> const int x = 3;</span><br><span class=\"line\"> TD&lt;decltype(x)&gt; xtype;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时编译器报错如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error: aggregate ‘TD&lt;const int&gt; xtype’ has incomplete type and cannot be defined</span><br><span class=\"line\">  TD&lt;decltype(x)&gt; xtype;</span><br></pre></td></tr></table></figure>\n<p>可以看到x的确被推导为const int<br>还有1种就是使用type_info,在大多数情况下他是正确的，但他推导的方式是安值推导的，也就是说，引用和常量性会被忽略，所以他并不可靠，</p>\n<p>接下来是条款5，是开始了第2大章，关于auto的使用<br>条款5具体讲了一些应用auto带来的方便与好处<br>第1个就是在使用iterator的时候，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename It&gt;</span><br><span class=\"line\">void func(It b, It e)&#123;</span><br><span class=\"line\">    while(b!=e)&#123;</span><br><span class=\"line\">        typename std::iterator_traits&lt;It&gt;::value_type</span><br><span class=\"line\">        val = *b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>像上面这一段，我们使用萃取去获取这个迭代器到底指向啥东西，写起来十分的拗口麻烦，我们可以利用auto直接写成auto val = *b；<br>第2个就是使用auto来保证变量一定能初始化，解决变量未初始化的行为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto i; // 不能通过</span><br><span class=\"line\">auto i = 2;</span><br></pre></td></tr></table></figure>\n<p>第3个就是使用lambda表达式时，这个lambda对象到底是个什么类型，这个是由编译器决定的，所以我们需要利用auto用来把lambda表达式赋值给某个变量名，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto lam = []()&#123; return 0; &#125;;</span><br></pre></td></tr></table></figure>\n<p>当然我们也可以用一个std::function去持有这个lambda，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::function&lt;bool(int,int)&gt;</span><br><span class=\"line\">myfunc = [](int x, int y)&#123; return true;&#125;;</span><br></pre></td></tr></table></figure>\n<p>而其缺点在于function本身就是一个对象，他本身就是需要内存的，在内存上来说auto来的更好，<br>第4个就是对于一些硬件依赖的typename，比如unsigned，在32位上和在64位上不同的，单单指定某个变量是unsigned可能会在不同机器上带来出乎意料的结果，因此我们可以利用auto</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto size = v.size();</span><br></pre></td></tr></table></figure>\n<p>第5个还是在迭代的时候，我们对于一些容器他储存方式不熟悉带来的问题，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(const std::pair&lt;std::string, int&gt; &amp;p :m)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>m是个unorder_map,他本身是由std::pair&lt;const std::string, int&gt;组成的，不是上面这种方式，也就是说，程序跑到这段代码，会复制容器里的每一个元素，然后引用再去指向这些临时对象，可想而知多非时间，而使用auto很容易就解决</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for（const auto &amp;p:m)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>当然了，auto也是得看实际的使用场景，大多数情况下使用得当能提升我们编程的效率的<br>条款6 介绍的是使用auto可能遇到的坑，在这种时候就得采用传统的方式了<br>第1个，就是vector<bool>这个和其他vector格格不入的对象，对于一般的vector<T>[],他能返回一个T&amp;类型的东西，但vector<bool>他本身是特化过的，他底层是使用比特去表示这1个1个的bool，而c++又不能返回1个对比特的引用，所以他只能返回一个用来模拟bool&amp;的reference，即std::vector<bool>::reference,他能够像bool进行隐式转换，所以对下面语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;bool&gt; vec&#123;true,true&#125;;</span><br><span class=\"line\">bool is_true = vec[0];</span><br></pre></td></tr></table></figure>\n<p>这里取出来的vec[0]实际是个std::vector<bool>::reference，但他可以转换为bool，所以没啥问题<br>但假如我们使用auto去声明is_true,得到他类型就是std::vector<bool>::reference了，他就不是指代第1个元素是否为true的变量了<br>书里介绍的这种情况带来的问题在于可能出现悬空指针，例如，当我们函数的返回值是个vector<bool>时，他是个临时对象，而他实现获取第1个元素的方式，有一种实现是通过指针+偏移量的方式去获取，而我们如果使用auto is_true = bool_vectroy()[0]时，is_true和临时对象的指针指向同一个东西，而临时对象在这一句话后就解析了，那is_true就指向1个被析构了的地址了，</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cl7kmirrs00009kpv6ab995u7","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7kmmz7t0001oepvgm9whlmy"},{"post_id":"cl7kjsgzp0001ospv3gja6xid","tag_id":"cl7kmw2kt0000y0pvgvyefmel","_id":"cl7kmw2l30001y0pv41zp3lss"},{"post_id":"cl7n1867u00007fpv3ge1ad3e","tag_id":"cl7n1868000017fpv10563ts2","_id":"cl7n1868200027fpv9pjr8dyr"},{"post_id":"cl7n9mgb0000097pv77cmci4p","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7n9mgb8000197pv3sghfu48"},{"post_id":"cl7o7xgmf0000zepv3hir66l1","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7o7xgmm0002zepv678a0vdb"},{"post_id":"cl7o7xgmn0003zepvd4ukabme","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7ogwsye0001d6pvcwha5h2d"},{"post_id":"cl7ogwsy80000d6pvbb47fdys","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7ogwsyf0002d6pvf8jac3ph"},{"post_id":"cl7oxnq8n00001apvcxtcc7f4","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7oxnq8y00011apvh9qe2yiu"},{"post_id":"cl7ro22ol0000wwpvbi2vhuad","tag_id":"cl7ro22ot0001wwpva4po3vyx","_id":"cl7ro22ox0002wwpv0qpxfuyg"},{"post_id":"cl7rsg8tn0000y4pva3yf5yk8","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7rsg8ty0001y4pvaorg3x23"},{"post_id":"cl7rt965c00003qpvcqak7ik5","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7rt965n00013qpvc6w4f8pt"},{"post_id":"cl7ui5zz60000c6pv9my57qhv","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7ui5zzf0002c6pvew7e9tlk"},{"post_id":"cl7ui5zzd0001c6pv9drh4nqm","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7ui5zzh0004c6pvey6b60xt"},{"post_id":"cl7ui5zzg0003c6pv2m0z8zfq","tag_id":"cl7ui5zzi0006c6pv60hs1bnu","_id":"cl7ui5zzp0007c6pvf9l33yl0"},{"post_id":"cl7ui5zzh0005c6pv5qw88b4p","tag_id":"cl7n1868000017fpv10563ts2","_id":"cl7ul6qwb0000unpv0eie42um"},{"post_id":"cl7yi1p530000capvccema4df","tag_id":"cl7yi1p5b0001capv704ufmkq","_id":"cl7yi1p5g0002capv5n5iaq2f"},{"post_id":"cl7yr7m7b0000n4pv9ac5gwfm","tag_id":"cl7yi1p5b0001capv704ufmkq","_id":"cl7yr7m7m0001n4pvflqw2w2h"}],"Tag":[{"name":"c++","_id":"cl7kmmz7n0000oepv1lwy29q1"},{"name":"c+2","_id":"cl7kmw2kt0000y0pvgvyefmel"},{"name":"tvm","_id":"cl7n1868000017fpv10563ts2"},{"name":"小组件","_id":"cl7ro22ot0001wwpva4po3vyx"},{"name":"leveldb","_id":"cl7ui5zzi0006c6pv60hs1bnu"},{"name":"effective_modern_c++","_id":"cl7yi1p5b0001capv704ufmkq"}]}}