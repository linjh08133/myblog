{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/css/blog_basic.styl","path":"css/blog_basic.styl","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/css/font-awesome.css","path":"css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/css/insight.css","path":"css/insight.css","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/css/search.css","path":"css/search.css","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/images/favicon.webp","path":"images/favicon.webp","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/images/gongan.png","path":"images/gongan.png","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/images/logo.webp","path":"images/logo.webp","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/images/logo@2x.webp","path":"images/logo@2x.webp","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/add-bookmark.js","path":"js/add-bookmark.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/baidu-tongji.js","path":"js/baidu-tongji.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/jquery-migrate-1.2.1.min.js","path":"js/jquery-migrate-1.2.1.min.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/jquery.appear.js","path":"js/jquery.appear.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/tagcanvas.js","path":"js/tagcanvas.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/tagcloud.js","path":"js/tagcloud.js","modified":0,"renderable":1},{"_id":"themes/Anatolo/source/js/visitors.js","path":"js/visitors.js","modified":0,"renderable":1},{"_id":"source/images/logo.webp","path":"images/logo.webp","modified":0,"renderable":0},{"_id":"source/images/shared_ptr线程安全/dump.png","path":"images/shared_ptr线程安全/dump.png","modified":0,"renderable":0},{"_id":"source/images/local_static/res.png","path":"images/local_static/res.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"535a84862e557086eb83d343c8209ee589d13a38","modified":1662132688903},{"_id":"source/_posts/test.md","hash":"75bbe72dacaf2126838b459152e630b16fc8bf43","modified":1662132659993},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1662127190474},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1662127190476},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1662127190477},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1662127190480},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1662127190480},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1662127190480},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1662127190481},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1662127190489},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1662127190490},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1662127190489},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1662127190489},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1662127190490},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1662127190490},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1662127190490},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1662127190490},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1662127190490},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1662127190490},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1662127190490},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1662127190490},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1662127190485},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1662127190490},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1662127190490},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1662127190490},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1662127190490},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1662127190490},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1662127190485},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1662127190490},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1662127190494},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1662127190494},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1662127190495},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1662127190494},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1662127190494},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1662127190494},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1662127190495},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1662127190494},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1662127190495},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1662127190495},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1662127190490},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1662127190495},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1662127190495},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1662127190495},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1662127190495},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1662127190496},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1662127190502},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1662127190499},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1662127190499},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1662127190499},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1662127190499},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1662127190500},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1662127190499},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1662127190500},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1662127190502},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1662127190502},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1662127190502},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1662127190497},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1662127190495},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1662127190496},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1662127190496},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1662127190496},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1662127190496},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1662127190496},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1662127190503},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1662127190502},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1662127190503},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1662127190503},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1662127190504},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1662127190503},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1662127190503},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1662127190503},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1662127190503},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1662127190504},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1662127190502},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1662127190504},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1662127190502},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1662127190504},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1662127190504},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1662127190504},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1662127190497},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1662127190504},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1662127190504},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1662127190504},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1662127190504},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1662127190504},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1662127190503},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1662127190504},{"_id":"public/2022/09/02/test/index.html","hash":"134bdd9d78cd6346ad300fd1cb6e50e4b22d3b91","modified":1662277517014},{"_id":"public/2022/09/02/hello-world/index.html","hash":"51c0c3c050a794510d8d6f461af3376f20ac6f62","modified":1662277704933},{"_id":"public/archives/index.html","hash":"b7e8e0f631e24735baad142333c6718e4772f228","modified":1662392643609},{"_id":"public/archives/2022/index.html","hash":"b7e8e0f631e24735baad142333c6718e4772f228","modified":1662392643609},{"_id":"public/archives/2022/09/index.html","hash":"b7e8e0f631e24735baad142333c6718e4772f228","modified":1662392643609},{"_id":"public/index.html","hash":"48c299904dbaa1964aac4d70cb338d44972386f0","modified":1662392643609},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1662127486389},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1662127486389},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1662127486389},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1662127486389},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1662127486389},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1662127486389},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1662127486389},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1662127486389},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1662127486389},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1662127486389},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1662127486389},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1662127486389},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1662127486389},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1662127486389},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1662127486389},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1662127486389},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1662127486389},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1662127486389},{"_id":"public/css/style.css","hash":"c0f346d04e643520b1bd77552bd3d723c5a88366","modified":1662132071838},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1662127486389},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1662127486389},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1662127486389},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1662127486389},{"_id":"source/_posts/test1.md","hash":"49e8ebfc4037ecf0c52039b57d11646cfa8215e2","modified":1662132255829},{"_id":"themes/Anatolo/.gitignore","hash":"34d5fc554d9f7f0eb41773e16bd753112d9b9e95","modified":1662272325086},{"_id":"themes/Anatolo/LICENSE","hash":"c6e73f74e331546c7bc59ed16025b1381145e389","modified":1662131863804},{"_id":"themes/Anatolo/README.md","hash":"101f5ada93bc99e7c349d4c62179baf51ca321b7","modified":1662131863804},{"_id":"themes/Anatolo/_config.yml","hash":"652a37b13396c3d17dc3ab7be041b33f272ecacc","modified":1662277238803},{"_id":"themes/Anatolo/package.json","hash":"da1cba3cf5d7e45eb731fed952ce1d0aaccc16bc","modified":1662131863808},{"_id":"themes/Anatolo/languages/en.yml","hash":"bc4f41d20ca49893a3e5373961c8b3e006867d15","modified":1662131863806},{"_id":"themes/Anatolo/languages/pt-BR.yml","hash":"77d0db5442d38eb3c804ec2cd99d7c7461230477","modified":1662131863806},{"_id":"themes/Anatolo/languages/zh-cn.yml","hash":"6f3c966764b1b57ce64b3cec2c515e0df01eca11","modified":1662131863806},{"_id":"themes/Anatolo/layout/archive.pug","hash":"7c9c18beef56e713191da2f76a5320b1bfda86c5","modified":1662131863806},{"_id":"themes/Anatolo/layout/category.pug","hash":"cf9c50a38f21a5a1f3223a06d3c731d211389d1c","modified":1662131863806},{"_id":"themes/Anatolo/layout/index.pug","hash":"57e3b4f9ff332de85c0726fc6f3e7a7882750eff","modified":1662131863806},{"_id":"themes/Anatolo/layout/mixins.pug","hash":"c17a7d51fb25f2629fb3f8a1af89c1e946a900c1","modified":1662131863806},{"_id":"themes/Anatolo/layout/page.pug","hash":"570190249a84b551dc6ac3d4466c9e9deaff0711","modified":1662131863807},{"_id":"themes/Anatolo/layout/post.pug","hash":"e05c8c9cdbed372eb098cfdcebfd17c79ac7f8ff","modified":1662131863807},{"_id":"themes/Anatolo/layout/tag.pug","hash":"cc0b383e1313199e9e8537c610fc6c6023f22a1e","modified":1662131863807},{"_id":"themes/Anatolo/layout/tags.pug","hash":"41208b4d5ca33e171419769605089a012206ca35","modified":1662131863807},{"_id":"themes/Anatolo/scripts/index.js","hash":"116a35be4c2c89ee400bb5453943de2abb676840","modified":1662131863808},{"_id":"themes/Anatolo/includes/generators/insight.js","hash":"c4b981443927b87cc14a3a583029e13f819d6d71","modified":1662131863804},{"_id":"themes/Anatolo/includes/generators/tags.js","hash":"50d939b63fc00a19064c6fe59b6db0f8e140e39d","modified":1662131863805},{"_id":"themes/Anatolo/includes/tasks/welcome.js","hash":"56073b2019bb20b452a123b9dfcbb3678b40517c","modified":1662131863805},{"_id":"themes/Anatolo/includes/helpers/site.js","hash":"221d84f5eca5b91dfd429705d0651067e6d9063a","modified":1662131863805},{"_id":"themes/Anatolo/layout/partial/comments.pug","hash":"de5da9a655717f85f0bdc21f61e569adb16cf4b3","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/footer.pug","hash":"4e3e47701211869b2097e6472278a024b912346d","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/layout.pug","hash":"1311905a9ea1870caf44a97a5296d72b7c131b13","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/head.pug","hash":"8ec73cb945f60b27e9ce9928be31b13e98e18810","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/nav.pug","hash":"fec7b36ee20d387bafc70328677cd63985afbdda","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/search.pug","hash":"342e0f1d5813d448051257c361fa676f45e3f49c","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/sidebar.pug","hash":"08a304b3a640c48fd4c58125d220d3f8dd1f1b08","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/social_links.pug","hash":"234218895422dd915a6d0115b012353d9b37fc62","modified":1662131863807},{"_id":"themes/Anatolo/layout/partial/toc.pug","hash":"2bbaab792d5346063d94d18ad1dd5e6dd7903711","modified":1662131863807},{"_id":"themes/Anatolo/source/css/blog_basic.styl","hash":"6036d6b6c44fd29a83732e6800aca163aac86008","modified":1662131863808},{"_id":"themes/Anatolo/source/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1662131863809},{"_id":"themes/Anatolo/source/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1662131863809},{"_id":"themes/Anatolo/source/css/insight.css","hash":"b468a47b30b47017b06ff6c431c49a316288a501","modified":1662131863809},{"_id":"themes/Anatolo/source/css/search.css","hash":"c1cb306e075386517ac15bf4ef37c647d37ec6b5","modified":1662131863809},{"_id":"themes/Anatolo/source/css/style.styl","hash":"c4341430ddecc1e26012af7cbf28e3f87d4414fe","modified":1662131863809},{"_id":"themes/Anatolo/source/images/favicon.webp","hash":"b2c2e853f326a171da7dce74aa45a363a750c359","modified":1662131863818},{"_id":"themes/Anatolo/source/images/gongan.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1662131863818},{"_id":"themes/Anatolo/source/images/logo.webp","hash":"c92aea3812e471d84b173e7c6fcd474787bfd4de","modified":1662133222868},{"_id":"themes/Anatolo/source/images/logo@2x.webp","hash":"c92aea3812e471d84b173e7c6fcd474787bfd4de","modified":1662133373872},{"_id":"themes/Anatolo/source/js/add-bookmark.js","hash":"3cd1622f94f184ca7a542fcbcce75cf9130b9208","modified":1662131863818},{"_id":"themes/Anatolo/source/js/baidu-tongji.js","hash":"49d6d863bc54d843efcc1cd5a92b0e3d65c4bdd6","modified":1662131863818},{"_id":"themes/Anatolo/source/js/insight.js","hash":"16f64c50efc78abb3d94c079d3cda0b74e809f5e","modified":1662131863818},{"_id":"themes/Anatolo/source/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1662131863818},{"_id":"themes/Anatolo/source/js/jquery.appear.js","hash":"1f8067d7bd4c0bde30785e8016100f239e14394f","modified":1662131863818},{"_id":"themes/Anatolo/source/js/tagcanvas.js","hash":"db9a61a79350d1618a74a8f3448f06046c3d9a6c","modified":1662131863821},{"_id":"themes/Anatolo/source/js/tagcloud.js","hash":"cd02ffd8e5192cb25f50f6c5c920a3249ff1614f","modified":1662131863821},{"_id":"themes/Anatolo/source/js/visitors.js","hash":"717a2483ae4d7682d944e79c2a1efd959fa112bc","modified":1662131863821},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1662131863817},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1662131863818},{"_id":"themes/Anatolo/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1662131863811},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1662131863812},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1662131863817},{"_id":"themes/Anatolo/source/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1662131863820},{"_id":"themes/Anatolo/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1662131863815},{"_id":"public/content.json","hash":"4cd5884d596a8e7efa138d00593149d3556771b3","modified":1662392643609},{"_id":"public/2022/09/02/test1/index.html","hash":"3b43e7ad2170f193f9606dcc602d452b2074f2dc","modified":1662277517014},{"_id":"public/tags/index.html","hash":"557488ea527a6053c935b2d436732737257efa8e","modified":1662392643609},{"_id":"public/images/favicon.webp","hash":"b2c2e853f326a171da7dce74aa45a363a750c359","modified":1662132071838},{"_id":"public/images/gongan.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1662132071838},{"_id":"public/images/logo@2x.webp","hash":"48e26e26b8e4a07d7e5c0a4b3654675cc870f3aa","modified":1662132071838},{"_id":"public/images/logo.webp","hash":"c92aea3812e471d84b173e7c6fcd474787bfd4de","modified":1662291808010},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1662132071838},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1662132071838},{"_id":"public/css/blog_basic.css","hash":"277c08a8a9305ddbe45a5fae2e44d0726d8f2ee1","modified":1662132071838},{"_id":"public/css/insight.css","hash":"b468a47b30b47017b06ff6c431c49a316288a501","modified":1662132071838},{"_id":"public/css/search.css","hash":"c1cb306e075386517ac15bf4ef37c647d37ec6b5","modified":1662132071838},{"_id":"public/js/add-bookmark.js","hash":"3cd1622f94f184ca7a542fcbcce75cf9130b9208","modified":1662132071838},{"_id":"public/js/baidu-tongji.js","hash":"49d6d863bc54d843efcc1cd5a92b0e3d65c4bdd6","modified":1662132071838},{"_id":"public/js/insight.js","hash":"16f64c50efc78abb3d94c079d3cda0b74e809f5e","modified":1662132071838},{"_id":"public/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1662132071838},{"_id":"public/js/jquery.appear.js","hash":"1f8067d7bd4c0bde30785e8016100f239e14394f","modified":1662132071838},{"_id":"public/js/tagcloud.js","hash":"cd02ffd8e5192cb25f50f6c5c920a3249ff1614f","modified":1662132071838},{"_id":"public/js/visitors.js","hash":"717a2483ae4d7682d944e79c2a1efd959fa112bc","modified":1662132071838},{"_id":"public/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1662132071838},{"_id":"public/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1662132071838},{"_id":"public/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1662132071838},{"_id":"public/js/tagcanvas.js","hash":"db9a61a79350d1618a74a8f3448f06046c3d9a6c","modified":1662132071838},{"_id":"public/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1662132071838},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1662132071838},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1662132071838},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1662132071838},{"_id":"public/tags/c/index.html","hash":"066122d7e84b2d5ca5c9b74dcaf0ad4f3dc0146b","modified":1662392643609},{"_id":"public/tags/c-2/index.html","hash":"763172b933c364a1d0980dce0e707d1fbd56126b","modified":1662277517014},{"_id":"source/_posts/tvm.md","hash":"1d929f45fc1ec174a10a2c6acbba6339549b70ea","modified":1662290388170},{"_id":"public/2022/09/04/tvm/index.html","hash":"83885ea38ad4d1dd172d40cebb86bbed459dd56d","modified":1662291808010},{"_id":"public/tags/tvm/index.html","hash":"9c7e82a2133611caf7641bffeea1f9b00f0c333e","modified":1662277704933},{"_id":"source/_posts/类型萃取.md","hash":"06fafa4d94b155bfd6fcc263782574d8eb4c3957","modified":1662292917600},{"_id":"source/images/logo.webp","hash":"c92aea3812e471d84b173e7c6fcd474787bfd4de","modified":1662133222868},{"_id":"public/2022/09/04/类型萃取/index.html","hash":"959eb58abc687333a05407252659f852118b541e","modified":1662349428652},{"_id":"source/_posts/内存模型1.md","hash":"423b3e9290059b8667b4f7fd9805270e7862f58b","modified":1662349418410},{"_id":"source/_posts/模板偏特化-1.md","hash":"df4ae66de7bc4e85bf82e1f81b4867c483908a4d","modified":1662299605067},{"_id":"source/_posts/模板偏特化.md","hash":"8249f2d877515c01d7d8bac813a7b0cf278543f3","modified":1662349725326},{"_id":"public/2022/09/04/模板偏特化-1/index.html","hash":"31089b3590ed81ee373ede35a38af2b731c2304e","modified":1662349428652},{"_id":"public/2022/09/04/模板偏特化/index.html","hash":"c88c7bf82c960de01088dec656fce95a288eeb11","modified":1662364511575},{"_id":"public/2022/09/05/内存模型1/index.html","hash":"21d98b51940c0d746c116deab3fb519647c37890","modified":1662364511575},{"_id":"source/_posts/shared-ptr线程安全.md","hash":"713f863f46a8b2e9c18ece1c7a94853c2e258cda","modified":1662364500570},{"_id":"source/images/shared_ptr线程安全/dump.png","hash":"4f98cf577e94bc4b998f88448359b2656209d302","modified":1662364425355},{"_id":"public/2022/09/05/shared-ptr线程安全/index.html","hash":"05f4f61c05f94c5901d647b6de8982584bec228c","modified":1662392643609},{"_id":"public/images/shared_ptr线程安全/dump.png","hash":"4f98cf577e94bc4b998f88448359b2656209d302","modified":1662364511575},{"_id":"source/_posts/局部静态对象.md","hash":"2b8877a97054bb69e6d7f28075c4d1905f59108f","modified":1662392638446},{"_id":"source/images/local_static/res.png","hash":"004cdcf7d8ae6d662e88c1d30168d9507543e7a8","modified":1662392477423},{"_id":"public/2022/09/05/局部静态对象/index.html","hash":"80cc2efd48cf0c6d52412fc22482297b2e0c2bdb","modified":1662392643609},{"_id":"public/images/local_static/res.png","hash":"004cdcf7d8ae6d662e88c1d30168d9507543e7a8","modified":1662392643609}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"test","date":"2022-09-02T14:04:38.000Z","_content":"","source":"_posts/test.md","raw":"---\ntitle: test\ndate: 2022-09-02 22:04:38\ntags:\n---\n","slug":"test","published":1,"updated":"2022-09-02T14:04:38.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7kjsgzf0000ospv7y772hj6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntags: c+2\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-09-02T15:31:28.907Z","updated":"2022-09-02T15:31:28.903Z","_id":"cl7kjsgzp0001ospv3gja6xid","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"test1","date":"2022-09-02T15:20:43.000Z","_content":"","source":"_posts/test1.md","raw":"---\ntitle: test1\ndate: 2022-09-02 23:20:43\ntags: c++\n---\n","slug":"test1","published":1,"updated":"2022-09-02T15:24:15.829Z","_id":"cl7kmirrs00009kpv6ab995u7","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tvm","date":"2022-09-04T07:38:01.000Z","_content":"\n\nthis is a placeholder for tvm\n下面测试以下图片捏\n![](/images/logo.webp)\n","source":"_posts/tvm.md","raw":"---\ntitle: tvm\ndate: 2022-09-04 15:38:01\ntags: tvm\n---\n\n\nthis is a placeholder for tvm\n下面测试以下图片捏\n![](/images/logo.webp)\n","slug":"tvm","published":1,"updated":"2022-09-04T11:19:48.170Z","_id":"cl7n1867u00007fpv3ge1ad3e","comments":1,"layout":"post","photos":[],"link":"","content":"<p>this is a placeholder for tvm<br>下面测试以下图片捏<br><img src=\"/images/logo.webp\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>this is a placeholder for tvm<br>下面测试以下图片捏<br><img src=\"/images/logo.webp\"></p>\n"},{"layout":"init","title":"类型萃取","date":"2022-09-04T11:26:49.000Z","_content":"\n所谓的类型萃取，就算说在某些函数模板中，它需要知道传进来的变量，它的类型到底是啥，用于返回值这类的，但c++是不允许说推导出返回值类型的，例如以下代码是不可能通过编译的\n`\ntemplate<typename T>\n(*T) func(T t){\n ...\n}\n`\n为了解决这种问题，对于我们自定义的类，可以利用typedef去声明，如下\n~~~\ntemplate<typename T>\nstruct MyIter{\n    typedef T value_type;\n    T * ptr;\n    MyIter(T* p):ptr(p){}\n    T& operator*() { return *ptr; }\n};\ntemplate<typename T>\ntypename T::value_type func(T t){\n    std::cout << *t << std::endl;\n}\n~~~\n这样做当传入类型是MyIter\\<int\\>的时候，首先MyIter的T会实例化为int,func这个函数模板的T会被实例化为MyIter，那么其返回类型也就是int了，这里的typename是告诉编译器，后面的T::value_type 是一个类型（像int，double这种),不加就可能会被当作是成员变量造成歧义。\n那当我们传入的是原生指针呢，上面的自定义对象我们可以直接获取它的成员变量的所指对象，但int * 这种就无法通过T::value_type,因为它根本就没有，所以这个时候就可以利用模板偏特化+trait的技巧了，如下\n~~~\ntemplate\\<typename T\\>\nstruct MyIter{\n    typedef T value_type;\n    T * ptr;\n    MyIter(T* p):ptr(p){}\n    T& operator*() { return *ptr; }\n};\n\ntemplate\\<typename T\\>\nstruct iterator_traits{\n    typedef T::value_type value_type;\n};\n\ntemplate\\<typename T\\>\nstruct iterator_traits\\<T*\\>{\n    typedef  T value_type;\n};\n\ntemplate<typename T>\ntypename iterator_traits<T>::value_type func(T t){\n    std::cout << *t << std::endl;\n~~~\n\n那么当func传进来的是int *的时候，会调用特例化的第2个模板，那么value_type就是int啦，这样做iterator所指类型不管是什么情况都能知道了，\n","source":"_posts/类型萃取.md","raw":"---\nlayout: init\ntitle: 类型萃取\ndate: 2022-09-04 19:26:49\ntags: c++\n---\n\n所谓的类型萃取，就算说在某些函数模板中，它需要知道传进来的变量，它的类型到底是啥，用于返回值这类的，但c++是不允许说推导出返回值类型的，例如以下代码是不可能通过编译的\n`\ntemplate<typename T>\n(*T) func(T t){\n ...\n}\n`\n为了解决这种问题，对于我们自定义的类，可以利用typedef去声明，如下\n~~~\ntemplate<typename T>\nstruct MyIter{\n    typedef T value_type;\n    T * ptr;\n    MyIter(T* p):ptr(p){}\n    T& operator*() { return *ptr; }\n};\ntemplate<typename T>\ntypename T::value_type func(T t){\n    std::cout << *t << std::endl;\n}\n~~~\n这样做当传入类型是MyIter\\<int\\>的时候，首先MyIter的T会实例化为int,func这个函数模板的T会被实例化为MyIter，那么其返回类型也就是int了，这里的typename是告诉编译器，后面的T::value_type 是一个类型（像int，double这种),不加就可能会被当作是成员变量造成歧义。\n那当我们传入的是原生指针呢，上面的自定义对象我们可以直接获取它的成员变量的所指对象，但int * 这种就无法通过T::value_type,因为它根本就没有，所以这个时候就可以利用模板偏特化+trait的技巧了，如下\n~~~\ntemplate\\<typename T\\>\nstruct MyIter{\n    typedef T value_type;\n    T * ptr;\n    MyIter(T* p):ptr(p){}\n    T& operator*() { return *ptr; }\n};\n\ntemplate\\<typename T\\>\nstruct iterator_traits{\n    typedef T::value_type value_type;\n};\n\ntemplate\\<typename T\\>\nstruct iterator_traits\\<T*\\>{\n    typedef  T value_type;\n};\n\ntemplate<typename T>\ntypename iterator_traits<T>::value_type func(T t){\n    std::cout << *t << std::endl;\n~~~\n\n那么当func传进来的是int *的时候，会调用特例化的第2个模板，那么value_type就是int啦，这样做iterator所指类型不管是什么情况都能知道了，\n","slug":"类型萃取","published":1,"updated":"2022-09-04T12:01:57.600Z","_id":"cl7n9mgb0000097pv77cmci4p","comments":1,"photos":[],"link":"","content":"<p>所谓的类型萃取，就算说在某些函数模板中，它需要知道传进来的变量，它的类型到底是啥，用于返回值这类的，但c++是不允许说推导出返回值类型的，例如以下代码是不可能通过编译的<br><code>template&lt;typename T&gt; (*T) func(T t)&#123;  ... &#125;</code><br>为了解决这种问题，对于我们自定义的类，可以利用typedef去声明，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">struct MyIter&#123;</span><br><span class=\"line\">    typedef T value_type;</span><br><span class=\"line\">    T * ptr;</span><br><span class=\"line\">    MyIter(T* p):ptr(p)&#123;&#125;</span><br><span class=\"line\">    T&amp; operator*() &#123; return *ptr; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">typename T::value_type func(T t)&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; *t &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做当传入类型是MyIter&lt;int&gt;的时候，首先MyIter的T会实例化为int,func这个函数模板的T会被实例化为MyIter，那么其返回类型也就是int了，这里的typename是告诉编译器，后面的T::value_type 是一个类型（像int，double这种),不加就可能会被当作是成员变量造成歧义。<br>那当我们传入的是原生指针呢，上面的自定义对象我们可以直接获取它的成员变量的所指对象，但int * 这种就无法通过T::value_type,因为它根本就没有，所以这个时候就可以利用模板偏特化+trait的技巧了，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template\\&lt;typename T\\&gt;</span><br><span class=\"line\">struct MyIter&#123;</span><br><span class=\"line\">    typedef T value_type;</span><br><span class=\"line\">    T * ptr;</span><br><span class=\"line\">    MyIter(T* p):ptr(p)&#123;&#125;</span><br><span class=\"line\">    T&amp; operator*() &#123; return *ptr; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template\\&lt;typename T\\&gt;</span><br><span class=\"line\">struct iterator_traits&#123;</span><br><span class=\"line\">    typedef T::value_type value_type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template\\&lt;typename T\\&gt;</span><br><span class=\"line\">struct iterator_traits\\&lt;T*\\&gt;&#123;</span><br><span class=\"line\">    typedef  T value_type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">typename iterator_traits&lt;T&gt;::value_type func(T t)&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; *t &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>\n\n<p>那么当func传进来的是int *的时候，会调用特例化的第2个模板，那么value_type就是int啦，这样做iterator所指类型不管是什么情况都能知道了，</p>\n","site":{"data":{}},"excerpt":"","more":"<p>所谓的类型萃取，就算说在某些函数模板中，它需要知道传进来的变量，它的类型到底是啥，用于返回值这类的，但c++是不允许说推导出返回值类型的，例如以下代码是不可能通过编译的<br><code>template&lt;typename T&gt; (*T) func(T t)&#123;  ... &#125;</code><br>为了解决这种问题，对于我们自定义的类，可以利用typedef去声明，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">struct MyIter&#123;</span><br><span class=\"line\">    typedef T value_type;</span><br><span class=\"line\">    T * ptr;</span><br><span class=\"line\">    MyIter(T* p):ptr(p)&#123;&#125;</span><br><span class=\"line\">    T&amp; operator*() &#123; return *ptr; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">typename T::value_type func(T t)&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; *t &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做当传入类型是MyIter&lt;int&gt;的时候，首先MyIter的T会实例化为int,func这个函数模板的T会被实例化为MyIter，那么其返回类型也就是int了，这里的typename是告诉编译器，后面的T::value_type 是一个类型（像int，double这种),不加就可能会被当作是成员变量造成歧义。<br>那当我们传入的是原生指针呢，上面的自定义对象我们可以直接获取它的成员变量的所指对象，但int * 这种就无法通过T::value_type,因为它根本就没有，所以这个时候就可以利用模板偏特化+trait的技巧了，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template\\&lt;typename T\\&gt;</span><br><span class=\"line\">struct MyIter&#123;</span><br><span class=\"line\">    typedef T value_type;</span><br><span class=\"line\">    T * ptr;</span><br><span class=\"line\">    MyIter(T* p):ptr(p)&#123;&#125;</span><br><span class=\"line\">    T&amp; operator*() &#123; return *ptr; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template\\&lt;typename T\\&gt;</span><br><span class=\"line\">struct iterator_traits&#123;</span><br><span class=\"line\">    typedef T::value_type value_type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template\\&lt;typename T\\&gt;</span><br><span class=\"line\">struct iterator_traits\\&lt;T*\\&gt;&#123;</span><br><span class=\"line\">    typedef  T value_type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">typename iterator_traits&lt;T&gt;::value_type func(T t)&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; *t &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>\n\n<p>那么当func传进来的是int *的时候，会调用特例化的第2个模板，那么value_type就是int啦，这样做iterator所指类型不管是什么情况都能知道了，</p>\n"},{"layout":"init","title":"内存模型1.md","date":"2022-09-05T02:34:30.000Z","_content":"\nc++的内存模型挺复杂的，因为现代cpu架构的原因，例如cache等，一些操作我们无法得知他具体什么时候会对其他线程可见，例如说thread A写了一个全局变量，但它很有可能是写到自己的私有cache导致说它的这个写对其他thread不可见，那么c++对于这些就提出了一个叫内存模型的玩意。\n首先是顺序一致性模型，它规定有2点：\n1.内存访问执行的顺序与程序指定的顺序相同\n2.所有核心的内存访问实际执行顺序都和程序指定顺序相同\n有1个例子就可以说明这个，一个群聊里，每个人的发言记录的顺序是固定的，不可能说先看到晚发出去的信息，而他所看到的所有人的发言记录，与其他的每个人都一样，都是遵循着某种交叉着的顺序，而且大家观察到的顺序都是一样的，\n而c++默认就是使用这种内存模型，即memory_order_seq_cst,以下面这段代码为例\n~~~\n#include <atomic>\n#include <thread>\n#include <assert.h>\n#include <iostream>\nstd::atomic<bool> x,y;\nstd::atomic<int> z;\nvoid write_x()\n{\n x.store(true,std::memory_order_seq_cst); // 1\n}\nvoid write_y()\n{\n y.store(true,std::memory_order_seq_cst); // 2\n}\nvoid read_x_then_y()\n{\n while(!x.load(std::memory_order_seq_cst));\n if(y.load(std::memory_order_seq_cst)) // 3\n ++z;\n //std::cout << z << std::endl;\n}\nvoid read_y_then_x()\n{\n while(!y.load(std::memory_order_seq_cst));\n if(x.load(std::memory_order_seq_cst)) // 4\n ++z;\n //std::cout << z << std::endl;\n\n}\nint main()\n{\n x=false;\n y=false;\n z=0;\n std::thread a(write_x);\n std::thread b(write_y);\n std::thread c(read_x_then_y);\n std::thread d(read_y_then_x);\n a.join();\n b.join();\n c.join();\n d.join();\n assert(z.load()!=0); // 5\n std::cout << z << std::endl;\n}\n~~~\n\n这里assert永远不会报错，且下一步输出的z有可能是1，有可能是2，下面分别分析：\n如果第1个load是true，但第2个load是false，也就算说它观察到了x的store是先于y的store，或者说在它跳出while的时候，肯定是看到了x的store操作，但y的load还是false，说明它没观察到y的store操作，所以它观察到的所x的store先于y的store，那么对thread d而言，它也必须以这种顺序观察到2个store，所以说thread d的第1个load如果是true了，说明它观察到了y的store，所以它必然已经观察到了x的store，所以它下一步的load必然为true，反过来也同理，这个时候的z就是1了\n而z=2的情况为还不是很明白，假如说a的第一个load到了某个时间点，观察到了x的store，它退出了while，然后它第2个load，观察到了y是true，但这就没办法确定x和y的store的观察顺序了，如果x的store先于y，那么对d而言，它的2个load必然为ture，z=2，如果y的store是先于x的，那么thread d就可能第2个load是false了，此时z=1（这里好像就是第1种情况了？，这里的解释不一定正确）\n\n\n\n\n接下来是acq-rel模型，它解除了对全局一致性的约束，只单纯地利用memory_order_acquire和memory_order_release,前者如果某个load使用则在load之前的指令都不能跨过该语句被重排到后面，后者则是某个store使用则其后语句不能被重排跨到前面\n我们经常利用他们去实现同步操作，但是这里要注意，它无法保证全局一致，也就是说，每个thread观测到的顺序是可能不一样的，如下例子：\n~~~\n#include <atomic>\n#include <thread>\n#include <assert.h>\nstd::atomic<bool> x,y;\nstd::atomic<int> z;\nvoid write_x()\n{\n x.store(true,std::memory_order_release);\n}\nvoid write_y()\n{\n y.store(true,std::memory_order_release);\n}\nvoid read_x_then_y()\n{\n while(!x.load(std::memory_order_acquire));\n if(y.load(std::memory_order_acquire)) // 1\n ++z;\n}\nvoid read_y_then_x()\n{\n while(!y.load(std::memory_order_acquire));\n if(x.load(std::memory_order_acquire)) // 2\n ++z;\n}\nint main()\n{\n x=false;\n y=false;\n z=0;\n std::thread a(write_x);\n std::thread b(write_y);\n std::thread c(read_x_then_y);\n std::thread d(read_y_then_x);\n a.join();\n b.join();\n c.join();\n d.join();\n assert(z.load()!=0); // 3\n}\n~~~\n对于不同thread的对同1个原子变量，acq-rel的语义只能做到——如果在load的时候观察到了store，那么必然就能保证我们需要的同步，如果在load的时候还没观察到store的话就做不到了，如下代码\n~~~\n#include <thread>\n#include <atomic>\n#include <cassert>\n#include <string>\n#include <iostream>\n#include <chrono>\nstd::atomic<std::string*> ptr ;\nint data;\n \nvoid producer()\n{\n    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n    std::string* p  = new std::string(\"Hello\");\n    data = 42;\n    ptr.store(p, std::memory_order_release);\n}\n \nvoid consumer()\n{\n    std::string* p2 = nullptr;\n    //std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n    p2 = ptr.load(std::memory_order_acquire);\n    assert(*p2 == \"Hello\"); // never fires\n    assert(data == 42);\n}\n \nint main()\n{\n    std::thread t1(producer);\n    std::thread t2(consumer);\n    t1.join(); t2.join();\n}\n~~~\n这段代码大多数时候是报错的，因为thread 1 sleep了一段时间，所以在第2个thread中，在它load的时候，第1个thread的store因为sleep的原因未执行，导致了它无法做到同步，所以下面的assert必然报错，但如果修改p2，改成while(!p2=ptr.load(std::memory_order_acquire)),就能实现同步了，因为它会一直在while中循环，直到某1次循环中，它观察到了线程1的store操作，那么这2者的同步语义就能建立起来了——线程1的store之前的语句必然先于store，线程2的load之后的语句必然非先于load，而它跳出循环的时候store必然是已经被观测到了，所以这种同步就建立起来了\n回头看上一段代码，这段代码可能报错的原因就在于，acq-rel语义没有规定全局一致，那么就可能出现thread c观测到x的store先于y的store，而d则反过来，此时他们就都加不了z，或者说我们可以这么理解——全局一致下，c看到了x是true，y只load1次看到是false，说明x的store对d来说也必然先于y的store，而d一直卡在while那里，直到它观测到y是true；但没有全局一致的要求时，以下情况就可能发生——对thread c，它卡在while一段时间退去后，此时它肯定观测到了x的sotre，而它只对y进行了1次load，是false，说明它观测到x的store先于y，但对d而言，没有全局一致的约束，c的观测顺序对它没意义了，它完全可以一直卡在while，直到它观测到y的store，然后在对x进行1次load，发现x的store还没被观察到，对d而言，它是先观测到y后才是x，那么这种矛盾的原因在于，x和y的store它可能是写入内存，而c和d在load的时候，不一定去内存找，它可能直接在自己的cache中找，不一致就来了\n那么怎么修改这段代码呢，很简单，只要保证x和y他们的被观测到的顺序是一样的就可以了，上述由于是分开被2个线程写的原因\n如下\n~~~\n#include <atomic>\n#include <thread>\n#include <assert.h>\nstd::atomic<bool> x,y;\nstd::atomic<int> z;\nvoid write_x_then_y()\n{\n x.store(true,std::memory_order_relaxed); // 1 \n y.store(true,std::memory_order_release); // 2\n}\nvoid read_y_then_x()\n{\n while(!y.load(std::memory_order_acquire)); // 3 自旋，等待y被设置为true\n if(x.load(std::memory_order_relaxed)) // 4\n ++z;\n}\nint main()\n{\n x=false;\n y=false;\n z=0;\n std::thread a(write_x_then_y);\n std::thread b(read_y_then_x);\n a.join();\n b.join();\n assert(z.load()!=0); // 5\n}\n~~~\n这里就不用解释了，但如果说y的load不是while，而是只读1次，那这种同步性就没有了，因为它完全有可能在load之前没有观察到store，加上while，不断的load，直到某1次，发现y被store为true了，这次的load就和store有了先后顺序了，那么就可以保证同步了\n","source":"_posts/内存模型1.md","raw":"---\nlayout: init\ntitle: 内存模型1.md\ndate: 2022-09-05 10:34:30\ntags: c++\n---\n\nc++的内存模型挺复杂的，因为现代cpu架构的原因，例如cache等，一些操作我们无法得知他具体什么时候会对其他线程可见，例如说thread A写了一个全局变量，但它很有可能是写到自己的私有cache导致说它的这个写对其他thread不可见，那么c++对于这些就提出了一个叫内存模型的玩意。\n首先是顺序一致性模型，它规定有2点：\n1.内存访问执行的顺序与程序指定的顺序相同\n2.所有核心的内存访问实际执行顺序都和程序指定顺序相同\n有1个例子就可以说明这个，一个群聊里，每个人的发言记录的顺序是固定的，不可能说先看到晚发出去的信息，而他所看到的所有人的发言记录，与其他的每个人都一样，都是遵循着某种交叉着的顺序，而且大家观察到的顺序都是一样的，\n而c++默认就是使用这种内存模型，即memory_order_seq_cst,以下面这段代码为例\n~~~\n#include <atomic>\n#include <thread>\n#include <assert.h>\n#include <iostream>\nstd::atomic<bool> x,y;\nstd::atomic<int> z;\nvoid write_x()\n{\n x.store(true,std::memory_order_seq_cst); // 1\n}\nvoid write_y()\n{\n y.store(true,std::memory_order_seq_cst); // 2\n}\nvoid read_x_then_y()\n{\n while(!x.load(std::memory_order_seq_cst));\n if(y.load(std::memory_order_seq_cst)) // 3\n ++z;\n //std::cout << z << std::endl;\n}\nvoid read_y_then_x()\n{\n while(!y.load(std::memory_order_seq_cst));\n if(x.load(std::memory_order_seq_cst)) // 4\n ++z;\n //std::cout << z << std::endl;\n\n}\nint main()\n{\n x=false;\n y=false;\n z=0;\n std::thread a(write_x);\n std::thread b(write_y);\n std::thread c(read_x_then_y);\n std::thread d(read_y_then_x);\n a.join();\n b.join();\n c.join();\n d.join();\n assert(z.load()!=0); // 5\n std::cout << z << std::endl;\n}\n~~~\n\n这里assert永远不会报错，且下一步输出的z有可能是1，有可能是2，下面分别分析：\n如果第1个load是true，但第2个load是false，也就算说它观察到了x的store是先于y的store，或者说在它跳出while的时候，肯定是看到了x的store操作，但y的load还是false，说明它没观察到y的store操作，所以它观察到的所x的store先于y的store，那么对thread d而言，它也必须以这种顺序观察到2个store，所以说thread d的第1个load如果是true了，说明它观察到了y的store，所以它必然已经观察到了x的store，所以它下一步的load必然为true，反过来也同理，这个时候的z就是1了\n而z=2的情况为还不是很明白，假如说a的第一个load到了某个时间点，观察到了x的store，它退出了while，然后它第2个load，观察到了y是true，但这就没办法确定x和y的store的观察顺序了，如果x的store先于y，那么对d而言，它的2个load必然为ture，z=2，如果y的store是先于x的，那么thread d就可能第2个load是false了，此时z=1（这里好像就是第1种情况了？，这里的解释不一定正确）\n\n\n\n\n接下来是acq-rel模型，它解除了对全局一致性的约束，只单纯地利用memory_order_acquire和memory_order_release,前者如果某个load使用则在load之前的指令都不能跨过该语句被重排到后面，后者则是某个store使用则其后语句不能被重排跨到前面\n我们经常利用他们去实现同步操作，但是这里要注意，它无法保证全局一致，也就是说，每个thread观测到的顺序是可能不一样的，如下例子：\n~~~\n#include <atomic>\n#include <thread>\n#include <assert.h>\nstd::atomic<bool> x,y;\nstd::atomic<int> z;\nvoid write_x()\n{\n x.store(true,std::memory_order_release);\n}\nvoid write_y()\n{\n y.store(true,std::memory_order_release);\n}\nvoid read_x_then_y()\n{\n while(!x.load(std::memory_order_acquire));\n if(y.load(std::memory_order_acquire)) // 1\n ++z;\n}\nvoid read_y_then_x()\n{\n while(!y.load(std::memory_order_acquire));\n if(x.load(std::memory_order_acquire)) // 2\n ++z;\n}\nint main()\n{\n x=false;\n y=false;\n z=0;\n std::thread a(write_x);\n std::thread b(write_y);\n std::thread c(read_x_then_y);\n std::thread d(read_y_then_x);\n a.join();\n b.join();\n c.join();\n d.join();\n assert(z.load()!=0); // 3\n}\n~~~\n对于不同thread的对同1个原子变量，acq-rel的语义只能做到——如果在load的时候观察到了store，那么必然就能保证我们需要的同步，如果在load的时候还没观察到store的话就做不到了，如下代码\n~~~\n#include <thread>\n#include <atomic>\n#include <cassert>\n#include <string>\n#include <iostream>\n#include <chrono>\nstd::atomic<std::string*> ptr ;\nint data;\n \nvoid producer()\n{\n    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n    std::string* p  = new std::string(\"Hello\");\n    data = 42;\n    ptr.store(p, std::memory_order_release);\n}\n \nvoid consumer()\n{\n    std::string* p2 = nullptr;\n    //std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n    p2 = ptr.load(std::memory_order_acquire);\n    assert(*p2 == \"Hello\"); // never fires\n    assert(data == 42);\n}\n \nint main()\n{\n    std::thread t1(producer);\n    std::thread t2(consumer);\n    t1.join(); t2.join();\n}\n~~~\n这段代码大多数时候是报错的，因为thread 1 sleep了一段时间，所以在第2个thread中，在它load的时候，第1个thread的store因为sleep的原因未执行，导致了它无法做到同步，所以下面的assert必然报错，但如果修改p2，改成while(!p2=ptr.load(std::memory_order_acquire)),就能实现同步了，因为它会一直在while中循环，直到某1次循环中，它观察到了线程1的store操作，那么这2者的同步语义就能建立起来了——线程1的store之前的语句必然先于store，线程2的load之后的语句必然非先于load，而它跳出循环的时候store必然是已经被观测到了，所以这种同步就建立起来了\n回头看上一段代码，这段代码可能报错的原因就在于，acq-rel语义没有规定全局一致，那么就可能出现thread c观测到x的store先于y的store，而d则反过来，此时他们就都加不了z，或者说我们可以这么理解——全局一致下，c看到了x是true，y只load1次看到是false，说明x的store对d来说也必然先于y的store，而d一直卡在while那里，直到它观测到y是true；但没有全局一致的要求时，以下情况就可能发生——对thread c，它卡在while一段时间退去后，此时它肯定观测到了x的sotre，而它只对y进行了1次load，是false，说明它观测到x的store先于y，但对d而言，没有全局一致的约束，c的观测顺序对它没意义了，它完全可以一直卡在while，直到它观测到y的store，然后在对x进行1次load，发现x的store还没被观察到，对d而言，它是先观测到y后才是x，那么这种矛盾的原因在于，x和y的store它可能是写入内存，而c和d在load的时候，不一定去内存找，它可能直接在自己的cache中找，不一致就来了\n那么怎么修改这段代码呢，很简单，只要保证x和y他们的被观测到的顺序是一样的就可以了，上述由于是分开被2个线程写的原因\n如下\n~~~\n#include <atomic>\n#include <thread>\n#include <assert.h>\nstd::atomic<bool> x,y;\nstd::atomic<int> z;\nvoid write_x_then_y()\n{\n x.store(true,std::memory_order_relaxed); // 1 \n y.store(true,std::memory_order_release); // 2\n}\nvoid read_y_then_x()\n{\n while(!y.load(std::memory_order_acquire)); // 3 自旋，等待y被设置为true\n if(x.load(std::memory_order_relaxed)) // 4\n ++z;\n}\nint main()\n{\n x=false;\n y=false;\n z=0;\n std::thread a(write_x_then_y);\n std::thread b(read_y_then_x);\n a.join();\n b.join();\n assert(z.load()!=0); // 5\n}\n~~~\n这里就不用解释了，但如果说y的load不是while，而是只读1次，那这种同步性就没有了，因为它完全有可能在load之前没有观察到store，加上while，不断的load，直到某1次，发现y被store为true了，这次的load就和store有了先后顺序了，那么就可以保证同步了\n","slug":"内存模型1","published":1,"updated":"2022-09-05T03:43:38.410Z","comments":1,"photos":[],"link":"","_id":"cl7o7xgmf0000zepv3hir66l1","content":"<p>c++的内存模型挺复杂的，因为现代cpu架构的原因，例如cache等，一些操作我们无法得知他具体什么时候会对其他线程可见，例如说thread A写了一个全局变量，但它很有可能是写到自己的私有cache导致说它的这个写对其他thread不可见，那么c++对于这些就提出了一个叫内存模型的玩意。<br>首先是顺序一致性模型，它规定有2点：<br>1.内存访问执行的顺序与程序指定的顺序相同<br>2.所有核心的内存访问实际执行顺序都和程序指定顺序相同<br>有1个例子就可以说明这个，一个群聊里，每个人的发言记录的顺序是固定的，不可能说先看到晚发出去的信息，而他所看到的所有人的发言记录，与其他的每个人都一样，都是遵循着某种交叉着的顺序，而且大家观察到的顺序都是一样的，<br>而c++默认就是使用这种内存模型，即memory_order_seq_cst,以下面这段代码为例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;assert.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">std::atomic&lt;bool&gt; x,y;</span><br><span class=\"line\">std::atomic&lt;int&gt; z;</span><br><span class=\"line\">void write_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x.store(true,std::memory_order_seq_cst); // 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void write_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> y.store(true,std::memory_order_seq_cst); // 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_x_then_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!x.load(std::memory_order_seq_cst));</span><br><span class=\"line\"> if(y.load(std::memory_order_seq_cst)) // 3</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\"> //std::cout &lt;&lt; z &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_y_then_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!y.load(std::memory_order_seq_cst));</span><br><span class=\"line\"> if(x.load(std::memory_order_seq_cst)) // 4</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\"> //std::cout &lt;&lt; z &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x=false;</span><br><span class=\"line\"> y=false;</span><br><span class=\"line\"> z=0;</span><br><span class=\"line\"> std::thread a(write_x);</span><br><span class=\"line\"> std::thread b(write_y);</span><br><span class=\"line\"> std::thread c(read_x_then_y);</span><br><span class=\"line\"> std::thread d(read_y_then_x);</span><br><span class=\"line\"> a.join();</span><br><span class=\"line\"> b.join();</span><br><span class=\"line\"> c.join();</span><br><span class=\"line\"> d.join();</span><br><span class=\"line\"> assert(z.load()!=0); // 5</span><br><span class=\"line\"> std::cout &lt;&lt; z &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里assert永远不会报错，且下一步输出的z有可能是1，有可能是2，下面分别分析：<br>如果第1个load是true，但第2个load是false，也就算说它观察到了x的store是先于y的store，或者说在它跳出while的时候，肯定是看到了x的store操作，但y的load还是false，说明它没观察到y的store操作，所以它观察到的所x的store先于y的store，那么对thread d而言，它也必须以这种顺序观察到2个store，所以说thread d的第1个load如果是true了，说明它观察到了y的store，所以它必然已经观察到了x的store，所以它下一步的load必然为true，反过来也同理，这个时候的z就是1了<br>而z=2的情况为还不是很明白，假如说a的第一个load到了某个时间点，观察到了x的store，它退出了while，然后它第2个load，观察到了y是true，但这就没办法确定x和y的store的观察顺序了，如果x的store先于y，那么对d而言，它的2个load必然为ture，z=2，如果y的store是先于x的，那么thread d就可能第2个load是false了，此时z=1（这里好像就是第1种情况了？，这里的解释不一定正确）</p>\n<p>接下来是acq-rel模型，它解除了对全局一致性的约束，只单纯地利用memory_order_acquire和memory_order_release,前者如果某个load使用则在load之前的指令都不能跨过该语句被重排到后面，后者则是某个store使用则其后语句不能被重排跨到前面<br>我们经常利用他们去实现同步操作，但是这里要注意，它无法保证全局一致，也就是说，每个thread观测到的顺序是可能不一样的，如下例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;assert.h&gt;</span><br><span class=\"line\">std::atomic&lt;bool&gt; x,y;</span><br><span class=\"line\">std::atomic&lt;int&gt; z;</span><br><span class=\"line\">void write_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x.store(true,std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void write_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> y.store(true,std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_x_then_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!x.load(std::memory_order_acquire));</span><br><span class=\"line\"> if(y.load(std::memory_order_acquire)) // 1</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_y_then_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!y.load(std::memory_order_acquire));</span><br><span class=\"line\"> if(x.load(std::memory_order_acquire)) // 2</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x=false;</span><br><span class=\"line\"> y=false;</span><br><span class=\"line\"> z=0;</span><br><span class=\"line\"> std::thread a(write_x);</span><br><span class=\"line\"> std::thread b(write_y);</span><br><span class=\"line\"> std::thread c(read_x_then_y);</span><br><span class=\"line\"> std::thread d(read_y_then_x);</span><br><span class=\"line\"> a.join();</span><br><span class=\"line\"> b.join();</span><br><span class=\"line\"> c.join();</span><br><span class=\"line\"> d.join();</span><br><span class=\"line\"> assert(z.load()!=0); // 3</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于不同thread的对同1个原子变量，acq-rel的语义只能做到——如果在load的时候观察到了store，那么必然就能保证我们需要的同步，如果在load的时候还没观察到store的话就做不到了，如下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;cassert&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;chrono&gt;</span><br><span class=\"line\">std::atomic&lt;std::string*&gt; ptr ;</span><br><span class=\"line\">int data;</span><br><span class=\"line\"> </span><br><span class=\"line\">void producer()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::this_thread::sleep_for(std::chrono::milliseconds(1000));</span><br><span class=\"line\">    std::string* p  = new std::string(&quot;Hello&quot;);</span><br><span class=\"line\">    data = 42;</span><br><span class=\"line\">    ptr.store(p, std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">void consumer()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::string* p2 = nullptr;</span><br><span class=\"line\">    //std::this_thread::sleep_for(std::chrono::milliseconds(1000));</span><br><span class=\"line\">    p2 = ptr.load(std::memory_order_acquire);</span><br><span class=\"line\">    assert(*p2 == &quot;Hello&quot;); // never fires</span><br><span class=\"line\">    assert(data == 42);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::thread t1(producer);</span><br><span class=\"line\">    std::thread t2(consumer);</span><br><span class=\"line\">    t1.join(); t2.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码大多数时候是报错的，因为thread 1 sleep了一段时间，所以在第2个thread中，在它load的时候，第1个thread的store因为sleep的原因未执行，导致了它无法做到同步，所以下面的assert必然报错，但如果修改p2，改成while(!p2=ptr.load(std::memory_order_acquire)),就能实现同步了，因为它会一直在while中循环，直到某1次循环中，它观察到了线程1的store操作，那么这2者的同步语义就能建立起来了——线程1的store之前的语句必然先于store，线程2的load之后的语句必然非先于load，而它跳出循环的时候store必然是已经被观测到了，所以这种同步就建立起来了<br>回头看上一段代码，这段代码可能报错的原因就在于，acq-rel语义没有规定全局一致，那么就可能出现thread c观测到x的store先于y的store，而d则反过来，此时他们就都加不了z，或者说我们可以这么理解——全局一致下，c看到了x是true，y只load1次看到是false，说明x的store对d来说也必然先于y的store，而d一直卡在while那里，直到它观测到y是true；但没有全局一致的要求时，以下情况就可能发生——对thread c，它卡在while一段时间退去后，此时它肯定观测到了x的sotre，而它只对y进行了1次load，是false，说明它观测到x的store先于y，但对d而言，没有全局一致的约束，c的观测顺序对它没意义了，它完全可以一直卡在while，直到它观测到y的store，然后在对x进行1次load，发现x的store还没被观察到，对d而言，它是先观测到y后才是x，那么这种矛盾的原因在于，x和y的store它可能是写入内存，而c和d在load的时候，不一定去内存找，它可能直接在自己的cache中找，不一致就来了<br>那么怎么修改这段代码呢，很简单，只要保证x和y他们的被观测到的顺序是一样的就可以了，上述由于是分开被2个线程写的原因<br>如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;assert.h&gt;</span><br><span class=\"line\">std::atomic&lt;bool&gt; x,y;</span><br><span class=\"line\">std::atomic&lt;int&gt; z;</span><br><span class=\"line\">void write_x_then_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x.store(true,std::memory_order_relaxed); // 1 </span><br><span class=\"line\"> y.store(true,std::memory_order_release); // 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_y_then_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!y.load(std::memory_order_acquire)); // 3 自旋，等待y被设置为true</span><br><span class=\"line\"> if(x.load(std::memory_order_relaxed)) // 4</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x=false;</span><br><span class=\"line\"> y=false;</span><br><span class=\"line\"> z=0;</span><br><span class=\"line\"> std::thread a(write_x_then_y);</span><br><span class=\"line\"> std::thread b(read_y_then_x);</span><br><span class=\"line\"> a.join();</span><br><span class=\"line\"> b.join();</span><br><span class=\"line\"> assert(z.load()!=0); // 5</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就不用解释了，但如果说y的load不是while，而是只读1次，那这种同步性就没有了，因为它完全有可能在load之前没有观察到store，加上while，不断的load，直到某1次，发现y被store为true了，这次的load就和store有了先后顺序了，那么就可以保证同步了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>c++的内存模型挺复杂的，因为现代cpu架构的原因，例如cache等，一些操作我们无法得知他具体什么时候会对其他线程可见，例如说thread A写了一个全局变量，但它很有可能是写到自己的私有cache导致说它的这个写对其他thread不可见，那么c++对于这些就提出了一个叫内存模型的玩意。<br>首先是顺序一致性模型，它规定有2点：<br>1.内存访问执行的顺序与程序指定的顺序相同<br>2.所有核心的内存访问实际执行顺序都和程序指定顺序相同<br>有1个例子就可以说明这个，一个群聊里，每个人的发言记录的顺序是固定的，不可能说先看到晚发出去的信息，而他所看到的所有人的发言记录，与其他的每个人都一样，都是遵循着某种交叉着的顺序，而且大家观察到的顺序都是一样的，<br>而c++默认就是使用这种内存模型，即memory_order_seq_cst,以下面这段代码为例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;assert.h&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">std::atomic&lt;bool&gt; x,y;</span><br><span class=\"line\">std::atomic&lt;int&gt; z;</span><br><span class=\"line\">void write_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x.store(true,std::memory_order_seq_cst); // 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void write_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> y.store(true,std::memory_order_seq_cst); // 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_x_then_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!x.load(std::memory_order_seq_cst));</span><br><span class=\"line\"> if(y.load(std::memory_order_seq_cst)) // 3</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\"> //std::cout &lt;&lt; z &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_y_then_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!y.load(std::memory_order_seq_cst));</span><br><span class=\"line\"> if(x.load(std::memory_order_seq_cst)) // 4</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\"> //std::cout &lt;&lt; z &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x=false;</span><br><span class=\"line\"> y=false;</span><br><span class=\"line\"> z=0;</span><br><span class=\"line\"> std::thread a(write_x);</span><br><span class=\"line\"> std::thread b(write_y);</span><br><span class=\"line\"> std::thread c(read_x_then_y);</span><br><span class=\"line\"> std::thread d(read_y_then_x);</span><br><span class=\"line\"> a.join();</span><br><span class=\"line\"> b.join();</span><br><span class=\"line\"> c.join();</span><br><span class=\"line\"> d.join();</span><br><span class=\"line\"> assert(z.load()!=0); // 5</span><br><span class=\"line\"> std::cout &lt;&lt; z &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里assert永远不会报错，且下一步输出的z有可能是1，有可能是2，下面分别分析：<br>如果第1个load是true，但第2个load是false，也就算说它观察到了x的store是先于y的store，或者说在它跳出while的时候，肯定是看到了x的store操作，但y的load还是false，说明它没观察到y的store操作，所以它观察到的所x的store先于y的store，那么对thread d而言，它也必须以这种顺序观察到2个store，所以说thread d的第1个load如果是true了，说明它观察到了y的store，所以它必然已经观察到了x的store，所以它下一步的load必然为true，反过来也同理，这个时候的z就是1了<br>而z=2的情况为还不是很明白，假如说a的第一个load到了某个时间点，观察到了x的store，它退出了while，然后它第2个load，观察到了y是true，但这就没办法确定x和y的store的观察顺序了，如果x的store先于y，那么对d而言，它的2个load必然为ture，z=2，如果y的store是先于x的，那么thread d就可能第2个load是false了，此时z=1（这里好像就是第1种情况了？，这里的解释不一定正确）</p>\n<p>接下来是acq-rel模型，它解除了对全局一致性的约束，只单纯地利用memory_order_acquire和memory_order_release,前者如果某个load使用则在load之前的指令都不能跨过该语句被重排到后面，后者则是某个store使用则其后语句不能被重排跨到前面<br>我们经常利用他们去实现同步操作，但是这里要注意，它无法保证全局一致，也就是说，每个thread观测到的顺序是可能不一样的，如下例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;assert.h&gt;</span><br><span class=\"line\">std::atomic&lt;bool&gt; x,y;</span><br><span class=\"line\">std::atomic&lt;int&gt; z;</span><br><span class=\"line\">void write_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x.store(true,std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void write_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> y.store(true,std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_x_then_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!x.load(std::memory_order_acquire));</span><br><span class=\"line\"> if(y.load(std::memory_order_acquire)) // 1</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_y_then_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!y.load(std::memory_order_acquire));</span><br><span class=\"line\"> if(x.load(std::memory_order_acquire)) // 2</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x=false;</span><br><span class=\"line\"> y=false;</span><br><span class=\"line\"> z=0;</span><br><span class=\"line\"> std::thread a(write_x);</span><br><span class=\"line\"> std::thread b(write_y);</span><br><span class=\"line\"> std::thread c(read_x_then_y);</span><br><span class=\"line\"> std::thread d(read_y_then_x);</span><br><span class=\"line\"> a.join();</span><br><span class=\"line\"> b.join();</span><br><span class=\"line\"> c.join();</span><br><span class=\"line\"> d.join();</span><br><span class=\"line\"> assert(z.load()!=0); // 3</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于不同thread的对同1个原子变量，acq-rel的语义只能做到——如果在load的时候观察到了store，那么必然就能保证我们需要的同步，如果在load的时候还没观察到store的话就做不到了，如下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;cassert&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;chrono&gt;</span><br><span class=\"line\">std::atomic&lt;std::string*&gt; ptr ;</span><br><span class=\"line\">int data;</span><br><span class=\"line\"> </span><br><span class=\"line\">void producer()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::this_thread::sleep_for(std::chrono::milliseconds(1000));</span><br><span class=\"line\">    std::string* p  = new std::string(&quot;Hello&quot;);</span><br><span class=\"line\">    data = 42;</span><br><span class=\"line\">    ptr.store(p, std::memory_order_release);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">void consumer()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::string* p2 = nullptr;</span><br><span class=\"line\">    //std::this_thread::sleep_for(std::chrono::milliseconds(1000));</span><br><span class=\"line\">    p2 = ptr.load(std::memory_order_acquire);</span><br><span class=\"line\">    assert(*p2 == &quot;Hello&quot;); // never fires</span><br><span class=\"line\">    assert(data == 42);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::thread t1(producer);</span><br><span class=\"line\">    std::thread t2(consumer);</span><br><span class=\"line\">    t1.join(); t2.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码大多数时候是报错的，因为thread 1 sleep了一段时间，所以在第2个thread中，在它load的时候，第1个thread的store因为sleep的原因未执行，导致了它无法做到同步，所以下面的assert必然报错，但如果修改p2，改成while(!p2=ptr.load(std::memory_order_acquire)),就能实现同步了，因为它会一直在while中循环，直到某1次循环中，它观察到了线程1的store操作，那么这2者的同步语义就能建立起来了——线程1的store之前的语句必然先于store，线程2的load之后的语句必然非先于load，而它跳出循环的时候store必然是已经被观测到了，所以这种同步就建立起来了<br>回头看上一段代码，这段代码可能报错的原因就在于，acq-rel语义没有规定全局一致，那么就可能出现thread c观测到x的store先于y的store，而d则反过来，此时他们就都加不了z，或者说我们可以这么理解——全局一致下，c看到了x是true，y只load1次看到是false，说明x的store对d来说也必然先于y的store，而d一直卡在while那里，直到它观测到y是true；但没有全局一致的要求时，以下情况就可能发生——对thread c，它卡在while一段时间退去后，此时它肯定观测到了x的sotre，而它只对y进行了1次load，是false，说明它观测到x的store先于y，但对d而言，没有全局一致的约束，c的观测顺序对它没意义了，它完全可以一直卡在while，直到它观测到y的store，然后在对x进行1次load，发现x的store还没被观察到，对d而言，它是先观测到y后才是x，那么这种矛盾的原因在于，x和y的store它可能是写入内存，而c和d在load的时候，不一定去内存找，它可能直接在自己的cache中找，不一致就来了<br>那么怎么修改这段代码呢，很简单，只要保证x和y他们的被观测到的顺序是一样的就可以了，上述由于是分开被2个线程写的原因<br>如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;assert.h&gt;</span><br><span class=\"line\">std::atomic&lt;bool&gt; x,y;</span><br><span class=\"line\">std::atomic&lt;int&gt; z;</span><br><span class=\"line\">void write_x_then_y()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x.store(true,std::memory_order_relaxed); // 1 </span><br><span class=\"line\"> y.store(true,std::memory_order_release); // 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void read_y_then_x()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> while(!y.load(std::memory_order_acquire)); // 3 自旋，等待y被设置为true</span><br><span class=\"line\"> if(x.load(std::memory_order_relaxed)) // 4</span><br><span class=\"line\"> ++z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> x=false;</span><br><span class=\"line\"> y=false;</span><br><span class=\"line\"> z=0;</span><br><span class=\"line\"> std::thread a(write_x_then_y);</span><br><span class=\"line\"> std::thread b(read_y_then_x);</span><br><span class=\"line\"> a.join();</span><br><span class=\"line\"> b.join();</span><br><span class=\"line\"> assert(z.load()!=0); // 5</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就不用解释了，但如果说y的load不是while，而是只读1次，那这种同步性就没有了，因为它完全有可能在load之前没有观察到store，加上while，不断的load，直到某1次，发现y被store为true了，这次的load就和store有了先后顺序了，那么就可以保证同步了</p>\n"},{"layout":"init","title":"模板偏特化","date":"2022-09-04T13:53:25.000Z","_content":"","source":"_posts/模板偏特化-1.md","raw":"---\nlayout: init\ntitle: 模板偏特化\ndate: 2022-09-04 21:53:25\ntags:\n---\n","slug":"模板偏特化-1","published":1,"updated":"2022-09-04T13:53:25.067Z","comments":1,"photos":[],"link":"","_id":"cl7o7xgmk0001zepvamre4kid","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"init","title":"模板偏特化","date":"2022-09-04T12:02:45.000Z","_content":"\n模板偏特化，就\n","source":"_posts/模板偏特化.md","raw":"---\nlayout: init\ntitle: 模板偏特化\ndate: 2022-09-04 20:02:45\ntags: c++\n---\n\n模板偏特化，就\n","slug":"模板偏特化","published":1,"updated":"2022-09-05T03:48:45.326Z","_id":"cl7o7xgmn0003zepvd4ukabme","comments":1,"photos":[],"link":"","content":"<p>模板偏特化，就</p>\n","site":{"data":{}},"excerpt":"","more":"<p>模板偏特化，就</p>\n"},{"layout":"init","title":"shared_ptr线程安全","date":"2022-09-05T07:36:09.000Z","_content":"\nshared_ptr众所周知的智能指针，其允许多个指针指向同一内存对象，且在引用计数为0的时候自动析构被管理的对象，但是，在多线程的环境下，他的操作不是线程安全的，\n原因在于，其管理对象的方式是通过指针去管理，而其底层的引用计数本身也是一个指针，指向一个真正的计数对象，当我们执行如下代码的时候\n~~~\nshared_ptr<A> a1 (new A));\nshared_ptr<A> a2 = a1;\n~~~\na2在构造的时候，是分为2步的，第1步是让a2管理的A对象指向a1管理的对象，第2步是让a2的引用计数也指向a1的引用计数对象，然后再把count+1\n那么这种非原子的操作方式就可能带来race condition了，如下代码\n~~~\n#include <memory>\n#include <iostream>\n#include <thread>\n\nstd::shared_ptr<int> p1 (new int(5));\n\nvoid func1(){\n  std::shared_ptr<int> p2;\n  p2 = p1;\n  std::cout << *p2 << std::endl;\n}\n\nvoid func2(){\n  std::shared_ptr<int> p3;\n  p1 = p3;\n}\n\nint main(){\n  std::thread t1(func1);\n  std::thread t2(func2);\n  t1.join();\n  t2.join();\n}\n~~~\n当线程1执行p2 = p1的时候，首先他会把p1管理对象的指针赋值给p2，但这个时候，线程2来了，他的p1 = p3的赋值操作，导致p1原来管理的int(5)变成了1个没人指向的对象，所以其对应的引用计数也为0，且这个原来的对象就被析构了，此时p1所指的引用计数对象，他的count是2，再下一步，来到线程1，p2 = p1指令继续赋值，把p1的新的引用计数对象赋给了p2，那么这个引用计数对象的count就是3了，但此时p2所指的是那个已经被析构了的int(5),这个时候我们再解引用p2，就会报错了，如图：\n![](/images/shared_ptr线程安全/dump.png)\n中间的那个偶尔的段错误吐核就是啦\n所以这里要记住：shared_ptr的实现机制，最核心的就是使用2个指针，指向1个被管理对象和1个与之关联的引用计数对象，在赋值的时候是分2步的非原子操作，所以这个时候一定要加锁使其原子化\n\n","source":"_posts/shared-ptr线程安全.md","raw":"---\nlayout: init\ntitle: shared_ptr线程安全\ndate: 2022-09-05 15:36:09\ntags: c++\n---\n\nshared_ptr众所周知的智能指针，其允许多个指针指向同一内存对象，且在引用计数为0的时候自动析构被管理的对象，但是，在多线程的环境下，他的操作不是线程安全的，\n原因在于，其管理对象的方式是通过指针去管理，而其底层的引用计数本身也是一个指针，指向一个真正的计数对象，当我们执行如下代码的时候\n~~~\nshared_ptr<A> a1 (new A));\nshared_ptr<A> a2 = a1;\n~~~\na2在构造的时候，是分为2步的，第1步是让a2管理的A对象指向a1管理的对象，第2步是让a2的引用计数也指向a1的引用计数对象，然后再把count+1\n那么这种非原子的操作方式就可能带来race condition了，如下代码\n~~~\n#include <memory>\n#include <iostream>\n#include <thread>\n\nstd::shared_ptr<int> p1 (new int(5));\n\nvoid func1(){\n  std::shared_ptr<int> p2;\n  p2 = p1;\n  std::cout << *p2 << std::endl;\n}\n\nvoid func2(){\n  std::shared_ptr<int> p3;\n  p1 = p3;\n}\n\nint main(){\n  std::thread t1(func1);\n  std::thread t2(func2);\n  t1.join();\n  t2.join();\n}\n~~~\n当线程1执行p2 = p1的时候，首先他会把p1管理对象的指针赋值给p2，但这个时候，线程2来了，他的p1 = p3的赋值操作，导致p1原来管理的int(5)变成了1个没人指向的对象，所以其对应的引用计数也为0，且这个原来的对象就被析构了，此时p1所指的引用计数对象，他的count是2，再下一步，来到线程1，p2 = p1指令继续赋值，把p1的新的引用计数对象赋给了p2，那么这个引用计数对象的count就是3了，但此时p2所指的是那个已经被析构了的int(5),这个时候我们再解引用p2，就会报错了，如图：\n![](/images/shared_ptr线程安全/dump.png)\n中间的那个偶尔的段错误吐核就是啦\n所以这里要记住：shared_ptr的实现机制，最核心的就是使用2个指针，指向1个被管理对象和1个与之关联的引用计数对象，在赋值的时候是分2步的非原子操作，所以这个时候一定要加锁使其原子化\n\n","slug":"shared-ptr线程安全","published":1,"updated":"2022-09-05T07:55:00.570Z","comments":1,"photos":[],"link":"","_id":"cl7ogwsy80000d6pvbb47fdys","content":"<p>shared_ptr众所周知的智能指针，其允许多个指针指向同一内存对象，且在引用计数为0的时候自动析构被管理的对象，但是，在多线程的环境下，他的操作不是线程安全的，<br>原因在于，其管理对象的方式是通过指针去管理，而其底层的引用计数本身也是一个指针，指向一个真正的计数对象，当我们执行如下代码的时候</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;A&gt; a1 (new A));</span><br><span class=\"line\">shared_ptr&lt;A&gt; a2 = a1;</span><br></pre></td></tr></table></figure>\n<p>a2在构造的时候，是分为2步的，第1步是让a2管理的A对象指向a1管理的对象，第2步是让a2的引用计数也指向a1的引用计数对象，然后再把count+1<br>那么这种非原子的操作方式就可能带来race condition了，如下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;memory&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">std::shared_ptr&lt;int&gt; p1 (new int(5));</span><br><span class=\"line\"></span><br><span class=\"line\">void func1()&#123;</span><br><span class=\"line\">  std::shared_ptr&lt;int&gt; p2;</span><br><span class=\"line\">  p2 = p1;</span><br><span class=\"line\">  std::cout &lt;&lt; *p2 &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void func2()&#123;</span><br><span class=\"line\">  std::shared_ptr&lt;int&gt; p3;</span><br><span class=\"line\">  p1 = p3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">  std::thread t1(func1);</span><br><span class=\"line\">  std::thread t2(func2);</span><br><span class=\"line\">  t1.join();</span><br><span class=\"line\">  t2.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当线程1执行p2 = p1的时候，首先他会把p1管理对象的指针赋值给p2，但这个时候，线程2来了，他的p1 = p3的赋值操作，导致p1原来管理的int(5)变成了1个没人指向的对象，所以其对应的引用计数也为0，且这个原来的对象就被析构了，此时p1所指的引用计数对象，他的count是2，再下一步，来到线程1，p2 = p1指令继续赋值，把p1的新的引用计数对象赋给了p2，那么这个引用计数对象的count就是3了，但此时p2所指的是那个已经被析构了的int(5),这个时候我们再解引用p2，就会报错了，如图：<br><img src=\"/images/shared_ptr%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/dump.png\"><br>中间的那个偶尔的段错误吐核就是啦<br>所以这里要记住：shared_ptr的实现机制，最核心的就是使用2个指针，指向1个被管理对象和1个与之关联的引用计数对象，在赋值的时候是分2步的非原子操作，所以这个时候一定要加锁使其原子化</p>\n","site":{"data":{}},"excerpt":"","more":"<p>shared_ptr众所周知的智能指针，其允许多个指针指向同一内存对象，且在引用计数为0的时候自动析构被管理的对象，但是，在多线程的环境下，他的操作不是线程安全的，<br>原因在于，其管理对象的方式是通过指针去管理，而其底层的引用计数本身也是一个指针，指向一个真正的计数对象，当我们执行如下代码的时候</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;A&gt; a1 (new A));</span><br><span class=\"line\">shared_ptr&lt;A&gt; a2 = a1;</span><br></pre></td></tr></table></figure>\n<p>a2在构造的时候，是分为2步的，第1步是让a2管理的A对象指向a1管理的对象，第2步是让a2的引用计数也指向a1的引用计数对象，然后再把count+1<br>那么这种非原子的操作方式就可能带来race condition了，如下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;memory&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">std::shared_ptr&lt;int&gt; p1 (new int(5));</span><br><span class=\"line\"></span><br><span class=\"line\">void func1()&#123;</span><br><span class=\"line\">  std::shared_ptr&lt;int&gt; p2;</span><br><span class=\"line\">  p2 = p1;</span><br><span class=\"line\">  std::cout &lt;&lt; *p2 &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void func2()&#123;</span><br><span class=\"line\">  std::shared_ptr&lt;int&gt; p3;</span><br><span class=\"line\">  p1 = p3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">  std::thread t1(func1);</span><br><span class=\"line\">  std::thread t2(func2);</span><br><span class=\"line\">  t1.join();</span><br><span class=\"line\">  t2.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当线程1执行p2 = p1的时候，首先他会把p1管理对象的指针赋值给p2，但这个时候，线程2来了，他的p1 = p3的赋值操作，导致p1原来管理的int(5)变成了1个没人指向的对象，所以其对应的引用计数也为0，且这个原来的对象就被析构了，此时p1所指的引用计数对象，他的count是2，再下一步，来到线程1，p2 = p1指令继续赋值，把p1的新的引用计数对象赋给了p2，那么这个引用计数对象的count就是3了，但此时p2所指的是那个已经被析构了的int(5),这个时候我们再解引用p2，就会报错了，如图：<br><img src=\"/images/shared_ptr%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/dump.png\"><br>中间的那个偶尔的段错误吐核就是啦<br>所以这里要记住：shared_ptr的实现机制，最核心的就是使用2个指针，指向1个被管理对象和1个与之关联的引用计数对象，在赋值的时候是分2步的非原子操作，所以这个时候一定要加锁使其原子化</p>\n"},{"layout":"init","title":"局部静态对象","date":"2022-09-05T15:35:19.000Z","_content":"\n\n\nc++11规定，在一个函数内的局部静态变量(local static),它的初始化是必须线程安全的，也就是说，它的初始化过程是加锁的，其他线程在其初始化过程中是被阻塞的，否则就可能说1个线程在初始化过程中在还没赋值之前，另1个线程也开始初始化，最后就造成了重复构造，具体如下代码\n~~~\n#include <thread>\n#include <iostream>\n#include <mutex>\nclass A {\npublic:\nA(){ std::cout << \"constructing\" << std::endl; }\n\n};\n\nA& getA(){\n  static A a;\n  return a;\n}\n\nstd::mutex lock;\nvoid func(){\n  A a = getA();\n  std::unique_lock<std::mutex> mylock (lock);\n  std::cout << &a << std::endl;\n}\n\nint main(){\n  std::thread thread_list[10];\n  for (int i = 0; i < 10; i++){\n    thread_list[i] = std::thread(func);\n  }\n  for (int i = 0; i < 10; i++){\n    thread_list[i].join();\n  }\n}\n~~~\n![](/images/local_static/res.png)\n\n可以看到，这个对象只被正确地构造了1次，其他线程都引用同一个对象\n这种方式是c++实现单例模式的最佳手段，因为它就是这么简单\n","source":"_posts/局部静态对象.md","raw":"---\nlayout: init\ntitle: 局部静态对象\ndate: 2022-09-05 23:35:19\ntags: c++\n---\n\n\n\nc++11规定，在一个函数内的局部静态变量(local static),它的初始化是必须线程安全的，也就是说，它的初始化过程是加锁的，其他线程在其初始化过程中是被阻塞的，否则就可能说1个线程在初始化过程中在还没赋值之前，另1个线程也开始初始化，最后就造成了重复构造，具体如下代码\n~~~\n#include <thread>\n#include <iostream>\n#include <mutex>\nclass A {\npublic:\nA(){ std::cout << \"constructing\" << std::endl; }\n\n};\n\nA& getA(){\n  static A a;\n  return a;\n}\n\nstd::mutex lock;\nvoid func(){\n  A a = getA();\n  std::unique_lock<std::mutex> mylock (lock);\n  std::cout << &a << std::endl;\n}\n\nint main(){\n  std::thread thread_list[10];\n  for (int i = 0; i < 10; i++){\n    thread_list[i] = std::thread(func);\n  }\n  for (int i = 0; i < 10; i++){\n    thread_list[i].join();\n  }\n}\n~~~\n![](/images/local_static/res.png)\n\n可以看到，这个对象只被正确地构造了1次，其他线程都引用同一个对象\n这种方式是c++实现单例模式的最佳手段，因为它就是这么简单\n","slug":"局部静态对象","published":1,"updated":"2022-09-05T15:43:58.446Z","comments":1,"photos":[],"link":"","_id":"cl7oxnq8n00001apvcxtcc7f4","content":"<p>c++11规定，在一个函数内的局部静态变量(local static),它的初始化是必须线程安全的，也就是说，它的初始化过程是加锁的，其他线程在其初始化过程中是被阻塞的，否则就可能说1个线程在初始化过程中在还没赋值之前，另1个线程也开始初始化，最后就造成了重复构造，具体如下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;mutex&gt;</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">A()&#123; std::cout &lt;&lt; &quot;constructing&quot; &lt;&lt; std::endl; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">A&amp; getA()&#123;</span><br><span class=\"line\">  static A a;</span><br><span class=\"line\">  return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::mutex lock;</span><br><span class=\"line\">void func()&#123;</span><br><span class=\"line\">  A a = getA();</span><br><span class=\"line\">  std::unique_lock&lt;std::mutex&gt; mylock (lock);</span><br><span class=\"line\">  std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">  std::thread thread_list[10];</span><br><span class=\"line\">  for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">    thread_list[i] = std::thread(func);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">    thread_list[i].join();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/local_static/res.png\"></p>\n<p>可以看到，这个对象只被正确地构造了1次，其他线程都引用同一个对象<br>这种方式是c++实现单例模式的最佳手段，因为它就是这么简单</p>\n","site":{"data":{}},"excerpt":"","more":"<p>c++11规定，在一个函数内的局部静态变量(local static),它的初始化是必须线程安全的，也就是说，它的初始化过程是加锁的，其他线程在其初始化过程中是被阻塞的，否则就可能说1个线程在初始化过程中在还没赋值之前，另1个线程也开始初始化，最后就造成了重复构造，具体如下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;thread&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;mutex&gt;</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">A()&#123; std::cout &lt;&lt; &quot;constructing&quot; &lt;&lt; std::endl; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">A&amp; getA()&#123;</span><br><span class=\"line\">  static A a;</span><br><span class=\"line\">  return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::mutex lock;</span><br><span class=\"line\">void func()&#123;</span><br><span class=\"line\">  A a = getA();</span><br><span class=\"line\">  std::unique_lock&lt;std::mutex&gt; mylock (lock);</span><br><span class=\"line\">  std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">  std::thread thread_list[10];</span><br><span class=\"line\">  for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">    thread_list[i] = std::thread(func);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">    thread_list[i].join();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/local_static/res.png\"></p>\n<p>可以看到，这个对象只被正确地构造了1次，其他线程都引用同一个对象<br>这种方式是c++实现单例模式的最佳手段，因为它就是这么简单</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cl7kmirrs00009kpv6ab995u7","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7kmmz7t0001oepvgm9whlmy"},{"post_id":"cl7kjsgzp0001ospv3gja6xid","tag_id":"cl7kmw2kt0000y0pvgvyefmel","_id":"cl7kmw2l30001y0pv41zp3lss"},{"post_id":"cl7n1867u00007fpv3ge1ad3e","tag_id":"cl7n1868000017fpv10563ts2","_id":"cl7n1868200027fpv9pjr8dyr"},{"post_id":"cl7n9mgb0000097pv77cmci4p","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7n9mgb8000197pv3sghfu48"},{"post_id":"cl7o7xgmf0000zepv3hir66l1","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7o7xgmm0002zepv678a0vdb"},{"post_id":"cl7o7xgmn0003zepvd4ukabme","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7ogwsye0001d6pvcwha5h2d"},{"post_id":"cl7ogwsy80000d6pvbb47fdys","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7ogwsyf0002d6pvf8jac3ph"},{"post_id":"cl7oxnq8n00001apvcxtcc7f4","tag_id":"cl7kmmz7n0000oepv1lwy29q1","_id":"cl7oxnq8y00011apvh9qe2yiu"}],"Tag":[{"name":"c++","_id":"cl7kmmz7n0000oepv1lwy29q1"},{"name":"c+2","_id":"cl7kmw2kt0000y0pvgvyefmel"},{"name":"tvm","_id":"cl7n1868000017fpv10563ts2"}]}}