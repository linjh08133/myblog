<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="lin"><title>effective modern c ++ 31-33 · Hexo</title><meta name="description" content="从条款31开始进入第6大章，也就是关于lambda表达式的内容31讲的是关于默认捕获的一些缺点首先是关于默认引用捕获，即&amp;amp;{}的，最明显的就是他往往会有引用局部变量的错误，这个也是这系列书一直在强调的一个点，千万不能引用1个很容易就析构了的局部变量，例子如下
1234567891011121"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Hexo</a></h3><div class="description"><p>this is my blog. love furry 捏</p></div></div><ul class="social-links"><li><a href="mailto:275911105@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=275911105"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span>  </span><i class="fa fa-star"></i><span> lin</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>effective modern c ++ 31-33</a></h3></div><div class="post-content"><p><p>从条款31开始进入第6大章，也就是关于lambda表达式的内容<br>31讲的是关于默认捕获的一些缺点<br>首先是关于默认引用捕获，即<a href="">&amp;</a>{}的，最明显的就是他往往会有引用局部变量的错误，这个也是这系列书一直在强调的一个点，千万不能引用1个很容易就析构了的局部变量，例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void add_elem(vector&lt;function&lt;bool(int)&gt;&gt; vec)&#123;</span><br><span class="line">  int i = 2;</span><br><span class="line">  vec.emplace_back([&amp;](int value)&#123;return value==i;&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  vector&lt;function&lt;bool(int)&gt;&gt; vec;</span><br><span class="line">  add_elem(vec);</span><br><span class="line">  vec[0](3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面报错吐核，因为引用了一个早就已经释放了的局部变量i，而作者建议，如果要用&amp;，最好把要引用的变量也写进去，这样子究竟引用了啥也容易查找，当然像这种情况，最优实践就是按值捕获<br>但按值捕获也具有一定的缺点，最明显的是指针类型上，按值捕获使得同个地址被2个变量所拥有，就有了多重析构的可能，当然我们可以通过智能指针去解决<br>还有另外1个问题就是在类的非静态成员函数里的lambda表达式，他的捕获都是捕获this指针的，因为在这些成员函数里，数据成员本来就不在他的局部作用域内，怎么可能捕获到，而他们又持有this指针，所以对下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">  void dosth();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  double i;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void A::dosth()&#123;</span><br><span class="line">    auto lambda1 = [&amp;i]()&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会报捕获不了i的错，解决方法也很简单，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void A::dosth()&#123;</span><br><span class="line">    auto lambda2 = [this]()&#123;this-&gt;i;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接按值捕获this指针即可，从上面也可以看出，这个lambda表达式的生存周期，和this指针，也就是this所指对象的生存周期是一致的，所以这里也需要我们注意不要把一些局部作用域里的对象的this指针给传递出来，因为很有可能在离开这个作用域后这个对象就析构了，this指针就空悬了，解决方式是不使用this指针，直接把我们需要的数据给引进来，如在lambda之前加上一句auto tmp = i的操作，或者使用14标准的广义lambda捕获，即[d = i]的操作<br>最后一点讲的是一些static变量，他们是不能被按值捕获的，因此表面上在一些函数体内，我们使用[=]把非静态的局部变量给按值捕获了，但实际上其表现出来的行为是按引用捕获的，我们可以写个例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void func(vector&lt;function&lt;void()&gt;&gt; &amp;vec)&#123;</span><br><span class="line">  static int i = 0;</span><br><span class="line">  vec.emplace_back([=]()&#123;cout &lt;&lt; i &lt;&lt; endl;&#125;);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  vector&lt;function&lt;void()&gt;&gt; vec;</span><br><span class="line">  func(vec);</span><br><span class="line">  func(vec);</span><br><span class="line">  vec[0]();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表面上看，每个lambda都按值捕获了i的副本，但实际上他们是以引用的方式捕获的，所以最后输出的结果是2<br>条款32讲的就是上面提及到的广义lambda捕获，标准上叫做初始化捕获<br>在11的时候，假如我们想要把一些只移对象或者一些移动操作比复制快的多的对象移动到闭包内，11并没有直接的方式支持，而到了14，就出现了广义lambda捕获，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">auto ptr = make_unique&lt;Widget&gt;();</span><br><span class="line">auto lambda1 = [ptr = move(ptr)]()&#123;&#125;;</span><br><span class="line">auto lamdba2 = [ptr = make_unique&lt;Widget&gt;()]()&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>其中要注意的是，在[]中，等号左边的ptr的作用域是闭包外的作用域，而等号右边的ptr的作用域则是在闭包内的作用域<br>而在11中，我们也是可以自己写一个类似的东西，只要他有1个接收unique_ptr的构造函数，1个重载（）运算符的函数就够用了<br>除此之外，我们还可以使用bind去实现（在11中），如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto pw = make_unique&lt;int&gt;(3);</span><br><span class="line"></span><br><span class="line">auto mylambda = </span><br><span class="line">  bind([](const unique_ptr&lt;int&gt;&amp; pw)&#123;&#125;,</span><br><span class="line">       move(pw));</span><br></pre></td></tr></table></figure>
<p>bind的第1个参数是可调用对象，在这里就是我们需要的lambda表达式，而后面的参数则是可调用对象的参数列表，那么在调用这个bind的对象时，如mylambda(),则会把第2个参数，也就是右值unique_ptr用于初始化lambda表达式里的pw，就实现了我们需要的初始化捕获<br>不过现在14的标准就不用这么麻烦啦<br>条款33讲的是对于使用auto&amp;&amp;的形参，如何保证其左右值的特性<br>对于下面的lambda表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto lambda1 = [](auto i)&#123; func(dosth(i));&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器会做的，就是生成1个类，然后重载()运算符，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class sth&#123;</span><br><span class="line">public:</span><br><span class="line">  template&lt;typename T&gt;</span><br><span class="line">  void operator()(T x) const&#123;</span><br><span class="line">    func(dosth(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里不管传进来的是左值还是右值，都会被当成1个左值看待，那很自然的，我们就会想把其改写成万能引用（auto&amp;&amp;）+完美转发（forward）的形式，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto lambda1 = [](auto&amp;&amp; i)&#123;func(dosth(forward&lt;&gt;(i)));&#125;;</span><br></pre></td></tr></table></figure>
<p>但问题来了，我们究竟拿什么去获取forward的实例化参数呢，我们根本不知道i是什么类型呀，那这个时候，decltype就派上用处了<br>decltype(i)作为模板实参，则当传进来的是个左值的时候，i会被推导为左值引用，那么decltype推导出左值引用类型；当传进来的是右值的时候，万能引用会推导为右值引用，则decltype会得到1个右值引用类型，不过这里需要注意的一点是，forward我们一般使用的时候，一般的惯例是左值引用的对立面是非引用，也就是说，传进来的应该是个type而不是type&amp;&amp;，但在这里无伤大雅，因为就算decltype推出来是个&amp;&amp;，forward返回的是T&amp;&amp;,也即T&amp;&amp; &amp;&amp;,在引用折叠的作用下，还是返回1个右值，没什么影响。<br>所以最终的解决方案时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto lambda2 = [](auto &amp;&amp; i)&#123; func(dosth(forward&lt;decltype&lt;i&gt;&gt;(i)));&#125;;</span><br></pre></td></tr></table></figure>
<p>推广到可变模板参数时，也很简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto lamdba3 = [](auto &amp;&amp; ...args)&#123; func(dosth(forward&lt;decltype(args)&gt;(args)...));&#125;;</span><br></pre></td></tr></table></figure>
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-20</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 1694 words, 5 min 38 sec  read</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2022/09/20/effective-modern-c-31-33/,Hexo,effective modern c ++ 31-33,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/09/20/effective-modern-c-28-30/" title="effective modern c ++ 28-30">Next</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>