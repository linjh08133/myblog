{"pages":[],"posts":[{"title":"test","text":"","link":"/2022/09/02/test/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/09/02/hello-world/"},{"title":"test1","text":"","link":"/2022/09/02/test1/"},{"title":"tvm","text":"this is a placeholder for tvm下面测试以下图片捏","link":"/2022/09/04/tvm/"},{"title":"类型萃取","text":"所谓的类型萃取，就算说在某些函数模板中，它需要知道传进来的变量，它的类型到底是啥，用于返回值这类的，但c++是不允许说推导出返回值类型的，例如以下代码是不可能通过编译的template&lt;typename T&gt; (*T) func(T t){ ... }为了解决这种问题，对于我们自定义的类，可以利用typedef去声明，如下`templatestruct MyIter{ typedef T value_type; T * ptr; MyIter(T* p):ptr(p){} T&amp; operator*() { return *ptr; } templatetypename T::value_type func(T t){ std::cout &lt;&lt; *t &lt;&lt; std::endl;}};`这样做当传入类型是MyIter的时候，首先MyIter的T会实例化为int,func这个函数模板的T会被实例化为MyIter，那么其返回类型也就是int了，这里的typename是告诉编译器，后面的T::value_type 是一个类型（像int，double这种),不加就可能会被当作是成员变量造成歧义。","link":"/2022/09/04/%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"c+2","slug":"c-2","link":"/tags/c-2/"},{"name":"tvm","slug":"tvm","link":"/tags/tvm/"}],"categories":[]}