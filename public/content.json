{"pages":[],"posts":[{"title":"test","text":"","link":"/2022/09/02/test/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/09/02/hello-world/"},{"title":"test1","text":"","link":"/2022/09/02/test1/"},{"title":"tvm","text":"this is a placeholder for tvm下面测试以下图片捏","link":"/2022/09/04/tvm/"},{"title":"类型萃取","text":"所谓的类型萃取，就算说在某些函数模板中，它需要知道传进来的变量，它的类型到底是啥，用于返回值这类的，但c++是不允许说推导出返回值类型的，例如以下代码是不可能通过编译的template&lt;typename T&gt; (*T) func(T t){ ... }为了解决这种问题，对于我们自定义的类，可以利用typedef去声明，如下 1234567891011template&lt;typename T&gt;struct MyIter{ typedef T value_type; T * ptr; MyIter(T* p):ptr(p){} T&amp; operator*() { return *ptr; }};template&lt;typename T&gt;typename T::value_type func(T t){ std::cout &lt;&lt; *t &lt;&lt; std::endl;} 这样做当传入类型是MyIter&lt;int&gt;的时候，首先MyIter的T会实例化为int,func这个函数模板的T会被实例化为MyIter，那么其返回类型也就是int了，这里的typename是告诉编译器，后面的T::value_type 是一个类型（像int，double这种),不加就可能会被当作是成员变量造成歧义。那当我们传入的是原生指针呢，上面的自定义对象我们可以直接获取它的成员变量的所指对象，但int * 这种就无法通过T::value_type,因为它根本就没有，所以这个时候就可以利用模板偏特化+trait的技巧了，如下 123456789101112131415161718192021template\\&lt;typename T\\&gt;struct MyIter{ typedef T value_type; T * ptr; MyIter(T* p):ptr(p){} T&amp; operator*() { return *ptr; }};template\\&lt;typename T\\&gt;struct iterator_traits{ typedef T::value_type value_type;};template\\&lt;typename T\\&gt;struct iterator_traits\\&lt;T*\\&gt;{ typedef T value_type;};template&lt;typename T&gt;typename iterator_traits&lt;T&gt;::value_type func(T t){ std::cout &lt;&lt; *t &lt;&lt; std::endl; 那么当func传进来的是int *的时候，会调用特例化的第2个模板，那么value_type就是int啦，这样做iterator所指类型不管是什么情况都能知道了，","link":"/2022/09/04/%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96/"},{"title":"内存模型1.md","text":"c++的内存模型挺复杂的，因为现代cpu架构的原因，例如cache等，一些操作我们无法得知他具体什么时候会对其他线程可见，例如说thread A写了一个全局变量，但它很有可能是写到自己的私有cache导致说它的这个写对其他thread不可见，那么c++对于这些就提出了一个叫内存模型的玩意。首先是顺序一致性模型，它规定有2点：1.内存访问执行的顺序与程序指定的顺序相同2.所有核心的内存访问实际执行顺序都和程序指定顺序相同有1个例子就可以说明这个，一个群聊里，每个人的发言记录的顺序是固定的，不可能说先看到晚发出去的信息，而他所看到的所有人的发言记录，与其他的每个人都一样，都是遵循着某种交叉着的顺序，而且大家观察到的顺序都是一样的，而c++默认就是使用这种内存模型，即memory_order_seq_cst,以下面这段代码为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;atomic&gt;#include &lt;thread&gt;#include &lt;assert.h&gt;#include &lt;iostream&gt;std::atomic&lt;bool&gt; x,y;std::atomic&lt;int&gt; z;void write_x(){ x.store(true,std::memory_order_seq_cst); // 1}void write_y(){ y.store(true,std::memory_order_seq_cst); // 2}void read_x_then_y(){ while(!x.load(std::memory_order_seq_cst)); if(y.load(std::memory_order_seq_cst)) // 3 ++z; //std::cout &lt;&lt; z &lt;&lt; std::endl;}void read_y_then_x(){ while(!y.load(std::memory_order_seq_cst)); if(x.load(std::memory_order_seq_cst)) // 4 ++z; //std::cout &lt;&lt; z &lt;&lt; std::endl;}int main(){ x=false; y=false; z=0; std::thread a(write_x); std::thread b(write_y); std::thread c(read_x_then_y); std::thread d(read_y_then_x); a.join(); b.join(); c.join(); d.join(); assert(z.load()!=0); // 5 std::cout &lt;&lt; z &lt;&lt; std::endl;} 这里assert永远不会报错，且下一步输出的z有可能是1，有可能是2，下面分别分析：如果第1个load是true，但第2个load是false，也就算说它观察到了x的store是先于y的store，或者说在它跳出while的时候，肯定是看到了x的store操作，但y的load还是false，说明它没观察到y的store操作，所以它观察到的所x的store先于y的store，那么对thread d而言，它也必须以这种顺序观察到2个store，所以说thread d的第1个load如果是true了，说明它观察到了y的store，所以它必然已经观察到了x的store，所以它下一步的load必然为true，反过来也同理，这个时候的z就是1了而z=2的情况为还不是很明白，假如说a的第一个load到了某个时间点，观察到了x的store，它退出了while，然后它第2个load，观察到了y是true，但这就没办法确定x和y的store的观察顺序了，如果x的store先于y，那么对d而言，它的2个load必然为ture，z=2，如果y的store是先于x的，那么thread d就可能第2个load是false了，此时z=1（这里好像就是第1种情况了？，这里的解释不一定正确） 接下来是acq-rel模型，它解除了对全局一致性的约束，只单纯地利用memory_order_acquire和memory_order_release,前者如果某个load使用则在load之前的指令都不能跨过该语句被重排到后面，后者则是某个store使用则其后语句不能被重排跨到前面我们经常利用他们去实现同步操作，但是这里要注意，它无法保证全局一致，也就是说，每个thread观测到的顺序是可能不一样的，如下例子： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;atomic&gt;#include &lt;thread&gt;#include &lt;assert.h&gt;std::atomic&lt;bool&gt; x,y;std::atomic&lt;int&gt; z;void write_x(){ x.store(true,std::memory_order_release);}void write_y(){ y.store(true,std::memory_order_release);}void read_x_then_y(){ while(!x.load(std::memory_order_acquire)); if(y.load(std::memory_order_acquire)) // 1 ++z;}void read_y_then_x(){ while(!y.load(std::memory_order_acquire)); if(x.load(std::memory_order_acquire)) // 2 ++z;}int main(){ x=false; y=false; z=0; std::thread a(write_x); std::thread b(write_y); std::thread c(read_x_then_y); std::thread d(read_y_then_x); a.join(); b.join(); c.join(); d.join(); assert(z.load()!=0); // 3} 对于不同thread的对同1个原子变量，acq-rel的语义只能做到——如果在load的时候观察到了store，那么必然就能保证我们需要的同步，如果在load的时候还没观察到store的话就做不到了，如下代码 1234567891011121314151617181920212223242526272829303132#include &lt;thread&gt;#include &lt;atomic&gt;#include &lt;cassert&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;chrono&gt;std::atomic&lt;std::string*&gt; ptr ;int data; void producer(){ std::this_thread::sleep_for(std::chrono::milliseconds(1000)); std::string* p = new std::string(&quot;Hello&quot;); data = 42; ptr.store(p, std::memory_order_release);} void consumer(){ std::string* p2 = nullptr; //std::this_thread::sleep_for(std::chrono::milliseconds(1000)); p2 = ptr.load(std::memory_order_acquire); assert(*p2 == &quot;Hello&quot;); // never fires assert(data == 42);} int main(){ std::thread t1(producer); std::thread t2(consumer); t1.join(); t2.join();} 这段代码大多数时候是报错的，因为thread 1 sleep了一段时间，所以在第2个thread中，在它load的时候，第1个thread的store因为sleep的原因未执行，导致了它无法做到同步，所以下面的assert必然报错，但如果修改p2，改成while(!p2=ptr.load(std::memory_order_acquire)),就能实现同步了，因为它会一直在while中循环，直到某1次循环中，它观察到了线程1的store操作，那么这2者的同步语义就能建立起来了——线程1的store之前的语句必然先于store，线程2的load之后的语句必然非先于load，而它跳出循环的时候store必然是已经被观测到了，所以这种同步就建立起来了回头看上一段代码，这段代码可能报错的原因就在于，acq-rel语义没有规定全局一致，那么就可能出现thread c观测到x的store先于y的store，而d则反过来，此时他们就都加不了z，或者说我们可以这么理解——全局一致下，c看到了x是true，y只load1次看到是false，说明x的store对d来说也必然先于y的store，而d一直卡在while那里，直到它观测到y是true；但没有全局一致的要求时，以下情况就可能发生——对thread c，它卡在while一段时间退去后，此时它肯定观测到了x的sotre，而它只对y进行了1次load，是false，说明它观测到x的store先于y，但对d而言，没有全局一致的约束，c的观测顺序对它没意义了，它完全可以一直卡在while，直到它观测到y的store，然后在对x进行1次load，发现x的store还没被观察到，对d而言，它是先观测到y后才是x，那么这种矛盾的原因在于，x和y的store它可能是写入内存，而c和d在load的时候，不一定去内存找，它可能直接在自己的cache中找，不一致就来了那么怎么修改这段代码呢，很简单，只要保证x和y他们的被观测到的顺序是一样的就可以了，上述由于是分开被2个线程写的原因如下 123456789101112131415161718192021222324252627#include &lt;atomic&gt;#include &lt;thread&gt;#include &lt;assert.h&gt;std::atomic&lt;bool&gt; x,y;std::atomic&lt;int&gt; z;void write_x_then_y(){ x.store(true,std::memory_order_relaxed); // 1 y.store(true,std::memory_order_release); // 2}void read_y_then_x(){ while(!y.load(std::memory_order_acquire)); // 3 自旋，等待y被设置为true if(x.load(std::memory_order_relaxed)) // 4 ++z;}int main(){ x=false; y=false; z=0; std::thread a(write_x_then_y); std::thread b(read_y_then_x); a.join(); b.join(); assert(z.load()!=0); // 5} 这里就不用解释了，但如果说y的load不是while，而是只读1次，那这种同步性就没有了，因为它完全有可能在load之前没有观察到store，加上while，不断的load，直到某1次，发现y被store为true了，这次的load就和store有了先后顺序了，那么就可以保证同步了","link":"/2022/09/05/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B1/"},{"title":"模板偏特化","text":"","link":"/2022/09/04/%E6%A8%A1%E6%9D%BF%E5%81%8F%E7%89%B9%E5%8C%96-1/"},{"title":"模板偏特化","text":"模板偏特化，就","link":"/2022/09/04/%E6%A8%A1%E6%9D%BF%E5%81%8F%E7%89%B9%E5%8C%96/"},{"title":"shared_ptr线程安全","text":"shared_ptr众所周知的智能指针，其允许多个指针指向同一内存对象，且在引用计数为0的时候自动析构被管理的对象，但是，在多线程的环境下，他的操作不是线程安全的，原因在于，其管理对象的方式是通过指针去管理，而其底层的引用计数本身也是一个指针，指向一个真正的计数对象，当我们执行如下代码的时候 12shared_ptr&lt;A&gt; a1 (new A));shared_ptr&lt;A&gt; a2 = a1; a2在构造的时候，是分为2步的，第1步是让a2管理的A对象指向a1管理的对象，第2步是让a2的引用计数也指向a1的引用计数对象，然后再把count+1那么这种非原子的操作方式就可能带来race condition了，如下代码 1234567891011121314151617181920212223#include &lt;memory&gt;#include &lt;iostream&gt;#include &lt;thread&gt;std::shared_ptr&lt;int&gt; p1 (new int(5));void func1(){ std::shared_ptr&lt;int&gt; p2; p2 = p1; std::cout &lt;&lt; *p2 &lt;&lt; std::endl;}void func2(){ std::shared_ptr&lt;int&gt; p3; p1 = p3;}int main(){ std::thread t1(func1); std::thread t2(func2); t1.join(); t2.join();} 当线程1执行p2 = p1的时候，首先他会把p1管理对象的指针赋值给p2，但这个时候，线程2来了，他的p1 = p3的赋值操作，导致p1原来管理的int(5)变成了1个没人指向的对象，所以其对应的引用计数也为0，且这个原来的对象就被析构了，此时p1所指的引用计数对象，他的count是2，再下一步，来到线程1，p2 = p1指令继续赋值，把p1的新的引用计数对象赋给了p2，那么这个引用计数对象的count就是3了，但此时p2所指的是那个已经被析构了的int(5),这个时候我们再解引用p2，就会报错了，如图：中间的那个偶尔的段错误吐核就是啦所以这里要记住：shared_ptr的实现机制，最核心的就是使用2个指针，指向1个被管理对象和1个与之关联的引用计数对象，在赋值的时候是分2步的非原子操作，所以这个时候一定要加锁使其原子化","link":"/2022/09/05/shared-ptr%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"title":"局部静态对象","text":"c++11规定，在一个函数内的局部静态变量(local static),它的初始化是必须线程安全的，也就是说，它的初始化过程是加锁的，其他线程在其初始化过程中是被阻塞的，否则就可能说1个线程在初始化过程中在还没赋值之前，另1个线程也开始初始化，最后就造成了重复构造，具体如下代码 123456789101112131415161718192021222324252627282930#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;mutex&gt;class A {public:A(){ std::cout &lt;&lt; &quot;constructing&quot; &lt;&lt; std::endl; }};A&amp; getA(){ static A a; return a;}std::mutex lock;void func(){ A a = getA(); std::unique_lock&lt;std::mutex&gt; mylock (lock); std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;}int main(){ std::thread thread_list[10]; for (int i = 0; i &lt; 10; i++){ thread_list[i] = std::thread(func); } for (int i = 0; i &lt; 10; i++){ thread_list[i].join(); }} 可以看到，这个对象只被正确地构造了1次，其他线程都引用同一个对象这种方式是c++实现单例模式的最佳手段，因为它就是这么简单","link":"/2022/09/05/%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1/"},{"title":"一个可扩展哈希代码阅读","text":"可扩展哈希一般是用在数据库中管理1条1条的record的，虽然现在很多都是用B+树了这个主要是做15-445的project时接触到的，project2需要实现1个可扩展哈希静态的哈希随着记录的增多，其冲突的概率也越来越大，此时如果能动态扩容就能优化性能了可扩展哈希的主要成员就2个，一个是bucket，它内部存放的就是1条1条的记录，一般初始化的时候就指定他的可存放记录的数目，多个bucket就构成了整个hash表第2个是directory，他是1个可以扩展的数组，每个成员都是指针，指向对应的bucket，其对应的bucket就是通过哈希函数算出对应的下标，且可能会有多个成员指向同个bucket的情况，这个后面再说还有的就是2个重要的概念：global depth和local depth，前者是directory的成员，它指明了每个bucket最大的local depth，也限制了其管理的bucket指针数组的大小，例如说global depth是5的时候，他的bucket数组最多就有32个，而local depth是每个bucket的成员，他指明了找到该bucket需要的位数，例如说 这里我分析的是https://github.com/nitish6174/extendible-hashing/blob/master/main.cpp里面的代码，内容还是比较好懂的接下来首先是他的bucket部分，这个比较简单，就是一些常规的增删查改操作， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116Bucket::Bucket(int depth, int size){ this-&gt;depth = depth; this-&gt;size = size;}int Bucket::insert(int key, string value){ std::map&lt;int,string&gt;::iterator it; it = values.find(key); if(it!=values.end()) return -1; if(isFull()) return 0; values[key] = value; return 1;}int Bucket::remove(int key){ std::map&lt;int,string&gt;::iterator it; it = values.find(key); if(it!=values.end()) { values.erase(it); return 1; } else { cout&lt;&lt;&quot;Cannot remove : This key does not exists&quot;&lt;&lt;endl; return 0; }}int Bucket::update(int key, string value){ std::map&lt;int,string&gt;::iterator it; it = values.find(key); if(it!=values.end()) { values[key] = value; cout&lt;&lt;&quot;Value updated&quot;&lt;&lt;endl; return 1; } else { cout&lt;&lt;&quot;Cannot update : This key does not exists&quot;&lt;&lt;endl; return 0; }}void Bucket::search(int key){ std::map&lt;int,string&gt;::iterator it; it = values.find(key); if(it!=values.end()) { cout&lt;&lt;&quot;Value = &quot;&lt;&lt;it-&gt;second&lt;&lt;endl; } else { cout&lt;&lt;&quot;This key does not exists&quot;&lt;&lt;endl; }}int Bucket::isFull(void){ if(values.size()==size) return 1; else return 0;}int Bucket::isEmpty(void){ if(values.size()==0) return 1; else return 0;}int Bucket::getDepth(void){ return depth;}int Bucket::increaseDepth(void){ depth++; return depth;}int Bucket::decreaseDepth(void){ depth--; return depth;}std::map&lt;int, string&gt; Bucket::copy(void){ std::map&lt;int, string&gt; temp(values.begin(),values.end()); return temp;}void Bucket::clear(void){ values.clear();}void Bucket::display(){ std::map&lt;int,string&gt;::iterator it; for(it=values.begin();it!=values.end();it++) cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;} 接下来就是directory的内容，首先是他的构造函数 123456789Directory::Directory(int depth, int bucket_size){ this-&gt;global_depth = depth; this-&gt;bucket_size = bucket_size; for(int i = 0 ; i &lt; 1&lt;&lt;depth ; i++ ) { buckets.push_back(new Bucket(depth,bucket_size)); }} 可以看到，他一开始的local depth和global depth是一样的，其哈希函数如下： 1234int Directory::hash(int n){ return n&amp;((1&lt;&lt;global_depth)-1);} 很直白的，就是取n的二进制位的最后global depth位做为哈希值，例如说当global depth为3时，上面就是n&amp;7（111）了下面是一个取pair的函数 1234int Directory::pairIndex(int bucket_no, int depth){ return bucket_no^(1&lt;&lt;(depth-1));} 这个是在桶进行split的时候调用的，这里在被调用时被分裂的桶的bucket_no+1才等于参数depth，例如说bucket_no是6（110）的时候，depth是4，那么做取异操作后，返回的是14（1110），和原来的6（0110）相比，就是在增加的哈希位上不同了，这里具体为啥这么做见后面的grow就知道了 123456void Directory::grow(void){ for(int i = 0 ; i &lt; 1&lt;&lt;global_depth ; i++ ) buckets.push_back(buckets[i]); global_depth++;} grow函数是在bucket分裂时发现他分裂后的local depth比global depth还大时调用的，调用后bucket数组翻倍，而且他翻倍后多出来的数组元素，比如说原来是n个，现在2n个，第n+1个和第1个指向同1个bucket，因为push_back会生成原来指针的副本，他也指向原来的指针所指对象，所以grow的过程并没有真正的创建bucket对象，只是多出了一些类似占位符的东西。而且看到这里上面的pairindex函数就明白了，pair指的就是这里的指针11对应的关系，bucket数组的第6个和第14个都指向同1个bucket对象，我们取得他的下标，给他赋予真正的新的bucket对象（见下面的split) 12345678910111213141516171819202122void Directory::split(int bucket_no){ int local_depth,pair_index,index_diff,dir_size,i; map&lt;int, string&gt; temp; map&lt;int, string&gt;::iterator it; local_depth = buckets[bucket_no]-&gt;increaseDepth(); if(local_depth&gt;global_depth) grow(); pair_index = pairIndex(bucket_no,local_depth); buckets[pair_index] = new Bucket(local_depth,bucket_size); temp = buckets[bucket_no]-&gt;copy(); buckets[bucket_no]-&gt;clear(); index_diff = 1&lt;&lt;local_depth; dir_size = 1&lt;&lt;global_depth; for( i=pair_index-index_diff ; i&gt;=0 ; i-=index_diff ) buckets[i] = buckets[pair_index]; for( i=pair_index+index_diff ; i&lt;dir_size ; i+=index_diff ) buckets[i] = buckets[pair_index]; for(it=temp.begin();it!=temp.end();it++) insert((*it).first,(*it).second,1);} 首先是调用要分裂的那个bucket的increasedepth函数，他的local depth+1了，如果需要扩容调用grow函数，接着是找到指向同1个bucket的bucket_no(pairindex函数)，然后在他上面真正的创建1个新的bucket，然后把需要分裂的那个桶的内容赋值给temp变量并清空，准备后面的分配，而接下来的操作则是bucket数组里的某几个指向新建立的bucket，这里我们具体以一个例子说明假设一开始global depth和local depth都是3，后来有某个桶7（111）他要split，发现global depth不够，于是需要grow，然后就走上述流程，接着算出index_diff和dir_size都是16，pair_index是15（1111），那么很明显2个for循环都不满足条件不执行，因为除了7和15外就没有哪个bucket_no指向相关的桶了，但假如后来桶7（0111，这个时候是4层了）又不够了，又要扩容了，global depth就变成5了，一切如上照旧；后来桶7又不够用。又分裂了，global depth变为6了，不过这个时候和原来8个桶相比，只多了3个桶而已到了后面，终于是1个local depth是3的桶要分裂了，假设他是6（110），他发现global depth够用，就不用grow了，他的pair_index是14（1110），index_diff是16，dir_size是64，第1个for没走，但第2个，他会遍历30（011110），46（101110），62（111110），这3个桶都指向新分裂出来的桶，原本他们指向的和6一样的桶，至于为啥这么做，我的想法是，当global depth比local depth多到1定程度时，指向同1个桶的哈希下标是有很多的，这个时候就需要新生成的桶来分担一些，例如上面的6，在没分裂前，后3位是110的桶的下标都指向了6,的桶，分裂后，后四位是0110的依旧，但1110的则被分配去新的桶了，假如不这么做的话，到后面可能就出现某些桶需要频繁地分裂的结果接下来就是insert函数，其实现如下 123456789101112131415161718192021void Directory::insert(int key,string value,bool reinserted){ int bucket_no = hash(key); int status = buckets[bucket_no]-&gt;insert(key,value); if(status==1) { if(!reinserted) cout&lt;&lt;&quot;Inserted key &quot;&lt;&lt;key&lt;&lt;&quot; in bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl; else cout&lt;&lt;&quot;Moved key &quot;&lt;&lt;key&lt;&lt;&quot; to bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl; } else if(status==0) { split(bucket_no); insert(key,value,reinserted); } else { cout&lt;&lt;&quot;Key &quot;&lt;&lt;key&lt;&lt;&quot; already exists in bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl; }} 首先是计算哈希值，例如说上面的例子继续下去，此时的global depth是6，这里根据上面的例子，对于后4位是1110的，他们会指向同1个桶，而后4位是0110的，他们会指向另外1个桶，可万一他原本就要溢出的桶里面，每条记录的后4位都是0110呢，这个时候他们就都走到同1个桶了，就又溢出了，这个时候上面代码就根据insert的返回值判断是否溢出，溢出了，则要对bucket_no这个桶再一次split，例如说我们假设的6（0110，现在是4位local depth），6的pair index这个时候是22了（10110），split也顺带把54指向了新生成的桶（110110，接下来就是根据5位二进制去判断了，因为我们原本假设他们后4位都是0110，现在就进一步地根据第5位是0还是1去判断走哪个桶了，如果还溢出，就继续分裂，知道没有溢出为止。总结目前上述内容，就是一种平衡吧，当global depth是6的时候，在6（110）这个下标的桶还没分裂前，有8个哈希下标会指向他，分裂的同时也应该能使得new出来的桶分担一些那接下来有分必有合，shrink操作函数如下 123456789101112131415void Directory::shrink(void){ int i,flag=1; for( i=0 ; i&lt;buckets.size() ; i++ ) { if(buckets[i]-&gt;getDepth()==global_depth) { flag=0; return; } } global_depth--; for(i = 0 ; i &lt; 1&lt;&lt;global_depth ; i++ ) buckets.pop_back();} 如果有1个桶的local depth和global depth一样，就无法缩小了，原因可以看到后面他缩小的操作，实际上就是把后半部分的bucket给去掉了，而能没有后果的去掉的前提是，这些bucket指向的对象完全和前半部分的一样，但假如其中某个桶的local depth和global depth一样，说明是经过了split中的new Bucket(local_depth,bucket_size)操作，导致这后半部分有某个桶他指向了新的对象，也就无法删除了，下面是merge函数 1234567891011121314151617181920void Directory::merge(int bucket_no){ int local_depth,pair_index,index_diff,dir_size,i; local_depth = buckets[bucket_no]-&gt;getDepth(); pair_index = pairIndex(bucket_no,local_depth); index_diff = 1&lt;&lt;local_depth; dir_size = 1&lt;&lt;global_depth; if( buckets[pair_index]-&gt;getDepth() == local_depth ) { buckets[pair_index]-&gt;decreaseDepth(); delete(buckets[bucket_no]); buckets[bucket_no] = buckets[pair_index]; for( i=bucket_no-index_diff ; i&gt;=0 ; i-=index_diff ) buckets[i] = buckets[pair_index]; for( i=bucket_no+index_diff ; i&lt;dir_size ; i+=index_diff ) buckets[i] = buckets[pair_index]; }} 这里就是split反过来，例如说上面的例子，我想merge22，他的pair index是6，且他们的local depth都是5，这个时候就可以走if里面的流程，把这个local depth减1，然后删去22这个桶，且让6所指的桶的指针给了22，然后就是把那些原来指向22的桶现在指向6，就是和上面split一样的思路下面是remove函数 123456789101112131415void Directory::remove(int key,int mode){ int bucket_no = hash(key); if(buckets[bucket_no]-&gt;remove(key)) cout&lt;&lt;&quot;Deleted key &quot;&lt;&lt;key&lt;&lt;&quot; from bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl; if(mode&gt;0) { if(buckets[bucket_no]-&gt;isEmpty() &amp;&amp; buckets[bucket_no]-&gt;getDepth()&gt;1) merge(bucket_no); } if(mode&gt;1) { shrink(); }} mode是用户输入的，根据他来判断是要merge（删去某个桶）还是直接对半砍去剩下的几个没列出来的也只是很简单的操作，这个代码也就分析完咯，下面就开始做project2捏","link":"/2022/09/07/%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%89%A9%E5%B1%95%E5%93%88%E5%B8%8C%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"},{"title":"引用折叠","text":"所谓的万能引用主要是用在以下2种场合：第1种是模板如下： 12template&lt;typename T&gt;void func(T&amp;&amp; t){...} 以上代码中的&amp;&amp;并不是右值引用的意思，他是表示说这个t肯定是一个引用类型，但具体是左值引用还是右值引用我们得根据传进来的参数确定那如何根据传进来的参数确定呢，这里就用到了引用折叠了，具体而言，当T被推导出来是右值时，T&amp;&amp;是一个右值引用（&amp;&amp; &amp;&amp; 折叠为了&amp;&amp;），而其他情况都是折叠为&amp;，即左值引用为了验证，我们可以用完美转发来验证一下 12345678910111213141516171819202122#include &lt;iostream&gt;void print(int&amp; t){ std::cout &lt;&lt; &quot;left&quot; &lt;&lt; std::endl;}void print(int&amp;&amp; t){ std::cout &lt;&lt; &quot;right&quot; &lt;&lt; std::endl;}template&lt;typename T&gt;void func(T&amp;&amp; t){ print(std::forward&lt;T&gt;(t));}int main(){ int x = 10; func(x); func(12); func(std::move(x)); int&amp; y = x; func(y);} 以上代码第1个显示是left，x是一个左值为什么被推导为左值引用呢，因为在func的参数里，传进来的T&amp;&amp;必须被解释为1个引用，那T就可以是int，int&amp;，int&amp;&amp;，只有int&amp;能被推断为左值(int&amp; &amp;&amp;折叠为&amp;)，第2个则是right，T是实例化为int，第3个为right，T为int&amp;&amp;，第4个T为int&amp;，折叠为&amp;，所以结果是left 第2种使用万能引用的场合是在auto推断中，如 12auto&amp;&amp; i = 3； //auto推断为int，i为int&amp;&amp;类型，即右值引用auto&amp;&amp; j = i; // auto推断为int&amp;，i为int&amp;，即左值引用","link":"/2022/09/07/%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0/"},{"title":"函数返回类型后置","text":"返回类型后置，主要的用处在于某些函数他返回的类型可能很复杂，例如返回一个函数指针等，如下 12typedef void(* ret)(int,double);ret myfunc(){...} 为了更加简洁，我们可以这么写 123auto myfunc() -&gt; void(*)(int,double){ ...} 其中的auto只是个占位符，真正的返回类型在后面，感觉和Python的写法很像捏 除此之外，我们还可以用decltype来推导函数的返回类型，如下： 1234template&lt;typename T1, typename T2&gt;auto func(T1 t1, T2 t2)-&gt;decltype(t1 + t2){ return t1 + t2;} 那么生成的模板函数就会根据t1+t2的实际类型决定返回类型了c++也允许decltype放在函数名之前表示返回类型如下： 1234template&lt;typename T1, typename T2&gt;decltype(T1() + T2()) func(T1 t1, T2 t2){ return t1 + t2;} 这么写虽然说也可以，但实际不这么建议使用，1是他需要要求T1和T2有无参构造函数，2是不够简洁","link":"/2022/09/07/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE/"},{"title":"4种c++风格的类型转换","text":"reinterpret_cast(value),他可以把一个指针转化为另外1种指针，也可以把1个整型值赋给一个指针，其最本质在于不修改value的底层二进制位，只是修改了去解释他的方法，比如说同一个二进制数，我用整数补码（int）和float类型那个ieee标准去解释结果肯定不同 123456789#include &lt;iostream&gt;int main(){int a = 0;int* p = &amp;a;char* p2 = reinterpret_cast&lt;char *&gt;(p);*p2 = '1';std::cout &lt;&lt; a &lt;&lt; std::endl;} 上面代码的输出结果为49，正好是a的asci值，首先他会把p这个int指针强制转换为char类型的指针，而且他指向了a的最低位（在我们机器上是小端存储的的），我们解引用赋值，其实就是在a的最低位字节上赋值了整数49，当用char的方式去解读时读出来的就是’a’,int则是49了，还有另外一种使用方式就是把一个整数赋值给一个指针，然后这个指针就指向这个地址了， 123int* p;int address = 0x12345678;p = reinterpret_cast&lt;int*&gt;(address); 当然这种得是你能访问这个地址才行 而这种强制转换在leveldb中的fixedint编码中就使用了，如下： 1234567inline void EncodeFixed32(char* dst, uint32_t value) { uint8_t* const buffer = reinterpret_cast&lt;uint8_t*&gt;(dst); buffer[0] = static_cast&lt;uint8_t&gt;(value); buffer[1] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 8); buffer[2] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 16); buffer[3] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 24);} 首先他把dst这个指针重新解释为1个指向uint8_t类型的指针然后赋值给buffer，现在buffer和dst指向同一个内存地址了，只不过他们解释这个地址里的东西的方式不同了，然后就是依次把value的每个字节的值写入buffer，也就是dst中，decode的则是反过来 123456789inline uint32_t DecodeFixed32(const char* ptr) { const uint8_t* const buffer = reinterpret_cast&lt;const uint8_t*&gt;(ptr); // Recent clang and gcc optimize this to a single mov / ldr instruction. return (static_cast&lt;uint32_t&gt;(buffer[0])) | (static_cast&lt;uint32_t&gt;(buffer[1]) &lt;&lt; 8) | (static_cast&lt;uint32_t&gt;(buffer[2]) &lt;&lt; 16) | (static_cast&lt;uint32_t&gt;(buffer[3]) &lt;&lt; 24);} 然后就是static_cast,基本等价于隐式转换，可以用在空指针转化为任意指针，可以用在整形和浮点数之间，对于继承的机制来说，可以把子类转化为父类，父类则不能反过来变为子类的， const_cast const_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。它的使用场景我目前了解的具体是在与const string这种相关的函数签名上，具体而言，大家都知道只有const string &amp;才能引用一个右值（在不想写右值引用的情况下），而为了能让函数能接受(“ww”,”ee”)这种参数，我们就不得不把函数的参数声明为const string&amp;，那这个时候他就很有可能也返回一个const string &amp;，但往往我们并不需要这种const的限制，所以我们就可以写个没有cosnt约束的函数，在其内部使用const_cast添加或移去他的常量性，如下： 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const string &amp; shorter(const string &amp; s1, const string &amp; s2){ cout &lt;&lt;&quot; this is const&quot; &lt;&lt; endl; return s1;}string &amp; shorter(string &amp; s1, string &amp; s2){ cout &lt;&lt;&quot;this is non const&quot; &lt;&lt; endl; auto &amp;res = shorter(const_cast&lt;const string &amp;&gt;(s1), const_cast&lt;const string &amp;&gt;(s2)); return const_cast&lt;string &amp;&gt;(res);}int main(){ string s1(&quot;ww&quot;); string s2(&quot;Ee&quot;); shorter(s1,s2); shorter(&quot;ww&quot;,&quot;ee&quot;);} 这样子不管进来的是什么样的内容，就都能处理了， dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。 dynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。","link":"/2022/09/09/4%E7%A7%8Dc-%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"title":"CRTP与静态多态","text":"CuriouslyRecurringTemplatePattern，简称CRTP，是一种实现静态多态的机制，简单而言，他的核心在于：父类是一个模板类，派生类会继承父类，且以派生类自身作为父类的模板参数，如下： 123456789101112131415161718192021222324252627template&lt;typename T&gt;class Base{public: void print(){ static_cast&lt;T*&gt;(*this)-&gt;imp(); } void imp(){ std::cout &lt;&lt; &quot;this is base&quot; &lt;&lt; std::endl; }};class Son1: public Base&lt;Son1&gt;{ void imp(){ std::cout &lt;&lt; &quot;this is son 1&quot; &lt;&lt; std::endl; }};class Son2: public Base&lt;Son2&gt;{ void imp(){ std::cout &lt;&lt; &quot;this is son 2&quot; &lt;&lt; std::endl; }};template&lt;typename T&gt;void func(T &amp; t){ t.print();} 当我传入func的对象是Son1时， Base实例化为Son1，print中的static_cast就会把this指针强制转换为Son1*，也就能调用Son1自己实现的函数了，不过这里严格意义上来说并不算是多态，因为每个派生类继承的是各自实例化后的模板类，使用static_cast就能把从基类去访问派生类的成员函数了似乎llvm的visitor模式采用的就是这种捏，tvm中的貌似也有涉及这种设计，后续再看","link":"/2022/09/09/CRTP%E4%B8%8E%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/"},{"title":"leveldb源码系列1-skiplist","text":"本文分析的是leveldb中的跳表skip list的实现，他会把user key和user value打包成一个更大的key塞入list中跳表的一个例子如下图 可以看到，每一个node，它都有不同的高度，且每个节点都在第0层都有出现，第0层就像最简单的链表一样，而到了上面的层数节点的个数越来越少，就像树状结构那种，跳表的许多操作都能在logn的复杂度下完成，leveldb的主要结构包括skiplist，内部是由一系列的node构成的，他还实现了一个iterator用于遍历接下来首先看node的实现 1234567891011121314151617181920212223242526272829303132333435363738template &lt;typename Key, class Comparator&gt;struct SkipList&lt;Key, Comparator&gt;::Node { explicit Node(const Key&amp; k) : key(k) {} Key const key; // Accessors/mutators for links. Wrapped in methods so we can // add the appropriate barriers as necessary. Node* Next(int n) { assert(n &gt;= 0); // Use an 'acquire load' so that we observe a fully initialized // version of the returned Node. return next_[n].load(std::memory_order_acquire); } void SetNext(int n, Node* x) { assert(n &gt;= 0); // Use a 'release store' so that anybody who reads through this // pointer observes a fully initialized version of the inserted node. next_[n].store(x, std::memory_order_release); } // No-barrier variants that can be safely used in a few locations. Node* NoBarrier_Next(int n) { assert(n &gt;= 0); return next_[n].load(std::memory_order_relaxed); } void NoBarrier_SetNext(int n, Node* x) { assert(n &gt;= 0); next_[n].store(x, std::memory_order_relaxed); } private: // Array of length equal to the node height. next_[0] is lowest level link. // 1) 这里提前声明并申请了一个内存，用于存储第 0 层的数据，因为第 0 层必然存在数据。 // 2) 这里的数组长度其实就是层高，假设 next_ 长度为 n，那么就会从 next_[n-1] 开始查找。 // 3) 因为 skip list 的 level 并不会太大，使用数组存储 Node 指针的话对 CPU 内存更友好 // https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf std::atomic&lt;Node*&gt; next_[1];}; 第一部分主要是1个显式的构造函数，指定某个键并初始化key这个成员数据，然后是他的next_数组，这个数组主要是用来存放该结点的每一层的next结点的指针的，指定为1是因为必然要在第0层有该结点，接下来是他的2个无锁操作和2个不用内存屏障的操作，next这个无锁操作使用了next_这个原子对象的load函数，且指定了memory_order_acquire,那么在这个语句之前的都不会被重排到他后面了，而setnext则是store函数，指定了memory_order_release，则该语句后面的内容都不会重排到他前面去，后面的2个则是使用了memory_order_relaxed,他只保证这条语句他是原子的，语句前后怎么重排都没有限制接下来是一个生成新结点的函数 123456789template &lt;typename Key, class Comparator&gt;typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::NewNode( const Key&amp; key, int height) { // 内存分配时只需要再分配 level - 1 层，因为第 0 层已经预先分配完毕了。 char* const node_memory = arena_-&gt;AllocateAligned( sizeof(Node) + sizeof(std::atomic&lt;Node*&gt;) * (height - 1)); // 这里是 placement new 的写法，在现有的内存上进行 new object return new (node_memory) Node(key);} 第2行开头的typename是为了告诉编译器，后面这个::Node是一个类型，那么整个函数的返回值就是NOde*了，首先分配内存，然后在这个内存上placement new，调用node的构造函数了 接下来是skiplist的成员函数第一个是生成随机层数的函数 123456789101112template &lt;typename Key, class Comparator&gt;int SkipList&lt;Key, Comparator&gt;::RandomHeight() { // Increase height with probability 1 in kBranching static const unsigned int kBranching = 4; int height = 1; while (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == 0)) { height++; } assert(height &gt; 0); assert(height &lt;= kMaxHeight); return height;} 首先初始化height为1，接着以1/4的概率使得while成立（在height比kmaxheight小的情况下），这样子第1层的node个数就大致是第0的1/4了，后面的层数以此类推，而用1/4这个概率貌似也是提出跳表的论文中建议的？接下来是一个key的大小顺序的函数 12345template &lt;typename Key, class Comparator&gt;bool SkipList&lt;Key, Comparator&gt;::KeyIsAfterNode(const Key&amp; key, Node* n) const { // null n is considered infinite return (n != nullptr) &amp;&amp; (compare_(n-&gt;key, key) &lt; 0);} 当要比较的对象（比如说是next节点指向的某一层对象）不为空且compare比较器得到的结果小于0时，说明这个key在顺序上是在n后面的， 接下来就是查找在每一层上 12345678910111213141516171819202122232425template &lt;typename Key, class Comparator&gt;typename SkipList&lt;Key, Comparator&gt;::Node*SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(const Key&amp; key, Node** prev) const { Node* x = head_; int level = GetMaxHeight() - 1; while (true) { /* 获取当前 level 层的下一个节点 */ Node* next = x-&gt;Next(level); if (KeyIsAfterNode(key, next)) { // Keep searching in this list x = next; } else { // prev 数组主要记录的就是每一层的 prev 节点，主要用于插入和删除时使用 if (prev != nullptr) prev[level] = x; if (level == 0) { return next; } else { // Switch to next list level--; } } }} 其中的GetMaxHeight函数获取的是当前结点的层数，我们从这个节点的最高层开始找，不断获取他的next节点，判断这个node他","link":"/2022/09/09/leveldb%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%971-skiplist/"},{"title":"tvm系列1——te代码阅读","text":"这篇是想探索一下tvm的te的compute和schedule具体的实现代码， 1234n = te.var(&quot;n&quot;)A = te.placeholder((n,), name=&quot;A&quot;)B = te.placeholder((n,), name=&quot;B&quot;)C = te.compute(A.shape, lambda i: A[i] + B[i], name=&quot;C&quot;) 上面这段假如熟悉tvm的应该再熟悉不过了，首先第1句话，返回的是tvm.tir.Var的数据类型的变量，这个是tir上的数据结构，后面再解析下面的A和B的placeholder如下 1234def placeholder(shape, dtype=None, name=&quot;placeholder&quot;): shape = (shape,) if isinstance(shape, tvm.tir.PrimExpr) else shape dtype = &quot;float32&quot; if dtype is None else dtype return _ffi_api.Placeholder(shape, dtype, name) 这个tvm.tir.PrimExpr是tir大多数类的父类，然后就会调用ffi机制去使用c++写的代码，这里也没啥可以说的，返回的就是 到了compute，这里源码的一开始一大段都是处理参数变量名称的，不用理会，这里他会if else到最后，直接把argspec.args当做arg——names，这里他是使用inspect的getfullargspec去获取一个lambda表达式的所有信息的到下面dim_var = [tvm.tir.IterVar((0, s), x, 0) for x, s in zip(arg_names, shape[:out_ndim])] body = fcompute(*[v.var for v in dim_var]) out_ndim是第1个参数的维度，这里是1，然后s是只有1个，就是n，会用他们去构造IterVar，第1个参数是这个iter的范围，第2个是这个iter的标识，第3个是这个iter的类型，源码中写着他是datapar，应该是一般的那种iter这里构造出来的dim_var打印如下： 12~~~接下来的body部分的var其实就是上面的第2个参数，fcompute就是C中的lambda表达式，首先把var的列表给解包，在调用fcompute这个可调用对象，就是上面C的lambda表达式，这里我们再写1个看看 n = te.var(“n”)A = te.placeholder((n,n), name=”A”)B = te.placeholder((n,n), name=”B”)C = te.compute(A.shape, lambda i,j: A[i,j] + B[i,j], name=”C”) 这里返回的body的类型是tvm.tir.expr.Add,主要是因为A和B都是tvm.te.Tensor,他们继承自ExprOp类，而这个类又写了一堆魔法方法，重载了一系列的运算符，比如说这里的+运算符，写了__add__函数后，最终调用这个函数 假如说在compute中，有te.sum这种reduce操作的，还会识别出其中达到reduce_axis,","link":"/2022/09/08/tvm%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94te%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"},{"title":"effective modern c ++ 1-3","text":"条款1是对模板参数推导的几个细则，具体以下代码 12template &lt;typename T&gt;void func(ParamType param){} 使用func(expr)去调用时，它会推导T和param的形别，这2种有的时候是一样的，有的时候由于常量这些标识而不同，例如 12template &lt;typename T&gt;void func(const T&amp; param){} 在使用一个int 变量i去调用func时，T是iNT,而PARAMTYPE是const int&amp;具体则分三种情况去讨论第1种是paramtype是一个非万能引用，此时的判断方法是：如果expr具有引用，把引用给忽略，然后再去推导，如下 123456template &lt;typename T&gt;void func(T&amp; param){}int x = 2;const int cx = x;const int&amp; rx = x; 那么在调用func的时候，对x，T是int，paramtype是int&amp;，而后面2个T是const int，而paramtype是const int&amp;，因为第3个expr的引用是会被忽略的，这里也可以看出，持有T&amp;的模板，它能保证传进来的对量的常量性能被捕获第2种是paramtype是一个万能引用，如 12template&lt;typename T&gt;void func(T&amp;&amp; param){} 这个时候就使用引用折叠，可知如果传进来的expr是左值，T和paramtype都会推导为左值引用，如果expr是右值，则根据1的规矩即可 第3种情况就是paramtype不是引用，那么就是说函数是按值传参的，他复制了一个新的对象，此时他对expr，会忽视他的const，volatile和引用，所以对上面的，x，cx，rx，如果模板声明如下 12template&lt;typename T&gt;void func(T param) 那么T和paramtype最终都是int，这个也是可以理解的——本身传进来后我是构建的新的对象，不会对外面的一切造成干扰这里还有1种特殊情况，即指向常量的常量指针，const int * const ptr,那么传进来之后，右边的const会被忽略，因为传进来的本质是1个地址，这个值就像前面那个const int一样，所以他就被忽略了，那么进来后，T会被推导为const int，指向常量的指针最后就是关于数组的问题了，这里直接结论如下：当paramtype是T param时，数组形参会退化为1个指针例如templatevoid func(T param)const char name[] = “22”;此时把name传进来时，T会推导为const char*但假如paramtype是个引用，T则会推导为const char[3],而paramtype则是cost char（&amp;）[13]我们可以用这一特性去推导数组长度 12345678template&lt;typename T, int N&gt;constexpr int getlen(T(&amp;)[N]) noexcept{ return N;}int main(){ int x[2] = {2,3}; char y[getlen(x)];} 条款2是auto推导的规则，他的规则上和模板推导的基本一致，但有一点很特别，在使用c++11引入的初始化方式中，如下 12auto x{3};auto x={3}; 此时auto推导型别会推导出std:: initializer_list，且其中只有1个元素的变量，所以如下代码编译是会失败的 1auto y{2,3,3.0}; 因为对std:: initializer_list的T推导不出是什么这里的本质是有2次推导，第1个是推导出y的型别为std:: initializer_list（因为使用了大括号去初始化），第2次是推导std:: initializer_list的T的类型，而如果我们想利用模板去实现这一点是做不到的，因为auto他本身对大括号初始化就假定了第1次推导必定是std:: initializer_list，而模板没办法，所以如果真要用模板，可以这么实现 12template&lt;typename T&gt;void func(std:: initializer_list&lt;T&gt; list); 对于func({2,3,3})的调用，上面模板就起效了最后还补充了1点，在c++14的标准中，可以单独用auto去说明函数返回值/lambda表达式的形参需要推导，但此时他是使用模板推导去推导的，所以说返回值不能使用大括号 条款3是decltype的使用一般的，对于大多数std的容器，其[]的使用会返回对应位置的元素的引用，除了vector以外，而在c++14中，正如在条款2中提到的，我们可以只使用auto不加decltype去推导返回值类型，此时使用的是模板类型的推导，那以下代码就有问题了 12345678template&lt;typename container, typename index&gt;auto getindex(container &amp; c,index i){ return c[i];}... std::vector&lt;int&gt; vec {3,4,4}; getindex(vec,2) = 10; ... 上面的代码执行如下：首先这里采用的是模板推导，且auto没有&amp;或者&amp;&amp;的修饰，即采用条款1种的第3种规则，此时型参的一切引用都会被忽略，即c[i]返回的int&amp;被看成是int，那么T和paramtype就是int了，此时返回的是1个临时值，是个右值，不能放在等号左侧，所以很明显他会报错 12error: lvalue required as left operand of assignment getindex(vec,2) = 10; 解决方法是把auto改成decltype（auto），告诉他说推导过程用的是decltype的规则，而他对于int&amp;就是推导为int&amp;，或者我们直接使用后置类型推导，也比较清晰那这里还有1个不完美的在于，getindex他只能接受1个左值容器，对于一些右值容器，比如说一些工厂函数的返回值，我们直接传入，此时需要用万能引用和完美转发去解决 1234template&lt;typename container, typename index&gt;decltype(auto) func(container &amp;&amp; c, index i){ return std::forward&lt;container&gt;(c)[i];} 除此之外，decltype还有一个坑，如果decltype（sth），sth仅仅只是1个变量名，如x，一切如旧；但假如sth是(x),c++仍把他看做是左值表达式，此时decltype必须推导出是一个引用类型，那么对下列代码 1234decltype(auto) func(){ int x = 2; return (x);} 他会返回1个局部变量的引用，这是一个危险的未定义行为，所以使用decltype一定要小心，里面的东西到底是什么","link":"/2022/09/12/effective-modern-c-1-3/"},{"title":"effective modern c ++ 4-6","text":"条款4是教如何去获取类型推导结果的，第一种就是利用IDE去获取，第2种我们可以声明一个类模板但不去定义他，然后使用decltype(x)让编译器报错，如下 12345678template&lt;typename T&gt;class TD;int main(){ const int x = 3; TD&lt;decltype(x)&gt; xtype;} 此时编译器报错如下： 12error: aggregate ‘TD&lt;const int&gt; xtype’ has incomplete type and cannot be defined TD&lt;decltype(x)&gt; xtype; 可以看到x的确被推导为const int还有1种就是使用type_info,在大多数情况下他是正确的，但他推导的方式是安值推导的，也就是说，引用和常量性会被忽略，所以他并不可靠， 接下来是条款5，是开始了第2大章，关于auto的使用条款5具体讲了一些应用auto带来的方便与好处第1个就是在使用iterator的时候，如下 1234567template&lt;typename It&gt;void func(It b, It e){ while(b!=e){ typename std::iterator_traits&lt;It&gt;::value_type val = *b; }} 像上面这一段，我们使用萃取去获取这个迭代器到底指向啥东西，写起来十分的拗口麻烦，我们可以利用auto直接写成auto val = *b；第2个就是使用auto来保证变量一定能初始化，解决变量未初始化的行为 12auto i; // 不能通过auto i = 2; 第3个就是使用lambda表达式时，这个lambda对象到底是个什么类型，这个是由编译器决定的，所以我们需要利用auto用来把lambda表达式赋值给某个变量名，如 1auto lam = [](){ return 0; }; 当然我们也可以用一个std::function去持有这个lambda，如 12std::function&lt;bool(int,int)&gt;myfunc = [](int x, int y){ return true;}; 而其缺点在于function本身就是一个对象，他本身就是需要内存的，在内存上来说auto来的更好，第4个就是对于一些硬件依赖的typename，比如unsigned，在32位上和在64位上不同的，单单指定某个变量是unsigned可能会在不同机器上带来出乎意料的结果，因此我们可以利用auto 1auto size = v.size(); 第5个还是在迭代的时候，我们对于一些容器他储存方式不熟悉带来的问题，如 1for(const std::pair&lt;std::string, int&gt; &amp;p :m){...} m是个unorder_map,他本身是由std::pair&lt;const std::string, int&gt;组成的，不是上面这种方式，也就是说，程序跑到这段代码，会复制容器里的每一个元素，然后引用再去指向这些临时对象，可想而知多非时间，而使用auto很容易就解决 1for（const auto &amp;p:m){...} 当然了，auto也是得看实际的使用场景，大多数情况下使用得当能提升我们编程的效率的条款6 介绍的是使用auto可能遇到的坑，在这种时候就得采用传统的方式了第1个，就是vector&lt;bool&gt;这个和其他vector格格不入的对象，对于一般的vector&lt;T&gt;[],他能返回一个T&amp;类型的东西，但vector&lt;bool&gt;他本身是特化过的，他底层是使用比特去表示这1个1个的bool，而c++又不能返回1个对比特的引用，所以他只能返回一个用来模拟bool&amp;的reference，即std::vector&lt;bool&gt;::reference,他能够像bool进行隐式转换，所以对下面语句 12vector\\&lt;bool&gt; vec{true,true};bool is_true = vec[0]; 这里取出来的vec[0]实际是个std::vector&lt;bool&gt;::reference，但他可以转换为bool，所以没啥问题但假如我们使用auto去声明is_true,得到他类型就是std::vector::reference了，他就不是指代第1个元素是否为true的变量了书里介绍的这种情况带来的问题在于可能出现悬空指针，例如，当我们函数的返回值是个vector时，他是个临时对象，而他实现获取第1个元素的方式，有一种实现是通过指针+偏移量的方式去获取，而我们如果使用auto is_true = bool_vectroy()[0]时，is_true和临时对象的指针指向同一个东西，而临时对象在这一句话后就解析了，那is_true就指向1个被析构了的地址了，","link":"/2022/09/12/effective-modern-c-4-6/"},{"title":"effective modern c ++ 7-9","text":"条款7开始是第3章的内容，具体就是介绍了一些c+11新特性特别好用的地方条款7介绍的是{}的优缺点，第1点好处就是他用来初始化时适合于所有情况，一般而言有4种初始化方式，如下 1234int x = 2;int x(2);int x = {2};int x{2}; 后面2种其实都是同1个，而如下代码 123Widget w1;Widget w2 = w1;w1 = w2; 这里的赋值并不是初始化，而是复制构造函数,最后的调用的也是赋值运算符的重载大括号初始化的第1点优势在于可以用其初始化容器 1vector&lt;int&gt; vec {1,3,4}; 第2点是可以用来给非静态成员赋初始值 12345678class A{private: int x{2}; int y = 0; int z(0); //error! }; 第3点是可以用来给不可复制的对象进行初始化，如下 123std::atomic&lt;int&gt; x = 0; //error!!!std::atomic&lt;int&gt; y{2};std::atomic&lt;int&gt; z(0); 从2和3点可以看出，只有大括号初始化在这些情况下是可以通用的，所以说大括号是一种大一统初始化的方式大括号还有1种特性，括号内是不能使用窄式类型转换的，如 12doube x, y, z;int sum1 {x + y + z}; 上面不能确定double之和能不能用int表示 大括号的第4点好处是避免了很烦人的解析语法，如 1234Widget w(10);Widget w;Widget w();//变成函数声明了Widget w{}; 上面第3行本想用无参构造函数，结果却声明了一个返回值是Widget的无参函数，使用第4行的方式就能避免这种麻烦了而使用{}的缺点在于类的构造函数的选择问题上，如果构造函数的型参有std::initializer_list且传进来的参数有机会匹配到（有机会包括进行窄式类型转换），那么他会直接忽略其他任何的构造函数，不管说这些构造函数会多匹配如下 123456789101112class A{public: A(int x_, double y_):x(x_), y(y_){} A(std::initializer_list&lt;bool&gt; list){}private: int x; double y;};int main(){ A a{10,0.5};} 以上代码会报错， 1error: narrowing conversion of ‘10’ from ‘int’ to ‘bool’ inside { } [-Wnarrowing] 虽然有一个完美符合a的构造函数，但因为编译器看到了能使用initializer_list的希望，他就直接忽视了其他构造函数了甚至说以下代码 12Widget w{w2};Widget w3{std::move(w)}; 本来会使用复制构造函数和移动构造函数的，但如果有上述条件。他还是会调用initializer_list只有当真的没办法匹配到这个initializer_list型参的构造函数的时候，其他构造函数才会成为候选最后1个问题就是上面的无参构造函数了，在使用{}的时候表示的是无参，而不是没有元素的空的初始化列表，如果想表示后者，应该这么写 1Widget w{{}}; 而（）和{}的区别，也导致说初始化容器的时候，可能会有意想不到的结果，如下 12vector&lt;int&gt; vec (10, 20);vector&lt;int&gt; vec2 {10, 20}; 第1个是创建了一个元素都是20.共10个的vector，而第2个则是有2个元素，分别为10和20这种接口作者认为是失败的 条款8则是介绍了nullptr这个特性，在没有他之前，我们想表示空指针需要使用0和NULL,但前者本质是一个int，不是一个指针，而NULL根据具体的实现不同而不同，但本质也是1个整形数据而不是1个指针，所以在下面的场景中，那个参数为void *的函数是永远不会被调用的 12345void func(int){}void func(void *){}void func(bool){}func(0);func(NULL); NULL可能是由long实现的，可能带来歧义，但这里本质的问题在于传入的本意是个指针，结果却调用了非指针版本的矛盾因此，nullptr登上了舞台，他不具备整型类型，永远不会像0和NULL一样被解释为一个整形，且他可以隐式转换为任何其他类型的指针，此时func(nullptr)调用的就是void *类型的func了使用他的优点是在使用auto的场景下，到底一个变量是整数还是空指针，这个在有nullptr的情况下就很明了了 12345678auto func()-&gt;decltype(result){ if(result == nullptr){ return result; } ...} 假如这里的nullptr是0的话，auto就推导为int，但我们本意是拿result去和空指针比较，所以用上nullptr，result就一定是个指针了既然说到了auto，那模板推导也必然受益于nullptr了如下 1234567template&lt;typename T, typename P&gt;void func(T t, P ptr){ ...}func(3, 0);func(3, NULL);func(3, nullptr); 上面前2个调用会使得P被推导为int或long的整型数据，只有使用nullptr才使得P被推导为指针类型 条款9讲的是using用来声明类型别名的优势在不使用类型别名的时候，我们声明一个变量可能很痛苦，使用using就变简单多了，如下 1using MyType = std::unique_ptr&lt;std::unordered_map&lt;std::string,int&gt;&gt;; 当然我们可以使用typedef去弄别名，在上面的场景和下面这种，2者没啥区别，最多是可读性上不同 12using fp = void(*)(int ,double);typedef void (*fp)(int, double); 而using的优点在于模板的别名上，如下 12345678910template&lt;typename T&gt;using MyList = std::list&lt;T,MyAlloc&lt;T&gt;&gt;; //MyAlloc是自定义的MyList&lt;int&gt; l1;template&lt;typename T&gt;struct MyList{ typedef std::list&lt;T,MyAlloc&lt;T&gt;&gt; type;}；MyList&lt;int&gt;::type l2; 可以看出使用using比typedef方便多了，不用说去弄个struct写了一堆，而且如果想用上面的这个类型去用做类模板，using同样更加方便 1234567891011template&lt;typename T&gt;class{private: typename MyList&lt;T&gt;::type list;};template&lt;typename T&gt;class{private: MyList&lt;T&gt; list;}; 第2种就是使用using的写法，第1种既要typename又要::type，比较麻烦","link":"/2022/09/13/effective-modern-c-7-9/"},{"title":"effective modern c ++ 10-12","text":"条款10介绍的是enum的2种类型，一种是非限定作用域的enum，一种是限定作用域的enum，他们主要有以下几点不同一是作用域的不同 12enum Color{White, Black};auto White = false; 上面代码的第2行不能通过编译，因为这里的enum不带class，他的大括号里的内容的作用域会扩散出来，而下面 123enum class Color{White, Black};auto White = false;Color c = Color::White; 则不会，因为这里是限定作用域的enum,所以下面可以声明一个White二是能否隐式转换的问题非限定作用域的enum，他能转化为整数型别，甚至是浮点数，而限定作用域的则不可了，除非是static_cast去强制转换，如下 12345678enum Color{White, Black};void func(int c){ ...}Color c = White;c &gt;= 2;func(c); 上面这种代码比较诡异，为什么要拿枚举类的东西去和整数比较呢，没有啥意义，因此限定作用域的enum就禁止这种行为了三是关于能否前置声明而不定义的问题非限定枚举本来是能只声明的，但因为他的底层具体使用的数据类型是需要具体的枚举型别去确定，例如可能用char，也可能用int等，因此如果在后面，我们修改了他，整个系统就需要重新编译了而限定枚举能直接声明不定义，因为他默认底层的数据类型就是int，而非限定则没有默认值，只要我们加上默认值，也可以只声明了 1enum Color：int; 条款11介绍了delete关键词的使用场景最常见的是我们不想我们的对象能被复制，在98时直接把复制构造函数声明为private且不定义即可，到了11我们可以在后面加上=delete且放在public，另外1个就是，任何函数都能使用delete，这个应用场景如下 1234void func(int num);func('a');func(3.2);func(true); 如上，我们期望的实参是个int，但却传入了一堆不相关的，但这是允许的，因为他们还勉强能转化为int，为了明确禁止这种行为，我们可以 1234void func(int num);void func(double)=delete;void func(bool) =delete;void func(char)=delete; 这样子上面的3行函数调用会使用被删除的重载版本，也就不能通过编译了还有1种场景就是模板，我们希望当模板被某种类型的参数实例化时不能通过编译，比如说对指针类型T*,我们不希望void和char通过编译，前者因为他过于特殊，无法自增，自减，后者因为他通常是用来表示c的string，我们假定我们的模板不会处理这两种，代码如下 123456789template&lt;typename T&gt;void func(T* ptr){ ...}template&lt;&gt;void func&lt;char&gt;(char * ptr)=delete;template&lt;&gt;void func&lt;void&gt;(void * ptr)=delete; 条款12讲的是关于override的使用其最重要的使用场景在于，关于虚函数的重载，他的要求十分严格，函数的签名必须一致，const必须一致，异常必须一致（noexcept），引用修饰词也必须一致（在函数签名后加&amp;或&amp;&amp;表示这个函数是给左值对象或者右值对象调用），那么很有可能因为这些限制，我们写出来的“虚函数”实际已经丢失了虚函数的特性，而编译器有可能没有给我们提出warning，因此这个时候就需要override了，如下： 123456789class Base{public: virtual void func();};class Derived:public Base{public: virtual void func() override;}; 这样子编译器发现override的函数如果有什么不一致会报错这个条款的最后补充说明了引用修饰词的用法 123456789101112class A{public: using datatype = std::vector&lt;int&gt;; datatype&amp; getdata() &amp;{ return values; } datatype getdata() &amp;&amp; {return std::move(values);}private: datatype values;};A getA(){ return A;} 上面这段代码A这个类有2个不同的引用修饰词修饰的函数，当左值对象调用时，返回的是左值对象的左值引用，而当右值对象，例如getA()的返回值调用getData时，使用的是&amp;&amp;修饰的函数，因为临时对象本身就是要被析构的，最佳使用方式是移动他的资源，而不是复制，所以&amp;&amp;版本使用了move移动语义，而且他的返回值也不是一个左值引用了，而是一个临时值，是个右值","link":"/2022/09/13/effective-modern-c-10-12/"},{"title":"effective modern c ++ 16-18","text":"条款16讲的是对于const成员函数的线程安全性，具体而言，const成员函数只能保证不去修改那些没被声明为mutable的成员数据，那也就是说，多个线程访问同一个const函数的时候，就可能会出现data race的情况了 1234567891011121314class Poly{public: using type = std::vector&lt;double&gt;; type getroot()const{ if(valid){ ... //计算并修改root } valid = true; return root; }private: mutable bool valid{false}; mutable type root{};}; 以上代码可能在多线程下有问题，此时我们需要施加锁上去 1234567891011121314151617class Poly{public: using type = std::vector&lt;double&gt;; type getroot()const{ std::unique_lock&lt;std::mutex&gt; l(lock); if(valid){ ... //计算并修改root valid = true; } return root; }private: mutable bool valid{false}; mutable type root{}; mutable std::mutex lock;}; 不过由于mutex是不可复制的，这个类的复制行为也就应该被禁止了，不过他还是可以移动的书中还指出，如果mutable的变量只有1个，比如说某个计数器，那么我们可以直接用atomic去表示他，就不用大费周章的用锁了（虽然atomic有时候还是锁的实现），但atomic同样是不可复制的，所以该类同样只能移动而不能复制 123456789class A{public: void dosth()const{ count ++; //dosth.... }private: mutable std::atomic&lt;int&gt; count{0};}; 因为原子变量保证count++的执行是原子的，所以不用担心多线程带来的不确定性而如果需要2个以上的mutable变量，使用atomic去表示他们的策略不是明智的，例如上面的例子，如果修改root的过程是在valid后面，那么就可能发生这种情况-线程1读valid发现为false，于是计算，然后设置valid，此时线程2也使用了这个函数，发现valid是true，于是直接返回root了，但线程1还没有修改root呢，这种现象发生的原因在于修改2个原子变量的过程并不是原子的，所以我们就需要加1个互斥锁来保证修改2个原子变量这一大动作的原子性，那既然都要用互斥锁了，那还不如直接把2个mutable的声明为普通变量，反正有了锁就能保证原子性了所以总结的说，使用const成员函数时，要确保对mutable变量的操作能是线程安全的，可以通过互斥锁或者原子变量去实现 条款17说的是各种生成构造函数和生成运算符的生成规则，规则1.当没有声明任何构造函数时，会生成1个默认的无参构造函数规则2.如果没有声明复制构造函数等，在使用的时候会自动生成需要的函数上面2个规则是98时代的，在11，大家都知道引入了移动构造函数和移动运算符，而编译器自动生成的移动操作，会默认的去“移动”每一个成员变量，移动加双引号是因为这个移动是有前提的，如果成员变量本身无法移动的，例如int这种，他执行的是复制，如果这个成员提供了移动操作，才是真正的移动这个变量，而本质上是使用std::move去处理每一个变量，得到的右值如果这个成员本身有移动构造函数能处理这个右值，就是执行移动操作，否则只能使用这个变量的复制构造函数了，因为复制构造函数的形参都是const &amp;，所以能去引用1个右值，这里我们可以写个例子示范如下 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class Movable{public: Movable()=default; Movable(Movable &amp;&amp; rhs){cout&lt;&lt;&quot;movable class moving&quot;&lt;&lt;endl;} Movable(const Movable &amp; rhs){cout&lt;&lt;&quot;movable class copying&quot;&lt;&lt;endl;}};class Copyable{public: Copyable()=default; Copyable(const Copyable &amp; rhs){cout &lt;&lt; &quot;coping class copy&quot; &lt;&lt;endl;}};class A{public: A(Movable m_,Copyable c_):m(m_),c(c_){}private: Movable m; Copyable c;};int main(){ Movable m; Copyable c; cout &lt;&lt;&quot;==&quot;&lt;&lt;endl; A a(std::move(m),c); cout &lt;&lt;&quot;==&quot;&lt;&lt;endl; A b(std::move(a));} 对于复制构造函数和复制运算符，他们是独立的，声明一种不会导致说编译器不会去生成另一种，但移动的2个操作就不同了，如果声明了其中的一种，编译器则不会去生成另外1个了，因为他会认为既然你自己实现的移动构造函数与默认的按数据成员移动的方式不一样，那么默认的移动运算符必然也与之不同，那还不如不生成进一步的，复制操作和移动操作，只要定义了其中的一方，编译器就不会去生成另一种操作了，因为既然声明了其中的1种，说明对于另外1种来说，其实现方式也很有可能与默认的方式不同，编译器就采用这种思想。接下来提到的是一个大三律的东西：复制构造函数，复制运算符和析构函数，只要声明了其中的一种，就应该实现另外的2个，其思想在于，我们之所以会去刻意地定义他们，是因为某些类成员函数的复制方式不同于默认的复制方式，例如说某些指针型的，例如说和资源管理相关的，那么析构函数也必须处理如何析构这些资源从这个定律推出来，如果有了用户声明的析构函数，就说明默认生成的复制操作是不合用户心意的，因此编译器不应该自动生成，不过98的时代这个思想没有被编译器采纳，但到了11，移动操作应用于这种思想导致了——一旦用户声明了析构函数，移动操作就不会被自动生成所以结合以上内容，如果想要自动生成移动操作，需要：1.不能声明复制操作2.不能声明移动操作3.不能声明析构函数接下来我们可以写一个类，这个类只有1个vector的成员，如下 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class A{public: A(){} vector&lt;int&gt; vec;};int main(){ A a; a.vec.push_back(2); a.vec.push_back(3); A c = move(a); cout &lt;&lt;a.vec.size()&lt;&lt;endl;} 当没有声明析构函数的时候，最终a的vec的size是0，的确是有移动操作在里面，但假如声明一下析构，最终输出是2，说明移动构造函数的确没有自动生成，假如这个vec的内容很多，这个复制的时间必然是多于移动的，此时我们简单的加上A(A&amp;&amp;)=default即可当然了，有时候我们声明析构函数，是因为需要某个类作为基类，必须得声明他的析构函数并且声明为虚函数提供多态的特性，此时我们可以在那些无法自动生成的移动操作加上=default，告诉编译器这个移动操作使用默认的生成式可以的所以最后总结如下• 默认构造函数：与 C++98 的机制相同。仅当类中不包含用户声明的构造函数时才生成。• 析构函数：与 C++98 的机制基本相同，唯 的区别在千析构函数默认为noexcept （参见条款 14) 。与 C++98 的机制相同，仅当基类的析构函数为虚的，派生类的析构函数才是虚的。• 复制构造函数：运行期行为与 C++98 相同：按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造函数时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制赋值运算符或析构函数的条件下，仍然生成复制构造函数已经成为了被废弃的行为。• 复制赋值运算符：运行期行为与 C++98 相同：按成员进行非静态数据成员的复制赋值。仅当类中不包含用户声明的复制赋值运算符时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制构造函数或析构函数的条件下，仍然生成复制赋值运算符已经成为了被废弃的行为。• 移动构造函数和移动赋值运算符：都按成员进行非静态数据成员的移动操作。仅当类中不包含用户声明的复制操作、移动操作和析构函数时才生成。 接下来进入的是第4大章，关于智能指针的使用条款18讲的是unique_ptr我们可以认为一个uniqueptr和野指针有几乎一样的尺寸，且他不能复制，因为本身他的实际应用场景就是管理专用型资源的，而且他的构造函数也使用了explicit修饰，不能使用隐式类型转换去构造如下 12345unique_ptr&lt;int&gt; p1(new int(3));unique_ptr&lt;int&gt; p2 = new int(3);unique_ptr&lt;int&gt; p3{nullptr};p3 = p1;p3 = move(p1); 第1行是拿一个野指针做参数构造p1，行的通；但第2行是想执行1个隐式类型转换，把int*转换为unique_ptr,这个是行不通的,而第4行自然也error，只有第5行才可以，此时p1的资源就给p3管理了unique_ptr可以自定义删除器，而且必须得把第二个模板参数声明为这个删除器，所以不同删除器的同个管理对象的类型是不同的，这个shared_ptr就不是了，如下 123456789101112131415161718192021class Investment{public: ... virtual ~Investment(){}};class Stock : public Investment{...};class Bond: pulibc Investment{...};auto MyDelete = [](Investment * ptr){dosth; delete ptr;}template&lt;typename ...Ts&gt;unique_ptr&lt;Investment, decltype(MyDelete)&gt;func(Ts&amp;&amp;... params){ unique_ptr&lt;Investment,decltype(MyDelete)&gt; p (nullptr,MyDelete); if (/*need stock*/){ p.reset(new Stock(forward&lt;Ts&gt;(params)...)); } else{ p.reset(new Bond(forward&lt;Ts&gt;(params))); } return p;} 上面代码的注意点：我们使用自定义的删除器，则需要指定unique_ptr的第2个模板实参，且在创建该对象时将删除器传入第二个参数后面的赋值操作并不能通过=的方式，原因上面提到了，需要使用reset函数去转换其管理的对象而使用了自定义的删除器后，如果我们用的删除器是函数指针，这个unique_ptr的尺寸就比一般的野指针要大了，因为它还要储存函数指针，而如果是无捕获的lambda表达式，作者说是不会浪费任何空间的，这里有待了解详情。","link":"/2022/09/14/effective-modern-c-16-18/"},{"title":"effective modern c ++ 13-15","text":"条款13介绍的是const_iterator，一开始一大段介绍了在98中实现一个const_iterator有多么困难，但到了11，一切都迎难而解 12345vector&lt;int&gt; vec;auto it = std::find(vec.cbegin(),vec.cend(),13);vec.insert(it,16); 我们可以使用cbegin()cend()来获取容器的const 迭代器，就算是对非const容器也一样，且insert函数他的第一个参数是const_iterator,这样子就满足他的要求了除此之外有一点要注意的是，c++11提供了非成员函数的begin，end等函数，为的就是满足容器是数组的情况下的需求，但11并没有提供cbegin或者cend等const函数，我们无法在只依赖std库的情况下做到const遍历数组，因此我们可以这么写 1234template&lt;typename T&gt;decltype(auto) cbegin(const T&amp; container){ return std::begin(container);} 把传进来的容器用const修饰，那么我就能用他去获取cbegin了，当然这种多余的步骤在14的时候就没必要了，14的时候就引入了非成员的cbegin，cend等函数 条款14介绍的是关于异常和noexcept关键字，在11的标准里，一个函数要么可能发射异常，要么保证不会发射异常，如果能确保他不会发射异常，我们就应该加上noexcept关键字，有关异常的知识我也不是很了解，作者这里介绍说加上noexcept比其他方式优化更好也不是很理解，等后续补坑接着是几个标准库里和异常相关的函数，最重要的就是push_back函数，当需要扩容时，原本的版本是强异常安全性的——直到所有元素都复制到了新的内存上，旧内存上的元素才会析构，如果中途抛出了异常，则没啥事；但如果为了优化复制转而使用移动，假设我们已经移动了一部分元素了，但此时抛出了异常，程序就处在一部分元素在新的内存，一部分在旧的内存，原有的状态已经没有了，如果想恢复到原来的状态转而把移动过的元素移动回去也可能异常，而11的很多函数的实现，为了解决这种麻烦，采取的是“能移动就移动，不能移动才复制”的策略，而判断移动是不是安全就看这个操作有没有noexcept，其中有一部分的函数，例如swap他是否异常安全，完全取决于用户自定义的操作是否带有noexcept，具体例子如下 12template&lt;class T, size_t N&gt;void swap( T(&amp;a)(N), T(&amp;b)(N)) noexcept(noexcept(swap(*a,*b))); 上述代码中，noexcept这种使用方式称为条件式noexcept，只有当括号内T的swap的操作，也就是对a这个数组的每一个元素都进行swap操作时时noexcept的，括号里的结果就为true，此时外层的swap就也是保证异常安全了的 条款15介绍的是constexpr关键字，他表示的变量必须是个常量，且必须在编译期就能确定下来具体是什么值，这个一个值可以用在声明数组长度，array的模板实参（长度）等必须在编译阶段就已知的常量值，如下 12constexpr int len = 2;std::array&lt;int, len&gt; arr; 而const修饰的，他并没有会在编译期就知道具体值的保证，所以并不能把他用在array这种模板形参上constexpr还可以修饰函数，不过此时就有点复杂了，如果传入的实参是编译期就能确定的常量值，那他必须保证该函数也能在编译期得到对应的结果，但如果传入的参数有1个是直到运行期才知道结果的，此时的函数就和一般的函数一样了，如下 12345constexpr int pow (int base, int numconds){ ....}constexpr auto numconds = 5;std::array&lt;int, pow(3,numconds)&gt; arr; 以上代码可以通过，因为2个参数都是编译期就知的常量，因此pow也能在编译期返回具体的值了而上面pow的….的具体实现与版本有关，在c++11下，constexpr函数最多只能有1条可执行语句，因此得这么写 1return numconds=0? 1:base*pow(base,numconds-1); 而在c++14下这个限制就放开了，可以按一般的for循环去实现了 除了内置类型可以声明为constexpr外，我们自定义的类也可以将构造函数以及其他成员函数声明为constexpr，这样子就能在编译器完成相关的语句执行了，如下 1234567891011121314151617class Point{} constexpr Point(double x_ = 0.0, double y_ = 0.0):x(x_),y(y_){} constexpr getx(){return x;} constexpr gety(){return y;}private: double x,y;;constexpr getmid(Point x1, Point x2){ return Point((x1.getx() + x2.getx()) / 2, (x1.gety() + x2.gety()) / 2);}int main(){ constexpr Point x1(5.3,2.3); constexpr Point x2(2.2,34.2); constexpr Point mid = getmid(x1,x2);} 以上的x1和x2都能在编译阶段都确定下来具体的值，mid也是","link":"/2022/09/14/effective-modern-c-13-15/"},{"title":"effective modern c ++ 19-21","text":"","link":"/2022/09/15/effective-modern-c-19-21/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"c+2","slug":"c-2","link":"/tags/c-2/"},{"name":"tvm","slug":"tvm","link":"/tags/tvm/"},{"name":"小组件","slug":"小组件","link":"/tags/%E5%B0%8F%E7%BB%84%E4%BB%B6/"},{"name":"leveldb","slug":"leveldb","link":"/tags/leveldb/"},{"name":"effective_modern_c++","slug":"effective-modern-c","link":"/tags/effective-modern-c/"}],"categories":[]}