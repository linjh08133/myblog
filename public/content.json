{"pages":[],"posts":[{"title":"test","text":"","link":"/2022/09/02/test/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/09/02/hello-world/"},{"title":"test1","text":"","link":"/2022/09/02/test1/"},{"title":"tvm","text":"this is a placeholder for tvm下面测试以下图片捏","link":"/2022/09/04/tvm/"},{"title":"类型萃取","text":"所谓的类型萃取，就算说在某些函数模板中，它需要知道传进来的变量，它的类型到底是啥，用于返回值这类的，但c++是不允许说推导出返回值类型的，例如以下代码是不可能通过编译的template&lt;typename T&gt; (*T) func(T t){ ... }为了解决这种问题，对于我们自定义的类，可以利用typedef去声明，如下 1234567891011template&lt;typename T&gt;struct MyIter{ typedef T value_type; T * ptr; MyIter(T* p):ptr(p){} T&amp; operator*() { return *ptr; }};template&lt;typename T&gt;typename T::value_type func(T t){ std::cout &lt;&lt; *t &lt;&lt; std::endl;} 这样做当传入类型是MyIter&lt;int&gt;的时候，首先MyIter的T会实例化为int,func这个函数模板的T会被实例化为MyIter，那么其返回类型也就是int了，这里的typename是告诉编译器，后面的T::value_type 是一个类型（像int，double这种),不加就可能会被当作是成员变量造成歧义。那当我们传入的是原生指针呢，上面的自定义对象我们可以直接获取它的成员变量的所指对象，但int * 这种就无法通过T::value_type,因为它根本就没有，所以这个时候就可以利用模板偏特化+trait的技巧了，如下 123456789101112131415161718192021template\\&lt;typename T\\&gt;struct MyIter{ typedef T value_type; T * ptr; MyIter(T* p):ptr(p){} T&amp; operator*() { return *ptr; }};template\\&lt;typename T\\&gt;struct iterator_traits{ typedef T::value_type value_type;};template\\&lt;typename T\\&gt;struct iterator_traits\\&lt;T*\\&gt;{ typedef T value_type;};template&lt;typename T&gt;typename iterator_traits&lt;T&gt;::value_type func(T t){ std::cout &lt;&lt; *t &lt;&lt; std::endl; 那么当func传进来的是int *的时候，会调用特例化的第2个模板，那么value_type就是int啦，这样做iterator所指类型不管是什么情况都能知道了，","link":"/2022/09/04/%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96/"},{"title":"内存模型1.md","text":"c++的内存模型挺复杂的，因为现代cpu架构的原因，例如cache等，一些操作我们无法得知他具体什么时候会对其他线程可见，例如说thread A写了一个全局变量，但它很有可能是写到自己的私有cache导致说它的这个写对其他thread不可见，那么c++对于这些就提出了一个叫内存模型的玩意。首先是顺序一致性模型，它规定有2点：1.内存访问执行的顺序与程序指定的顺序相同2.所有核心的内存访问实际执行顺序都和程序指定顺序相同有1个例子就可以说明这个，一个群聊里，每个人的发言记录的顺序是固定的，不可能说先看到晚发出去的信息，而他所看到的所有人的发言记录，与其他的每个人都一样，都是遵循着某种交叉着的顺序，而且大家观察到的顺序都是一样的，而c++默认就是使用这种内存模型，即memory_order_seq_cst,以下面这段代码为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;atomic&gt;#include &lt;thread&gt;#include &lt;assert.h&gt;#include &lt;iostream&gt;std::atomic&lt;bool&gt; x,y;std::atomic&lt;int&gt; z;void write_x(){ x.store(true,std::memory_order_seq_cst); // 1}void write_y(){ y.store(true,std::memory_order_seq_cst); // 2}void read_x_then_y(){ while(!x.load(std::memory_order_seq_cst)); if(y.load(std::memory_order_seq_cst)) // 3 ++z; //std::cout &lt;&lt; z &lt;&lt; std::endl;}void read_y_then_x(){ while(!y.load(std::memory_order_seq_cst)); if(x.load(std::memory_order_seq_cst)) // 4 ++z; //std::cout &lt;&lt; z &lt;&lt; std::endl;}int main(){ x=false; y=false; z=0; std::thread a(write_x); std::thread b(write_y); std::thread c(read_x_then_y); std::thread d(read_y_then_x); a.join(); b.join(); c.join(); d.join(); assert(z.load()!=0); // 5 std::cout &lt;&lt; z &lt;&lt; std::endl;} 这里assert永远不会报错，且下一步输出的z有可能是1，有可能是2，下面分别分析：如果第1个load是true，但第2个load是false，也就算说它观察到了x的store是先于y的store，或者说在它跳出while的时候，肯定是看到了x的store操作，但y的load还是false，说明它没观察到y的store操作，所以它观察到的所x的store先于y的store，那么对thread d而言，它也必须以这种顺序观察到2个store，所以说thread d的第1个load如果是true了，说明它观察到了y的store，所以它必然已经观察到了x的store，所以它下一步的load必然为true，反过来也同理，这个时候的z就是1了而z=2的情况为还不是很明白，假如说a的第一个load到了某个时间点，观察到了x的store，它退出了while，然后它第2个load，观察到了y是true，但这就没办法确定x和y的store的观察顺序了，如果x的store先于y，那么对d而言，它的2个load必然为ture，z=2，如果y的store是先于x的，那么thread d就可能第2个load是false了，此时z=1（这里好像就是第1种情况了？，这里的解释不一定正确） 接下来是acq-rel模型，它解除了对全局一致性的约束，只单纯地利用memory_order_acquire和memory_order_release,前者如果某个load使用则在load之前的指令都不能跨过该语句被重排到后面，后者则是某个store使用则其后语句不能被重排跨到前面我们经常利用他们去实现同步操作，但是这里要注意，它无法保证全局一致，也就是说，每个thread观测到的顺序是可能不一样的，如下例子： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;atomic&gt;#include &lt;thread&gt;#include &lt;assert.h&gt;std::atomic&lt;bool&gt; x,y;std::atomic&lt;int&gt; z;void write_x(){ x.store(true,std::memory_order_release);}void write_y(){ y.store(true,std::memory_order_release);}void read_x_then_y(){ while(!x.load(std::memory_order_acquire)); if(y.load(std::memory_order_acquire)) // 1 ++z;}void read_y_then_x(){ while(!y.load(std::memory_order_acquire)); if(x.load(std::memory_order_acquire)) // 2 ++z;}int main(){ x=false; y=false; z=0; std::thread a(write_x); std::thread b(write_y); std::thread c(read_x_then_y); std::thread d(read_y_then_x); a.join(); b.join(); c.join(); d.join(); assert(z.load()!=0); // 3} 对于不同thread的对同1个原子变量，acq-rel的语义只能做到——如果在load的时候观察到了store，那么必然就能保证我们需要的同步，如果在load的时候还没观察到store的话就做不到了，如下代码 1234567891011121314151617181920212223242526272829303132#include &lt;thread&gt;#include &lt;atomic&gt;#include &lt;cassert&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;chrono&gt;std::atomic&lt;std::string*&gt; ptr ;int data; void producer(){ std::this_thread::sleep_for(std::chrono::milliseconds(1000)); std::string* p = new std::string(&quot;Hello&quot;); data = 42; ptr.store(p, std::memory_order_release);} void consumer(){ std::string* p2 = nullptr; //std::this_thread::sleep_for(std::chrono::milliseconds(1000)); p2 = ptr.load(std::memory_order_acquire); assert(*p2 == &quot;Hello&quot;); // never fires assert(data == 42);} int main(){ std::thread t1(producer); std::thread t2(consumer); t1.join(); t2.join();} 这段代码大多数时候是报错的，因为thread 1 sleep了一段时间，所以在第2个thread中，在它load的时候，第1个thread的store因为sleep的原因未执行，导致了它无法做到同步，所以下面的assert必然报错，但如果修改p2，改成while(!p2=ptr.load(std::memory_order_acquire)),就能实现同步了，因为它会一直在while中循环，直到某1次循环中，它观察到了线程1的store操作，那么这2者的同步语义就能建立起来了——线程1的store之前的语句必然先于store，线程2的load之后的语句必然非先于load，而它跳出循环的时候store必然是已经被观测到了，所以这种同步就建立起来了回头看上一段代码，这段代码可能报错的原因就在于，acq-rel语义没有规定全局一致，那么就可能出现thread c观测到x的store先于y的store，而d则反过来，此时他们就都加不了z，或者说我们可以这么理解——全局一致下，c看到了x是true，y只load1次看到是false，说明x的store对d来说也必然先于y的store，而d一直卡在while那里，直到它观测到y是true；但没有全局一致的要求时，以下情况就可能发生——对thread c，它卡在while一段时间退去后，此时它肯定观测到了x的sotre，而它只对y进行了1次load，是false，说明它观测到x的store先于y，但对d而言，没有全局一致的约束，c的观测顺序对它没意义了，它完全可以一直卡在while，直到它观测到y的store，然后在对x进行1次load，发现x的store还没被观察到，对d而言，它是先观测到y后才是x，那么这种矛盾的原因在于，x和y的store它可能是写入内存，而c和d在load的时候，不一定去内存找，它可能直接在自己的cache中找，不一致就来了那么怎么修改这段代码呢，很简单，只要保证x和y他们的被观测到的顺序是一样的就可以了，上述由于是分开被2个线程写的原因如下 123456789101112131415161718192021222324252627#include &lt;atomic&gt;#include &lt;thread&gt;#include &lt;assert.h&gt;std::atomic&lt;bool&gt; x,y;std::atomic&lt;int&gt; z;void write_x_then_y(){ x.store(true,std::memory_order_relaxed); // 1 y.store(true,std::memory_order_release); // 2}void read_y_then_x(){ while(!y.load(std::memory_order_acquire)); // 3 自旋，等待y被设置为true if(x.load(std::memory_order_relaxed)) // 4 ++z;}int main(){ x=false; y=false; z=0; std::thread a(write_x_then_y); std::thread b(read_y_then_x); a.join(); b.join(); assert(z.load()!=0); // 5} 这里就不用解释了，但如果说y的load不是while，而是只读1次，那这种同步性就没有了，因为它完全有可能在load之前没有观察到store，加上while，不断的load，直到某1次，发现y被store为true了，这次的load就和store有了先后顺序了，那么就可以保证同步了","link":"/2022/09/05/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B1/"},{"title":"模板偏特化","text":"","link":"/2022/09/04/%E6%A8%A1%E6%9D%BF%E5%81%8F%E7%89%B9%E5%8C%96-1/"},{"title":"模板偏特化","text":"模板偏特化，就","link":"/2022/09/04/%E6%A8%A1%E6%9D%BF%E5%81%8F%E7%89%B9%E5%8C%96/"},{"title":"shared_ptr线程安全","text":"shared_ptr众所周知的智能指针，其允许多个指针指向同一内存对象，且在引用计数为0的时候自动析构被管理的对象，但是，在多线程的环境下，他的操作不是线程安全的，原因在于，其管理对象的方式是通过指针去管理，而其底层的引用计数本身也是一个指针，指向一个真正的计数对象，当我们执行如下代码的时候 12shared_ptr&lt;A&gt; a1 (new A));shared_ptr&lt;A&gt; a2 = a1; a2在构造的时候，是分为2步的，第1步是让a2管理的A对象指向a1管理的对象，第2步是让a2的引用计数也指向a1的引用计数对象，然后再把count+1那么这种非原子的操作方式就可能带来race condition了，如下代码 1234567891011121314151617181920212223#include &lt;memory&gt;#include &lt;iostream&gt;#include &lt;thread&gt;std::shared_ptr&lt;int&gt; p1 (new int(5));void func1(){ std::shared_ptr&lt;int&gt; p2; p2 = p1; std::cout &lt;&lt; *p2 &lt;&lt; std::endl;}void func2(){ std::shared_ptr&lt;int&gt; p3; p1 = p3;}int main(){ std::thread t1(func1); std::thread t2(func2); t1.join(); t2.join();} 当线程1执行p2 = p1的时候，首先他会把p1管理对象的指针赋值给p2，但这个时候，线程2来了，他的p1 = p3的赋值操作，导致p1原来管理的int(5)变成了1个没人指向的对象，所以其对应的引用计数也为0，且这个原来的对象就被析构了，此时p1所指的引用计数对象，他的count是2，再下一步，来到线程1，p2 = p1指令继续赋值，把p1的新的引用计数对象赋给了p2，那么这个引用计数对象的count就是3了，但此时p2所指的是那个已经被析构了的int(5),这个时候我们再解引用p2，就会报错了，如图：中间的那个偶尔的段错误吐核就是啦所以这里要记住：shared_ptr的实现机制，最核心的就是使用2个指针，指向1个被管理对象和1个与之关联的引用计数对象，在赋值的时候是分2步的非原子操作，所以这个时候一定要加锁使其原子化","link":"/2022/09/05/shared-ptr%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"title":"局部静态对象","text":"c++11规定，在一个函数内的局部静态变量(local static),它的初始化是必须线程安全的，也就是说，它的初始化过程是加锁的，其他线程在其初始化过程中是被阻塞的，否则就可能说1个线程在初始化过程中在还没赋值之前，另1个线程也开始初始化，最后就造成了重复构造，具体如下代码 123456789101112131415161718192021222324252627282930#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;mutex&gt;class A {public:A(){ std::cout &lt;&lt; &quot;constructing&quot; &lt;&lt; std::endl; }};A&amp; getA(){ static A a; return a;}std::mutex lock;void func(){ A a = getA(); std::unique_lock&lt;std::mutex&gt; mylock (lock); std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;}int main(){ std::thread thread_list[10]; for (int i = 0; i &lt; 10; i++){ thread_list[i] = std::thread(func); } for (int i = 0; i &lt; 10; i++){ thread_list[i].join(); }} 可以看到，这个对象只被正确地构造了1次，其他线程都引用同一个对象这种方式是c++实现单例模式的最佳手段，因为它就是这么简单","link":"/2022/09/05/%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1/"},{"title":"一个可扩展哈希代码阅读","text":"可扩展哈希一般是用在数据库中管理1条1条的record的，虽然现在很多都是用B+树了这个主要是做15-445的project时接触到的，project2需要实现1个可扩展哈希静态的哈希随着记录的增多，其冲突的概率也越来越大，此时如果能动态扩容就能优化性能了可扩展哈希的主要成员就2个，一个是bucket，它内部存放的就是1条1条的记录，一般初始化的时候就指定他的可存放记录的数目，多个bucket就构成了整个hash表第2个是directory，他是1个可以扩展的数组，每个成员都是指针，指向对应的bucket，其对应的bucket就是通过哈希函数算出对应的下标，且可能会有多个成员指向同个bucket的情况，这个后面再说还有的就是2个重要的概念：global depth和local depth，前者是directory的成员，它指明了每个bucket最大的local depth，也限制了其管理的bucket指针数组的大小，例如说global depth是5的时候，他的bucket数组最多就有32个，而local depth是每个bucket的成员，他指明了找到该bucket需要的位数，例如说 这里我分析的是https://github.com/nitish6174/extendible-hashing/blob/master/main.cpp里面的代码，内容还是比较好懂的接下来首先是他的bucket部分，这个比较简单，就是一些常规的增删查改操作， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116Bucket::Bucket(int depth, int size){ this-&gt;depth = depth; this-&gt;size = size;}int Bucket::insert(int key, string value){ std::map&lt;int,string&gt;::iterator it; it = values.find(key); if(it!=values.end()) return -1; if(isFull()) return 0; values[key] = value; return 1;}int Bucket::remove(int key){ std::map&lt;int,string&gt;::iterator it; it = values.find(key); if(it!=values.end()) { values.erase(it); return 1; } else { cout&lt;&lt;&quot;Cannot remove : This key does not exists&quot;&lt;&lt;endl; return 0; }}int Bucket::update(int key, string value){ std::map&lt;int,string&gt;::iterator it; it = values.find(key); if(it!=values.end()) { values[key] = value; cout&lt;&lt;&quot;Value updated&quot;&lt;&lt;endl; return 1; } else { cout&lt;&lt;&quot;Cannot update : This key does not exists&quot;&lt;&lt;endl; return 0; }}void Bucket::search(int key){ std::map&lt;int,string&gt;::iterator it; it = values.find(key); if(it!=values.end()) { cout&lt;&lt;&quot;Value = &quot;&lt;&lt;it-&gt;second&lt;&lt;endl; } else { cout&lt;&lt;&quot;This key does not exists&quot;&lt;&lt;endl; }}int Bucket::isFull(void){ if(values.size()==size) return 1; else return 0;}int Bucket::isEmpty(void){ if(values.size()==0) return 1; else return 0;}int Bucket::getDepth(void){ return depth;}int Bucket::increaseDepth(void){ depth++; return depth;}int Bucket::decreaseDepth(void){ depth--; return depth;}std::map&lt;int, string&gt; Bucket::copy(void){ std::map&lt;int, string&gt; temp(values.begin(),values.end()); return temp;}void Bucket::clear(void){ values.clear();}void Bucket::display(){ std::map&lt;int,string&gt;::iterator it; for(it=values.begin();it!=values.end();it++) cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;} 接下来就是directory的内容，首先是他的构造函数 123456789Directory::Directory(int depth, int bucket_size){ this-&gt;global_depth = depth; this-&gt;bucket_size = bucket_size; for(int i = 0 ; i &lt; 1&lt;&lt;depth ; i++ ) { buckets.push_back(new Bucket(depth,bucket_size)); }} 可以看到，他一开始的local depth和global depth是一样的，其哈希函数如下： 1234int Directory::hash(int n){ return n&amp;((1&lt;&lt;global_depth)-1);} 很直白的，就是取n的二进制位的最后global depth位做为哈希值，例如说当global depth为3时，上面就是n&amp;7（111）了下面是一个取pair的函数 1234int Directory::pairIndex(int bucket_no, int depth){ return bucket_no^(1&lt;&lt;(depth-1));} 这个是在桶进行split的时候调用的，这里在被调用时被分裂的桶的bucket_no+1才等于参数depth，例如说bucket_no是6（110）的时候，depth是4，那么做取异操作后，返回的是14（1110），和原来的6（0110）相比，就是在增加的哈希位上不同了，这里具体为啥这么做见后面的grow就知道了 123456void Directory::grow(void){ for(int i = 0 ; i &lt; 1&lt;&lt;global_depth ; i++ ) buckets.push_back(buckets[i]); global_depth++;} grow函数是在bucket分裂时发现他分裂后的local depth比global depth还大时调用的，调用后bucket数组翻倍，而且他翻倍后多出来的数组元素，比如说原来是n个，现在2n个，第n+1个和第1个指向同1个bucket，因为push_back会生成原来指针的副本，他也指向原来的指针所指对象，所以grow的过程并没有真正的创建bucket对象，只是多出了一些类似占位符的东西。而且看到这里上面的pairindex函数就明白了，pair指的就是这里的指针11对应的关系，bucket数组的第6个和第14个都指向同1个bucket对象，我们取得他的下标，给他赋予真正的新的bucket对象（见下面的split) 12345678910111213141516171819202122void Directory::split(int bucket_no){ int local_depth,pair_index,index_diff,dir_size,i; map&lt;int, string&gt; temp; map&lt;int, string&gt;::iterator it; local_depth = buckets[bucket_no]-&gt;increaseDepth(); if(local_depth&gt;global_depth) grow(); pair_index = pairIndex(bucket_no,local_depth); buckets[pair_index] = new Bucket(local_depth,bucket_size); temp = buckets[bucket_no]-&gt;copy(); buckets[bucket_no]-&gt;clear(); index_diff = 1&lt;&lt;local_depth; dir_size = 1&lt;&lt;global_depth; for( i=pair_index-index_diff ; i&gt;=0 ; i-=index_diff ) buckets[i] = buckets[pair_index]; for( i=pair_index+index_diff ; i&lt;dir_size ; i+=index_diff ) buckets[i] = buckets[pair_index]; for(it=temp.begin();it!=temp.end();it++) insert((*it).first,(*it).second,1);} 首先是调用要分裂的那个bucket的increasedepth函数，他的local depth+1了，如果需要扩容调用grow函数，接着是找到指向同1个bucket的bucket_no(pairindex函数)，然后在他上面真正的创建1个新的bucket，然后把需要分裂的那个桶的内容赋值给temp变量并清空，准备后面的分配，而接下来的操作则是bucket数组里的某几个指向新建立的bucket，这里我们具体以一个例子说明假设一开始global depth和local depth都是3，后来有某个桶7（111）他要split，发现global depth不够，于是需要grow，然后就走上述流程，接着算出index_diff和dir_size都是16，pair_index是15（1111），那么很明显2个for循环都不满足条件不执行，因为除了7和15外就没有哪个bucket_no指向相关的桶了，但假如后来桶7（0111，这个时候是4层了）又不够了，又要扩容了，global depth就变成5了，一切如上照旧；后来桶7又不够用。又分裂了，global depth变为6了，不过这个时候和原来8个桶相比，只多了3个桶而已到了后面，终于是1个local depth是3的桶要分裂了，假设他是6（110），他发现global depth够用，就不用grow了，他的pair_index是14（1110），index_diff是16，dir_size是64，第1个for没走，但第2个，他会遍历30（011110），46（101110），62（111110），这3个桶都指向新分裂出来的桶，原本他们指向的和6一样的桶，至于为啥这么做，我的想法是，当global depth比local depth多到1定程度时，指向同1个桶的哈希下标是有很多的，这个时候就需要新生成的桶来分担一些，例如上面的6，在没分裂前，后3位是110的桶的下标都指向了6,的桶，分裂后，后四位是0110的依旧，但1110的则被分配去新的桶了，假如不这么做的话，到后面可能就出现某些桶需要频繁地分裂的结果接下来就是insert函数，其实现如下 123456789101112131415161718192021void Directory::insert(int key,string value,bool reinserted){ int bucket_no = hash(key); int status = buckets[bucket_no]-&gt;insert(key,value); if(status==1) { if(!reinserted) cout&lt;&lt;&quot;Inserted key &quot;&lt;&lt;key&lt;&lt;&quot; in bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl; else cout&lt;&lt;&quot;Moved key &quot;&lt;&lt;key&lt;&lt;&quot; to bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl; } else if(status==0) { split(bucket_no); insert(key,value,reinserted); } else { cout&lt;&lt;&quot;Key &quot;&lt;&lt;key&lt;&lt;&quot; already exists in bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl; }} 首先是计算哈希值，例如说上面的例子继续下去，此时的global depth是6，这里根据上面的例子，对于后4位是1110的，他们会指向同1个桶，而后4位是0110的，他们会指向另外1个桶，可万一他原本就要溢出的桶里面，每条记录的后4位都是0110呢，这个时候他们就都走到同1个桶了，就又溢出了，这个时候上面代码就根据insert的返回值判断是否溢出，溢出了，则要对bucket_no这个桶再一次split，例如说我们假设的6（0110，现在是4位local depth），6的pair index这个时候是22了（10110），split也顺带把54指向了新生成的桶（110110，接下来就是根据5位二进制去判断了，因为我们原本假设他们后4位都是0110，现在就进一步地根据第5位是0还是1去判断走哪个桶了，如果还溢出，就继续分裂，知道没有溢出为止。总结目前上述内容，就是一种平衡吧，当global depth是6的时候，在6（110）这个下标的桶还没分裂前，有8个哈希下标会指向他，分裂的同时也应该能使得new出来的桶分担一些那接下来有分必有合，shrink操作函数如下 123456789101112131415void Directory::shrink(void){ int i,flag=1; for( i=0 ; i&lt;buckets.size() ; i++ ) { if(buckets[i]-&gt;getDepth()==global_depth) { flag=0; return; } } global_depth--; for(i = 0 ; i &lt; 1&lt;&lt;global_depth ; i++ ) buckets.pop_back();} 如果有1个桶的local depth和global depth一样，就无法缩小了，原因可以看到后面他缩小的操作，实际上就是把后半部分的bucket给去掉了，而能没有后果的去掉的前提是，这些bucket指向的对象完全和前半部分的一样，但假如其中某个桶的local depth和global depth一样，说明是经过了split中的new Bucket(local_depth,bucket_size)操作，导致这后半部分有某个桶他指向了新的对象，也就无法删除了，下面是merge函数 1234567891011121314151617181920void Directory::merge(int bucket_no){ int local_depth,pair_index,index_diff,dir_size,i; local_depth = buckets[bucket_no]-&gt;getDepth(); pair_index = pairIndex(bucket_no,local_depth); index_diff = 1&lt;&lt;local_depth; dir_size = 1&lt;&lt;global_depth; if( buckets[pair_index]-&gt;getDepth() == local_depth ) { buckets[pair_index]-&gt;decreaseDepth(); delete(buckets[bucket_no]); buckets[bucket_no] = buckets[pair_index]; for( i=bucket_no-index_diff ; i&gt;=0 ; i-=index_diff ) buckets[i] = buckets[pair_index]; for( i=bucket_no+index_diff ; i&lt;dir_size ; i+=index_diff ) buckets[i] = buckets[pair_index]; }} 这里就是split反过来，例如说上面的例子，我想merge22，他的pair index是6，且他们的local depth都是5，这个时候就可以走if里面的流程，把这个local depth减1，然后删去22这个桶，且让6所指的桶的指针给了22，然后就是把那些原来指向22的桶现在指向6，就是和上面split一样的思路下面是remove函数 123456789101112131415void Directory::remove(int key,int mode){ int bucket_no = hash(key); if(buckets[bucket_no]-&gt;remove(key)) cout&lt;&lt;&quot;Deleted key &quot;&lt;&lt;key&lt;&lt;&quot; from bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl; if(mode&gt;0) { if(buckets[bucket_no]-&gt;isEmpty() &amp;&amp; buckets[bucket_no]-&gt;getDepth()&gt;1) merge(bucket_no); } if(mode&gt;1) { shrink(); }} mode是用户输入的，根据他来判断是要merge（删去某个桶）还是直接对半砍去剩下的几个没列出来的也只是很简单的操作，这个代码也就分析完咯，下面就开始做project2捏","link":"/2022/09/07/%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%89%A9%E5%B1%95%E5%93%88%E5%B8%8C%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"},{"title":"引用折叠","text":"所谓的万能引用主要是用在以下2种场合：第1种是模板如下： 12template&lt;typename T&gt;void func(T&amp;&amp; t){...} 以上代码中的&amp;&amp;并不是右值引用的意思，他是表示说这个t肯定是一个引用类型，但具体是左值引用还是右值引用我们得根据传进来的参数确定那如何根据传进来的参数确定呢，这里就用到了引用折叠了，具体而言，当T被推导出来是右值时，T&amp;&amp;是一个右值引用（&amp;&amp; &amp;&amp; 折叠为了&amp;&amp;），而其他情况都是折叠为&amp;，即左值引用为了验证，我们可以用完美转发来验证一下 12345678910111213141516171819202122#include &lt;iostream&gt;void print(int&amp; t){ std::cout &lt;&lt; &quot;left&quot; &lt;&lt; std::endl;}void print(int&amp;&amp; t){ std::cout &lt;&lt; &quot;right&quot; &lt;&lt; std::endl;}template&lt;typename T&gt;void func(T&amp;&amp; t){ print(std::forward&lt;T&gt;(t));}int main(){ int x = 10; func(x); func(12); func(std::move(x)); int&amp; y = x; func(y);} 以上代码第1个显示是left，x是一个左值为什么被推导为左值引用呢，因为在func的参数里，传进来的T&amp;&amp;必须被解释为1个引用，那T就可以是int，int&amp;，int&amp;&amp;，只有int&amp;能被推断为左值(int&amp; &amp;&amp;折叠为&amp;)，第2个则是right，T是实例化为int，第3个为right，T为int&amp;&amp;，第4个T为int&amp;，折叠为&amp;，所以结果是left 第2种使用万能引用的场合是在auto推断中，如 12auto&amp;&amp; i = 3； //auto推断为int，i为int&amp;&amp;类型，即右值引用auto&amp;&amp; j = i; // auto推断为int&amp;，i为int&amp;，即左值引用","link":"/2022/09/07/%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0/"},{"title":"函数返回类型后置","text":"返回类型后置，主要的用处在于某些函数他返回的类型可能很复杂，例如返回一个函数指针等，如下 12typedef void(* ret)(int,double);ret myfunc(){...} 为了更加简洁，我们可以这么写 123auto myfunc() -&gt; void(*)(int,double){ ...} 其中的auto只是个占位符，真正的返回类型在后面，感觉和Python的写法很像捏 除此之外，我们还可以用decltype来推导函数的返回类型，如下： 1234template&lt;typename T1, typename T2&gt;auto func(T1 t1, T2 t2)-&gt;decltype(t1 + t2){ return t1 + t2;} 那么生成的模板函数就会根据t1+t2的实际类型决定返回类型了c++也允许decltype放在函数名之前表示返回类型如下： 1234template&lt;typename T1, typename T2&gt;decltype(T1() + T2()) func(T1 t1, T2 t2){ return t1 + t2;} 这么写虽然说也可以，但实际不这么建议使用，1是他需要要求T1和T2有无参构造函数，2是不够简洁","link":"/2022/09/07/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE/"},{"title":"4种c++风格的类型转换","text":"reinterpret_cast(value),他可以把一个指针转化为另外1种指针，也可以把1个整型值赋给一个指针，其最本质在于不修改value的底层二进制位，只是修改了去解释他的方法，比如说同一个二进制数，我用整数补码（int）和float类型那个ieee标准去解释结果肯定不同 123456789#include &lt;iostream&gt;int main(){int a = 0;int* p = &amp;a;char* p2 = reinterpret_cast&lt;char *&gt;(p);*p2 = '1';std::cout &lt;&lt; a &lt;&lt; std::endl;} 上面代码的输出结果为49，正好是a的asci值，首先他会把p这个int指针强制转换为char类型的指针，而且他指向了a的最低位（在我们机器上是小端存储的的），我们解引用赋值，其实就是在a的最低位字节上赋值了整数49，当用char的方式去解读时读出来的就是’a’,int则是49了，还有另外一种使用方式就是把一个整数赋值给一个指针，然后这个指针就指向这个地址了， 123int* p;int address = 0x12345678;p = reinterpret_cast&lt;int*&gt;(address); 当然这种得是你能访问这个地址才行 而这种强制转换在leveldb中的fixedint编码中就使用了，如下： 1234567inline void EncodeFixed32(char* dst, uint32_t value) { uint8_t* const buffer = reinterpret_cast&lt;uint8_t*&gt;(dst); buffer[0] = static_cast&lt;uint8_t&gt;(value); buffer[1] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 8); buffer[2] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 16); buffer[3] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 24);} 首先他把dst这个指针重新解释为1个指向uint8_t类型的指针然后赋值给buffer，现在buffer和dst指向同一个内存地址了，只不过他们解释这个地址里的东西的方式不同了，然后就是依次把value的每个字节的值写入buffer，也就是dst中，decode的则是反过来 123456789inline uint32_t DecodeFixed32(const char* ptr) { const uint8_t* const buffer = reinterpret_cast&lt;const uint8_t*&gt;(ptr); // Recent clang and gcc optimize this to a single mov / ldr instruction. return (static_cast&lt;uint32_t&gt;(buffer[0])) | (static_cast&lt;uint32_t&gt;(buffer[1]) &lt;&lt; 8) | (static_cast&lt;uint32_t&gt;(buffer[2]) &lt;&lt; 16) | (static_cast&lt;uint32_t&gt;(buffer[3]) &lt;&lt; 24);} 然后就是static_cast,基本等价于隐式转换，可以用在空指针转化为任意指针，可以用在整形和浮点数之间，对于继承的机制来说，可以把子类转化为父类，父类则不能反过来变为子类的， const_cast const_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。它的使用场景我目前了解的具体是在与const string这种相关的函数签名上，具体而言，大家都知道只有const string &amp;才能引用一个右值（在不想写右值引用的情况下），而为了能让函数能接受(“ww”,”ee”)这种参数，我们就不得不把函数的参数声明为const string&amp;，那这个时候他就很有可能也返回一个const string &amp;，但往往我们并不需要这种const的限制，所以我们就可以写个没有cosnt约束的函数，在其内部使用const_cast添加或移去他的常量性，如下： 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const string &amp; shorter(const string &amp; s1, const string &amp; s2){ cout &lt;&lt;&quot; this is const&quot; &lt;&lt; endl; return s1;}string &amp; shorter(string &amp; s1, string &amp; s2){ cout &lt;&lt;&quot;this is non const&quot; &lt;&lt; endl; auto &amp;res = shorter(const_cast&lt;const string &amp;&gt;(s1), const_cast&lt;const string &amp;&gt;(s2)); return const_cast&lt;string &amp;&gt;(res);}int main(){ string s1(&quot;ww&quot;); string s2(&quot;Ee&quot;); shorter(s1,s2); shorter(&quot;ww&quot;,&quot;ee&quot;);} 这样子不管进来的是什么样的内容，就都能处理了， dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。 dynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。","link":"/2022/09/09/4%E7%A7%8Dc-%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"title":"CRTP与静态多态","text":"CuriouslyRecurringTemplatePattern，简称CRTP，是一种实现静态多态的机制，简单而言，他的核心在于：父类是一个模板类，派生类会继承父类，且以派生类自身作为父类的模板参数，如下： 123456789101112131415161718192021222324252627template&lt;typename T&gt;class Base{public: void print(){ static_cast&lt;T*&gt;(*this)-&gt;imp(); } void imp(){ std::cout &lt;&lt; &quot;this is base&quot; &lt;&lt; std::endl; }};class Son1: public Base&lt;Son1&gt;{ void imp(){ std::cout &lt;&lt; &quot;this is son 1&quot; &lt;&lt; std::endl; }};class Son2: public Base&lt;Son2&gt;{ void imp(){ std::cout &lt;&lt; &quot;this is son 2&quot; &lt;&lt; std::endl; }};template&lt;typename T&gt;void func(T &amp; t){ t.print();} 当我传入func的对象是Son1时， Base实例化为Son1，print中的static_cast就会把this指针强制转换为Son1*，也就能调用Son1自己实现的函数了，不过这里严格意义上来说并不算是多态，因为每个派生类继承的是各自实例化后的模板类，使用static_cast就能把从基类去访问派生类的成员函数了似乎llvm的visitor模式采用的就是这种捏，tvm中的貌似也有涉及这种设计，后续再看","link":"/2022/09/09/CRTP%E4%B8%8E%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/"},{"title":"leveldb源码系列1-skiplist","text":"本文分析的是leveldb中的跳表skip list的实现，他会把user key和user value打包成一个更大的key塞入list中跳表的一个例子如下图 可以看到，每一个node，它都有不同的高度，且每个节点都在第0层都有出现，第0层就像最简单的链表一样，而到了上面的层数节点的个数越来越少，就像树状结构那种，跳表的许多操作都能在logn的复杂度下完成，leveldb的主要结构包括skiplist，内部是由一系列的node构成的，他还实现了一个iterator用于遍历接下来首先看node的实现 1234567891011121314151617181920212223242526272829303132333435363738template &lt;typename Key, class Comparator&gt;struct SkipList&lt;Key, Comparator&gt;::Node { explicit Node(const Key&amp; k) : key(k) {} Key const key; // Accessors/mutators for links. Wrapped in methods so we can // add the appropriate barriers as necessary. Node* Next(int n) { assert(n &gt;= 0); // Use an 'acquire load' so that we observe a fully initialized // version of the returned Node. return next_[n].load(std::memory_order_acquire); } void SetNext(int n, Node* x) { assert(n &gt;= 0); // Use a 'release store' so that anybody who reads through this // pointer observes a fully initialized version of the inserted node. next_[n].store(x, std::memory_order_release); } // No-barrier variants that can be safely used in a few locations. Node* NoBarrier_Next(int n) { assert(n &gt;= 0); return next_[n].load(std::memory_order_relaxed); } void NoBarrier_SetNext(int n, Node* x) { assert(n &gt;= 0); next_[n].store(x, std::memory_order_relaxed); } private: // Array of length equal to the node height. next_[0] is lowest level link. // 1) 这里提前声明并申请了一个内存，用于存储第 0 层的数据，因为第 0 层必然存在数据。 // 2) 这里的数组长度其实就是层高，假设 next_ 长度为 n，那么就会从 next_[n-1] 开始查找。 // 3) 因为 skip list 的 level 并不会太大，使用数组存储 Node 指针的话对 CPU 内存更友好 // https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf std::atomic&lt;Node*&gt; next_[1];}; 第一部分主要是1个显式的构造函数，指定某个键并初始化key这个成员数据，然后是他的next_数组，这个数组主要是用来存放该结点的每一层的next结点的指针的，指定为1是因为必然要在第0层有该结点，接下来是他的2个无锁操作和2个不用内存屏障的操作，next这个无锁操作使用了next_这个原子对象的load函数，且指定了memory_order_acquire,那么在这个语句之前的都不会被重排到他后面了，而setnext则是store函数，指定了memory_order_release，则该语句后面的内容都不会重排到他前面去，后面的2个则是使用了memory_order_relaxed,他只保证这条语句他是原子的，语句前后怎么重排都没有限制接下来是一个生成新结点的函数 123456789template &lt;typename Key, class Comparator&gt;typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::NewNode( const Key&amp; key, int height) { // 内存分配时只需要再分配 level - 1 层，因为第 0 层已经预先分配完毕了。 char* const node_memory = arena_-&gt;AllocateAligned( sizeof(Node) + sizeof(std::atomic&lt;Node*&gt;) * (height - 1)); // 这里是 placement new 的写法，在现有的内存上进行 new object return new (node_memory) Node(key);} 第2行开头的typename是为了告诉编译器，后面这个::Node是一个类型，那么整个函数的返回值就是NOde*了，首先分配内存，然后在这个内存上placement new，调用node的构造函数了 接下来是skiplist的成员函数第一个是生成随机层数的函数 123456789101112template &lt;typename Key, class Comparator&gt;int SkipList&lt;Key, Comparator&gt;::RandomHeight() { // Increase height with probability 1 in kBranching static const unsigned int kBranching = 4; int height = 1; while (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == 0)) { height++; } assert(height &gt; 0); assert(height &lt;= kMaxHeight); return height;} 首先初始化height为1，接着以1/4的概率使得while成立（在height比kmaxheight小的情况下），这样子第1层的node个数就大致是第0的1/4了，后面的层数以此类推，而用1/4这个概率貌似也是提出跳表的论文中建议的？接下来是一个key的大小顺序的函数 12345template &lt;typename Key, class Comparator&gt;bool SkipList&lt;Key, Comparator&gt;::KeyIsAfterNode(const Key&amp; key, Node* n) const { // null n is considered infinite return (n != nullptr) &amp;&amp; (compare_(n-&gt;key, key) &lt; 0);} 当要比较的对象（比如说是next节点指向的某一层对象）不为空且compare比较器得到的结果小于0时，说明这个key在顺序上是在n后面的， 接下来就是查找在每一层上 12345678910111213141516171819202122232425template &lt;typename Key, class Comparator&gt;typename SkipList&lt;Key, Comparator&gt;::Node*SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(const Key&amp; key, Node** prev) const { Node* x = head_; int level = GetMaxHeight() - 1; while (true) { /* 获取当前 level 层的下一个节点 */ Node* next = x-&gt;Next(level); if (KeyIsAfterNode(key, next)) { // Keep searching in this list x = next; } else { // prev 数组主要记录的就是每一层的 prev 节点，主要用于插入和删除时使用 if (prev != nullptr) prev[level] = x; if (level == 0) { return next; } else { // Switch to next list level--; } } }} 其中的GetMaxHeight函数获取的是当前结点的层数，我们从这个节点的最高层开始找，不断获取他的next节点，判断这个node他","link":"/2022/09/09/leveldb%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%971-skiplist/"},{"title":"tvm系列1——te代码阅读","text":"这篇是想探索一下tvm的te的compute和schedule具体的实现代码， 1234n = te.var(&quot;n&quot;)A = te.placeholder((n,), name=&quot;A&quot;)B = te.placeholder((n,), name=&quot;B&quot;)C = te.compute(A.shape, lambda i: A[i] + B[i], name=&quot;C&quot;) 上面这段假如熟悉tvm的应该再熟悉不过了，首先第1句话，返回的是tvm.tir.Var的数据类型的变量，这个是tir上的数据结构，后面再解析下面的A和B的placeholder如下 1234def placeholder(shape, dtype=None, name=&quot;placeholder&quot;): shape = (shape,) if isinstance(shape, tvm.tir.PrimExpr) else shape dtype = &quot;float32&quot; if dtype is None else dtype return _ffi_api.Placeholder(shape, dtype, name) 这个tvm.tir.PrimExpr是tir大多数类的父类，然后就会调用ffi机制去使用c++写的代码，这里也没啥可以说的，返回的就是 到了compute，这里源码的一开始一大段都是处理参数变量名称的，不用理会，这里他会if else到最后，直接把argspec.args当做arg——names，这里他是使用inspect的getfullargspec去获取一个lambda表达式的所有信息的到下面dim_var = [tvm.tir.IterVar((0, s), x, 0) for x, s in zip(arg_names, shape[:out_ndim])] body = fcompute(*[v.var for v in dim_var]) out_ndim是第1个参数的维度，这里是1，然后s是只有1个，就是n，会用他们去构造IterVar，第1个参数是这个iter的范围，第2个是这个iter的标识，第3个是这个iter的类型，源码中写着他是datapar，应该是一般的那种iter这里构造出来的dim_var打印如下： 12~~~接下来的body部分的var其实就是上面的第2个参数，fcompute就是C中的lambda表达式，首先把var的列表给解包，在调用fcompute这个可调用对象，就是上面C的lambda表达式，这里我们再写1个看看 n = te.var(“n”)A = te.placeholder((n,n), name=”A”)B = te.placeholder((n,n), name=”B”)C = te.compute(A.shape, lambda i,j: A[i,j] + B[i,j], name=”C”) 这里返回的body的类型是tvm.tir.expr.Add,主要是因为A和B都是tvm.te.Tensor,他们继承自ExprOp类，而这个类又写了一堆魔法方法，重载了一系列的运算符，比如说这里的+运算符，写了__add__函数后，最终调用这个函数 假如说在compute中，有te.sum这种reduce操作的，还会识别出其中达到reduce_axis,","link":"/2022/09/08/tvm%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94te%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"},{"title":"effective modern c ++ 1-3","text":"条款1是对模板参数推导的几个细则，具体以下代码 12template &lt;typename T&gt;void func(ParamType param){} 使用func(expr)去调用时，它会推导T和param的形别，这2种有的时候是一样的，有的时候由于常量这些标识而不同，例如 12template &lt;typename T&gt;void func(const T&amp; param){} 在使用一个int 变量i去调用func时，T是iNT,而PARAMTYPE是const int&amp;具体则分三种情况去讨论第1种是paramtype是一个非万能引用，此时的判断方法是：如果expr具有引用，把引用给忽略，然后再去推导，如下 123456template &lt;typename T&gt;void func(T&amp; param){}int x = 2;const int cx = x;const int&amp; rx = x; 那么在调用func的时候，对x，T是int，paramtype是int&amp;，而后面2个T是const int，而paramtype是const int&amp;，因为第3个expr的引用是会被忽略的，这里也可以看出，持有T&amp;的模板，它能保证传进来的对量的常量性能被捕获第2种是paramtype是一个万能引用，如 12template&lt;typename T&gt;void func(T&amp;&amp; param){} 这个时候就使用引用折叠，可知如果传进来的expr是左值，T和paramtype都会推导为左值引用，如果expr是右值，则根据1的规矩即可 第3种情况就是paramtype不是引用，那么就是说函数是按值传参的，他复制了一个新的对象，此时他对expr，会忽视他的const，volatile和引用，所以对上面的，x，cx，rx，如果模板声明如下 12template&lt;typename T&gt;void func(T param) 那么T和paramtype最终都是int，这个也是可以理解的——本身传进来后我是构建的新的对象，不会对外面的一切造成干扰这里还有1种特殊情况，即指向常量的常量指针，const int * const ptr,那么传进来之后，右边的const会被忽略，因为传进来的本质是1个地址，这个值就像前面那个const int一样，所以他就被忽略了，那么进来后，T会被推导为const int，指向常量的指针最后就是关于数组的问题了，这里直接结论如下：当paramtype是T param时，数组形参会退化为1个指针例如templatevoid func(T param)const char name[] = “22”;此时把name传进来时，T会推导为const char*但假如paramtype是个引用，T则会推导为const char[3],而paramtype则是cost char（&amp;）[13]我们可以用这一特性去推导数组长度 12345678template&lt;typename T, int N&gt;constexpr int getlen(T(&amp;)[N]) noexcept{ return N;}int main(){ int x[2] = {2,3}; char y[getlen(x)];} 条款2是auto推导的规则，他的规则上和模板推导的基本一致，但有一点很特别，在使用c++11引入的初始化方式中，如下 12auto x{3};auto x={3}; 此时auto推导型别会推导出std:: initializer_list，且其中只有1个元素的变量，所以如下代码编译是会失败的 1auto y{2,3,3.0}; 因为对std:: initializer_list的T推导不出是什么这里的本质是有2次推导，第1个是推导出y的型别为std:: initializer_list（因为使用了大括号去初始化），第2次是推导std:: initializer_list的T的类型，而如果我们想利用模板去实现这一点是做不到的，因为auto他本身对大括号初始化就假定了第1次推导必定是std:: initializer_list，而模板没办法，所以如果真要用模板，可以这么实现 12template&lt;typename T&gt;void func(std:: initializer_list&lt;T&gt; list); 对于func({2,3,3})的调用，上面模板就起效了最后还补充了1点，在c++14的标准中，可以单独用auto去说明函数返回值/lambda表达式的形参需要推导，但此时他是使用模板推导去推导的，所以说返回值不能使用大括号 条款3是decltype的使用一般的，对于大多数std的容器，其[]的使用会返回对应位置的元素的引用，除了vector以外，而在c++14中，正如在条款2中提到的，我们可以只使用auto不加decltype去推导返回值类型，此时使用的是模板类型的推导，那以下代码就有问题了 12345678template&lt;typename container, typename index&gt;auto getindex(container &amp; c,index i){ return c[i];}... std::vector&lt;int&gt; vec {3,4,4}; getindex(vec,2) = 10; ... 上面的代码执行如下：首先这里采用的是模板推导，且auto没有&amp;或者&amp;&amp;的修饰，即采用条款1种的第3种规则，此时型参的一切引用都会被忽略，即c[i]返回的int&amp;被看成是int，那么T和paramtype就是int了，此时返回的是1个临时值，是个右值，不能放在等号左侧，所以很明显他会报错 12error: lvalue required as left operand of assignment getindex(vec,2) = 10; 解决方法是把auto改成decltype（auto），告诉他说推导过程用的是decltype的规则，而他对于int&amp;就是推导为int&amp;，或者我们直接使用后置类型推导，也比较清晰那这里还有1个不完美的在于，getindex他只能接受1个左值容器，对于一些右值容器，比如说一些工厂函数的返回值，我们直接传入，此时需要用万能引用和完美转发去解决 1234template&lt;typename container, typename index&gt;decltype(auto) func(container &amp;&amp; c, index i){ return std::forward&lt;container&gt;(c)[i];} 除此之外，decltype还有一个坑，如果decltype（sth），sth仅仅只是1个变量名，如x，一切如旧；但假如sth是(x),c++仍把他看做是左值表达式，此时decltype必须推导出是一个引用类型，那么对下列代码 1234decltype(auto) func(){ int x = 2; return (x);} 他会返回1个局部变量的引用，这是一个危险的未定义行为，所以使用decltype一定要小心，里面的东西到底是什么","link":"/2022/09/12/effective-modern-c-1-3/"},{"title":"effective modern c ++ 4-6","text":"条款4是教如何去获取类型推导结果的，第一种就是利用IDE去获取，第2种我们可以声明一个类模板但不去定义他，然后使用decltype(x)让编译器报错，如下 12345678template&lt;typename T&gt;class TD;int main(){ const int x = 3; TD&lt;decltype(x)&gt; xtype;} 此时编译器报错如下： 12error: aggregate ‘TD&lt;const int&gt; xtype’ has incomplete type and cannot be defined TD&lt;decltype(x)&gt; xtype; 可以看到x的确被推导为const int还有1种就是使用type_info,在大多数情况下他是正确的，但他推导的方式是安值推导的，也就是说，引用和常量性会被忽略，所以他并不可靠， 接下来是条款5，是开始了第2大章，关于auto的使用条款5具体讲了一些应用auto带来的方便与好处第1个就是在使用iterator的时候，如下 1234567template&lt;typename It&gt;void func(It b, It e){ while(b!=e){ typename std::iterator_traits&lt;It&gt;::value_type val = *b; }} 像上面这一段，我们使用萃取去获取这个迭代器到底指向啥东西，写起来十分的拗口麻烦，我们可以利用auto直接写成auto val = *b；第2个就是使用auto来保证变量一定能初始化，解决变量未初始化的行为 12auto i; // 不能通过auto i = 2; 第3个就是使用lambda表达式时，这个lambda对象到底是个什么类型，这个是由编译器决定的，所以我们需要利用auto用来把lambda表达式赋值给某个变量名，如 1auto lam = [](){ return 0; }; 当然我们也可以用一个std::function去持有这个lambda，如 12std::function&lt;bool(int,int)&gt;myfunc = [](int x, int y){ return true;}; 而其缺点在于function本身就是一个对象，他本身就是需要内存的，在内存上来说auto来的更好，第4个就是对于一些硬件依赖的typename，比如unsigned，在32位上和在64位上不同的，单单指定某个变量是unsigned可能会在不同机器上带来出乎意料的结果，因此我们可以利用auto 1auto size = v.size(); 第5个还是在迭代的时候，我们对于一些容器他储存方式不熟悉带来的问题，如 1for(const std::pair&lt;std::string, int&gt; &amp;p :m){...} m是个unorder_map,他本身是由std::pair&lt;const std::string, int&gt;组成的，不是上面这种方式，也就是说，程序跑到这段代码，会复制容器里的每一个元素，然后引用再去指向这些临时对象，可想而知多非时间，而使用auto很容易就解决 1for（const auto &amp;p:m){...} 当然了，auto也是得看实际的使用场景，大多数情况下使用得当能提升我们编程的效率的条款6 介绍的是使用auto可能遇到的坑，在这种时候就得采用传统的方式了第1个，就是vector&lt;bool&gt;这个和其他vector格格不入的对象，对于一般的vector&lt;T&gt;[],他能返回一个T&amp;类型的东西，但vector&lt;bool&gt;他本身是特化过的，他底层是使用比特去表示这1个1个的bool，而c++又不能返回1个对比特的引用，所以他只能返回一个用来模拟bool&amp;的reference，即std::vector&lt;bool&gt;::reference,他能够像bool进行隐式转换，所以对下面语句 12vector\\&lt;bool&gt; vec{true,true};bool is_true = vec[0]; 这里取出来的vec[0]实际是个std::vector&lt;bool&gt;::reference，但他可以转换为bool，所以没啥问题但假如我们使用auto去声明is_true,得到他类型就是std::vector::reference了，他就不是指代第1个元素是否为true的变量了书里介绍的这种情况带来的问题在于可能出现悬空指针，例如，当我们函数的返回值是个vector时，他是个临时对象，而他实现获取第1个元素的方式，有一种实现是通过指针+偏移量的方式去获取，而我们如果使用auto is_true = bool_vectroy()[0]时，is_true和临时对象的指针指向同一个东西，而临时对象在这一句话后就解析了，那is_true就指向1个被析构了的地址了，","link":"/2022/09/12/effective-modern-c-4-6/"},{"title":"effective modern c ++ 7-9","text":"条款7开始是第3章的内容，具体就是介绍了一些c+11新特性特别好用的地方条款7介绍的是{}的优缺点，第1点好处就是他用来初始化时适合于所有情况，一般而言有4种初始化方式，如下 1234int x = 2;int x(2);int x = {2};int x{2}; 后面2种其实都是同1个，而如下代码 123Widget w1;Widget w2 = w1;w1 = w2; 这里的赋值并不是初始化，而是复制构造函数,最后的调用的也是赋值运算符的重载大括号初始化的第1点优势在于可以用其初始化容器 1vector&lt;int&gt; vec {1,3,4}; 第2点是可以用来给非静态成员赋初始值 12345678class A{private: int x{2}; int y = 0; int z(0); //error! }; 第3点是可以用来给不可复制的对象进行初始化，如下 123std::atomic&lt;int&gt; x = 0; //error!!!std::atomic&lt;int&gt; y{2};std::atomic&lt;int&gt; z(0); 从2和3点可以看出，只有大括号初始化在这些情况下是可以通用的，所以说大括号是一种大一统初始化的方式大括号还有1种特性，括号内是不能使用窄式类型转换的，如 12doube x, y, z;int sum1 {x + y + z}; 上面不能确定double之和能不能用int表示 大括号的第4点好处是避免了很烦人的解析语法，如 1234Widget w(10);Widget w;Widget w();//变成函数声明了Widget w{}; 上面第3行本想用无参构造函数，结果却声明了一个返回值是Widget的无参函数，使用第4行的方式就能避免这种麻烦了而使用{}的缺点在于类的构造函数的选择问题上，如果构造函数的型参有std::initializer_list且传进来的参数有机会匹配到（有机会包括进行窄式类型转换），那么他会直接忽略其他任何的构造函数，不管说这些构造函数会多匹配如下 123456789101112class A{public: A(int x_, double y_):x(x_), y(y_){} A(std::initializer_list&lt;bool&gt; list){}private: int x; double y;};int main(){ A a{10,0.5};} 以上代码会报错， 1error: narrowing conversion of ‘10’ from ‘int’ to ‘bool’ inside { } [-Wnarrowing] 虽然有一个完美符合a的构造函数，但因为编译器看到了能使用initializer_list的希望，他就直接忽视了其他构造函数了甚至说以下代码 12Widget w{w2};Widget w3{std::move(w)}; 本来会使用复制构造函数和移动构造函数的，但如果有上述条件。他还是会调用initializer_list只有当真的没办法匹配到这个initializer_list型参的构造函数的时候，其他构造函数才会成为候选最后1个问题就是上面的无参构造函数了，在使用{}的时候表示的是无参，而不是没有元素的空的初始化列表，如果想表示后者，应该这么写 1Widget w{{}}; 而（）和{}的区别，也导致说初始化容器的时候，可能会有意想不到的结果，如下 12vector&lt;int&gt; vec (10, 20);vector&lt;int&gt; vec2 {10, 20}; 第1个是创建了一个元素都是20.共10个的vector，而第2个则是有2个元素，分别为10和20这种接口作者认为是失败的 条款8则是介绍了nullptr这个特性，在没有他之前，我们想表示空指针需要使用0和NULL,但前者本质是一个int，不是一个指针，而NULL根据具体的实现不同而不同，但本质也是1个整形数据而不是1个指针，所以在下面的场景中，那个参数为void *的函数是永远不会被调用的 12345void func(int){}void func(void *){}void func(bool){}func(0);func(NULL); NULL可能是由long实现的，可能带来歧义，但这里本质的问题在于传入的本意是个指针，结果却调用了非指针版本的矛盾因此，nullptr登上了舞台，他不具备整型类型，永远不会像0和NULL一样被解释为一个整形，且他可以隐式转换为任何其他类型的指针，此时func(nullptr)调用的就是void *类型的func了使用他的优点是在使用auto的场景下，到底一个变量是整数还是空指针，这个在有nullptr的情况下就很明了了 12345678auto func()-&gt;decltype(result){ if(result == nullptr){ return result; } ...} 假如这里的nullptr是0的话，auto就推导为int，但我们本意是拿result去和空指针比较，所以用上nullptr，result就一定是个指针了既然说到了auto，那模板推导也必然受益于nullptr了如下 1234567template&lt;typename T, typename P&gt;void func(T t, P ptr){ ...}func(3, 0);func(3, NULL);func(3, nullptr); 上面前2个调用会使得P被推导为int或long的整型数据，只有使用nullptr才使得P被推导为指针类型 条款9讲的是using用来声明类型别名的优势在不使用类型别名的时候，我们声明一个变量可能很痛苦，使用using就变简单多了，如下 1using MyType = std::unique_ptr&lt;std::unordered_map&lt;std::string,int&gt;&gt;; 当然我们可以使用typedef去弄别名，在上面的场景和下面这种，2者没啥区别，最多是可读性上不同 12using fp = void(*)(int ,double);typedef void (*fp)(int, double); 而using的优点在于模板的别名上，如下 12345678910template&lt;typename T&gt;using MyList = std::list&lt;T,MyAlloc&lt;T&gt;&gt;; //MyAlloc是自定义的MyList&lt;int&gt; l1;template&lt;typename T&gt;struct MyList{ typedef std::list&lt;T,MyAlloc&lt;T&gt;&gt; type;}；MyList&lt;int&gt;::type l2; 可以看出使用using比typedef方便多了，不用说去弄个struct写了一堆，而且如果想用上面的这个类型去用做类模板，using同样更加方便 1234567891011template&lt;typename T&gt;class{private: typename MyList&lt;T&gt;::type list;};template&lt;typename T&gt;class{private: MyList&lt;T&gt; list;}; 第2种就是使用using的写法，第1种既要typename又要::type，比较麻烦","link":"/2022/09/13/effective-modern-c-7-9/"},{"title":"effective modern c ++ 10-12","text":"条款10介绍的是enum的2种类型，一种是非限定作用域的enum，一种是限定作用域的enum，他们主要有以下几点不同一是作用域的不同 12enum Color{White, Black};auto White = false; 上面代码的第2行不能通过编译，因为这里的enum不带class，他的大括号里的内容的作用域会扩散出来，而下面 123enum class Color{White, Black};auto White = false;Color c = Color::White; 则不会，因为这里是限定作用域的enum,所以下面可以声明一个White二是能否隐式转换的问题非限定作用域的enum，他能转化为整数型别，甚至是浮点数，而限定作用域的则不可了，除非是static_cast去强制转换，如下 12345678enum Color{White, Black};void func(int c){ ...}Color c = White;c &gt;= 2;func(c); 上面这种代码比较诡异，为什么要拿枚举类的东西去和整数比较呢，没有啥意义，因此限定作用域的enum就禁止这种行为了三是关于能否前置声明而不定义的问题非限定枚举本来是能只声明的，但因为他的底层具体使用的数据类型是需要具体的枚举型别去确定，例如可能用char，也可能用int等，因此如果在后面，我们修改了他，整个系统就需要重新编译了而限定枚举能直接声明不定义，因为他默认底层的数据类型就是int，而非限定则没有默认值，只要我们加上默认值，也可以只声明了 1enum Color：int; 条款11介绍了delete关键词的使用场景最常见的是我们不想我们的对象能被复制，在98时直接把复制构造函数声明为private且不定义即可，到了11我们可以在后面加上=delete且放在public，另外1个就是，任何函数都能使用delete，这个应用场景如下 1234void func(int num);func('a');func(3.2);func(true); 如上，我们期望的实参是个int，但却传入了一堆不相关的，但这是允许的，因为他们还勉强能转化为int，为了明确禁止这种行为，我们可以 1234void func(int num);void func(double)=delete;void func(bool) =delete;void func(char)=delete; 这样子上面的3行函数调用会使用被删除的重载版本，也就不能通过编译了还有1种场景就是模板，我们希望当模板被某种类型的参数实例化时不能通过编译，比如说对指针类型T*,我们不希望void和char通过编译，前者因为他过于特殊，无法自增，自减，后者因为他通常是用来表示c的string，我们假定我们的模板不会处理这两种，代码如下 123456789template&lt;typename T&gt;void func(T* ptr){ ...}template&lt;&gt;void func&lt;char&gt;(char * ptr)=delete;template&lt;&gt;void func&lt;void&gt;(void * ptr)=delete; 条款12讲的是关于override的使用其最重要的使用场景在于，关于虚函数的重载，他的要求十分严格，函数的签名必须一致，const必须一致，异常必须一致（noexcept），引用修饰词也必须一致（在函数签名后加&amp;或&amp;&amp;表示这个函数是给左值对象或者右值对象调用），那么很有可能因为这些限制，我们写出来的“虚函数”实际已经丢失了虚函数的特性，而编译器有可能没有给我们提出warning，因此这个时候就需要override了，如下： 123456789class Base{public: virtual void func();};class Derived:public Base{public: virtual void func() override;}; 这样子编译器发现override的函数如果有什么不一致会报错这个条款的最后补充说明了引用修饰词的用法 123456789101112class A{public: using datatype = std::vector&lt;int&gt;; datatype&amp; getdata() &amp;{ return values; } datatype getdata() &amp;&amp; {return std::move(values);}private: datatype values;};A getA(){ return A;} 上面这段代码A这个类有2个不同的引用修饰词修饰的函数，当左值对象调用时，返回的是左值对象的左值引用，而当右值对象，例如getA()的返回值调用getData时，使用的是&amp;&amp;修饰的函数，因为临时对象本身就是要被析构的，最佳使用方式是移动他的资源，而不是复制，所以&amp;&amp;版本使用了move移动语义，而且他的返回值也不是一个左值引用了，而是一个临时值，是个右值","link":"/2022/09/13/effective-modern-c-10-12/"},{"title":"effective modern c ++ 16-18","text":"条款16讲的是对于const成员函数的线程安全性，具体而言，const成员函数只能保证不去修改那些没被声明为mutable的成员数据，那也就是说，多个线程访问同一个const函数的时候，就可能会出现data race的情况了 1234567891011121314class Poly{public: using type = std::vector&lt;double&gt;; type getroot()const{ if(valid){ ... //计算并修改root } valid = true; return root; }private: mutable bool valid{false}; mutable type root{};}; 以上代码可能在多线程下有问题，此时我们需要施加锁上去 1234567891011121314151617class Poly{public: using type = std::vector&lt;double&gt;; type getroot()const{ std::unique_lock&lt;std::mutex&gt; l(lock); if(valid){ ... //计算并修改root valid = true; } return root; }private: mutable bool valid{false}; mutable type root{}; mutable std::mutex lock;}; 不过由于mutex是不可复制的，这个类的复制行为也就应该被禁止了，不过他还是可以移动的书中还指出，如果mutable的变量只有1个，比如说某个计数器，那么我们可以直接用atomic去表示他，就不用大费周章的用锁了（虽然atomic有时候还是锁的实现），但atomic同样是不可复制的，所以该类同样只能移动而不能复制 123456789class A{public: void dosth()const{ count ++; //dosth.... }private: mutable std::atomic&lt;int&gt; count{0};}; 因为原子变量保证count++的执行是原子的，所以不用担心多线程带来的不确定性而如果需要2个以上的mutable变量，使用atomic去表示他们的策略不是明智的，例如上面的例子，如果修改root的过程是在valid后面，那么就可能发生这种情况-线程1读valid发现为false，于是计算，然后设置valid，此时线程2也使用了这个函数，发现valid是true，于是直接返回root了，但线程1还没有修改root呢，这种现象发生的原因在于修改2个原子变量的过程并不是原子的，所以我们就需要加1个互斥锁来保证修改2个原子变量这一大动作的原子性，那既然都要用互斥锁了，那还不如直接把2个mutable的声明为普通变量，反正有了锁就能保证原子性了所以总结的说，使用const成员函数时，要确保对mutable变量的操作能是线程安全的，可以通过互斥锁或者原子变量去实现 条款17说的是各种生成构造函数和生成运算符的生成规则，规则1.当没有声明任何构造函数时，会生成1个默认的无参构造函数规则2.如果没有声明复制构造函数等，在使用的时候会自动生成需要的函数上面2个规则是98时代的，在11，大家都知道引入了移动构造函数和移动运算符，而编译器自动生成的移动操作，会默认的去“移动”每一个成员变量，移动加双引号是因为这个移动是有前提的，如果成员变量本身无法移动的，例如int这种，他执行的是复制，如果这个成员提供了移动操作，才是真正的移动这个变量，而本质上是使用std::move去处理每一个变量，得到的右值如果这个成员本身有移动构造函数能处理这个右值，就是执行移动操作，否则只能使用这个变量的复制构造函数了，因为复制构造函数的形参都是const &amp;，所以能去引用1个右值，这里我们可以写个例子示范如下 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class Movable{public: Movable()=default; Movable(Movable &amp;&amp; rhs){cout&lt;&lt;&quot;movable class moving&quot;&lt;&lt;endl;} Movable(const Movable &amp; rhs){cout&lt;&lt;&quot;movable class copying&quot;&lt;&lt;endl;}};class Copyable{public: Copyable()=default; Copyable(const Copyable &amp; rhs){cout &lt;&lt; &quot;coping class copy&quot; &lt;&lt;endl;}};class A{public: A(Movable m_,Copyable c_):m(m_),c(c_){}private: Movable m; Copyable c;};int main(){ Movable m; Copyable c; cout &lt;&lt;&quot;==&quot;&lt;&lt;endl; A a(std::move(m),c); cout &lt;&lt;&quot;==&quot;&lt;&lt;endl; A b(std::move(a));} 对于复制构造函数和复制运算符，他们是独立的，声明一种不会导致说编译器不会去生成另一种，但移动的2个操作就不同了，如果声明了其中的一种，编译器则不会去生成另外1个了，因为他会认为既然你自己实现的移动构造函数与默认的按数据成员移动的方式不一样，那么默认的移动运算符必然也与之不同，那还不如不生成进一步的，复制操作和移动操作，只要定义了其中的一方，编译器就不会去生成另一种操作了，因为既然声明了其中的1种，说明对于另外1种来说，其实现方式也很有可能与默认的方式不同，编译器就采用这种思想。接下来提到的是一个大三律的东西：复制构造函数，复制运算符和析构函数，只要声明了其中的一种，就应该实现另外的2个，其思想在于，我们之所以会去刻意地定义他们，是因为某些类成员函数的复制方式不同于默认的复制方式，例如说某些指针型的，例如说和资源管理相关的，那么析构函数也必须处理如何析构这些资源从这个定律推出来，如果有了用户声明的析构函数，就说明默认生成的复制操作是不合用户心意的，因此编译器不应该自动生成，不过98的时代这个思想没有被编译器采纳，但到了11，移动操作应用于这种思想导致了——一旦用户声明了析构函数，移动操作就不会被自动生成所以结合以上内容，如果想要自动生成移动操作，需要：1.不能声明复制操作2.不能声明移动操作3.不能声明析构函数接下来我们可以写一个类，这个类只有1个vector的成员，如下 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class A{public: A(){} vector&lt;int&gt; vec;};int main(){ A a; a.vec.push_back(2); a.vec.push_back(3); A c = move(a); cout &lt;&lt;a.vec.size()&lt;&lt;endl;} 当没有声明析构函数的时候，最终a的vec的size是0，的确是有移动操作在里面，但假如声明一下析构，最终输出是2，说明移动构造函数的确没有自动生成，假如这个vec的内容很多，这个复制的时间必然是多于移动的，此时我们简单的加上A(A&amp;&amp;)=default即可当然了，有时候我们声明析构函数，是因为需要某个类作为基类，必须得声明他的析构函数并且声明为虚函数提供多态的特性，此时我们可以在那些无法自动生成的移动操作加上=default，告诉编译器这个移动操作使用默认的生成式可以的所以最后总结如下• 默认构造函数：与 C++98 的机制相同。仅当类中不包含用户声明的构造函数时才生成。• 析构函数：与 C++98 的机制基本相同，唯 的区别在千析构函数默认为noexcept （参见条款 14) 。与 C++98 的机制相同，仅当基类的析构函数为虚的，派生类的析构函数才是虚的。• 复制构造函数：运行期行为与 C++98 相同：按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造函数时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制赋值运算符或析构函数的条件下，仍然生成复制构造函数已经成为了被废弃的行为。• 复制赋值运算符：运行期行为与 C++98 相同：按成员进行非静态数据成员的复制赋值。仅当类中不包含用户声明的复制赋值运算符时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制构造函数或析构函数的条件下，仍然生成复制赋值运算符已经成为了被废弃的行为。• 移动构造函数和移动赋值运算符：都按成员进行非静态数据成员的移动操作。仅当类中不包含用户声明的复制操作、移动操作和析构函数时才生成。 接下来进入的是第4大章，关于智能指针的使用条款18讲的是unique_ptr我们可以认为一个uniqueptr和野指针有几乎一样的尺寸，且他不能复制，因为本身他的实际应用场景就是管理专用型资源的，而且他的构造函数也使用了explicit修饰，不能使用隐式类型转换去构造如下 12345unique_ptr&lt;int&gt; p1(new int(3));unique_ptr&lt;int&gt; p2 = new int(3);unique_ptr&lt;int&gt; p3{nullptr};p3 = p1;p3 = move(p1); 第1行是拿一个野指针做参数构造p1，行的通；但第2行是想执行1个隐式类型转换，把int*转换为unique_ptr,这个是行不通的,而第4行自然也error，只有第5行才可以，此时p1的资源就给p3管理了unique_ptr可以自定义删除器，而且必须得把第二个模板参数声明为这个删除器，所以不同删除器的同个管理对象的类型是不同的，这个shared_ptr就不是了，如下 123456789101112131415161718192021class Investment{public: ... virtual ~Investment(){}};class Stock : public Investment{...};class Bond: pulibc Investment{...};auto MyDelete = [](Investment * ptr){dosth; delete ptr;}template&lt;typename ...Ts&gt;unique_ptr&lt;Investment, decltype(MyDelete)&gt;func(Ts&amp;&amp;... params){ unique_ptr&lt;Investment,decltype(MyDelete)&gt; p (nullptr,MyDelete); if (/*need stock*/){ p.reset(new Stock(forward&lt;Ts&gt;(params)...)); } else{ p.reset(new Bond(forward&lt;Ts&gt;(params))); } return p;} 上面代码的注意点：我们使用自定义的删除器，则需要指定unique_ptr的第2个模板实参，且在创建该对象时将删除器传入第二个参数后面的赋值操作并不能通过=的方式，原因上面提到了，需要使用reset函数去转换其管理的对象而使用了自定义的删除器后，如果我们用的删除器是函数指针，这个unique_ptr的尺寸就比一般的野指针要大了，因为它还要储存函数指针，而如果是无捕获的lambda表达式，作者说是不会浪费任何空间的，这里有待了解详情。","link":"/2022/09/14/effective-modern-c-16-18/"},{"title":"effective modern c ++ 13-15","text":"条款13介绍的是const_iterator，一开始一大段介绍了在98中实现一个const_iterator有多么困难，但到了11，一切都迎难而解 12345vector&lt;int&gt; vec;auto it = std::find(vec.cbegin(),vec.cend(),13);vec.insert(it,16); 我们可以使用cbegin()cend()来获取容器的const 迭代器，就算是对非const容器也一样，且insert函数他的第一个参数是const_iterator,这样子就满足他的要求了除此之外有一点要注意的是，c++11提供了非成员函数的begin，end等函数，为的就是满足容器是数组的情况下的需求，但11并没有提供cbegin或者cend等const函数，我们无法在只依赖std库的情况下做到const遍历数组，因此我们可以这么写 1234template&lt;typename T&gt;decltype(auto) cbegin(const T&amp; container){ return std::begin(container);} 把传进来的容器用const修饰，那么我就能用他去获取cbegin了，当然这种多余的步骤在14的时候就没必要了，14的时候就引入了非成员的cbegin，cend等函数 条款14介绍的是关于异常和noexcept关键字，在11的标准里，一个函数要么可能发射异常，要么保证不会发射异常，如果能确保他不会发射异常，我们就应该加上noexcept关键字，有关异常的知识我也不是很了解，作者这里介绍说加上noexcept比其他方式优化更好也不是很理解，等后续补坑接着是几个标准库里和异常相关的函数，最重要的就是push_back函数，当需要扩容时，原本的版本是强异常安全性的——直到所有元素都复制到了新的内存上，旧内存上的元素才会析构，如果中途抛出了异常，则没啥事；但如果为了优化复制转而使用移动，假设我们已经移动了一部分元素了，但此时抛出了异常，程序就处在一部分元素在新的内存，一部分在旧的内存，原有的状态已经没有了，如果想恢复到原来的状态转而把移动过的元素移动回去也可能异常，而11的很多函数的实现，为了解决这种麻烦，采取的是“能移动就移动，不能移动才复制”的策略，而判断移动是不是安全就看这个操作有没有noexcept，其中有一部分的函数，例如swap他是否异常安全，完全取决于用户自定义的操作是否带有noexcept，具体例子如下 12template&lt;class T, size_t N&gt;void swap( T(&amp;a)(N), T(&amp;b)(N)) noexcept(noexcept(swap(*a,*b))); 上述代码中，noexcept这种使用方式称为条件式noexcept，只有当括号内T的swap的操作，也就是对a这个数组的每一个元素都进行swap操作时时noexcept的，括号里的结果就为true，此时外层的swap就也是保证异常安全了的 条款15介绍的是constexpr关键字，他表示的变量必须是个常量，且必须在编译期就能确定下来具体是什么值，这个一个值可以用在声明数组长度，array的模板实参（长度）等必须在编译阶段就已知的常量值，如下 12constexpr int len = 2;std::array&lt;int, len&gt; arr; 而const修饰的，他并没有会在编译期就知道具体值的保证，所以并不能把他用在array这种模板形参上constexpr还可以修饰函数，不过此时就有点复杂了，如果传入的实参是编译期就能确定的常量值，那他必须保证该函数也能在编译期得到对应的结果，但如果传入的参数有1个是直到运行期才知道结果的，此时的函数就和一般的函数一样了，如下 12345constexpr int pow (int base, int numconds){ ....}constexpr auto numconds = 5;std::array&lt;int, pow(3,numconds)&gt; arr; 以上代码可以通过，因为2个参数都是编译期就知的常量，因此pow也能在编译期返回具体的值了而上面pow的….的具体实现与版本有关，在c++11下，constexpr函数最多只能有1条可执行语句，因此得这么写 1return numconds=0? 1:base*pow(base,numconds-1); 而在c++14下这个限制就放开了，可以按一般的for循环去实现了 除了内置类型可以声明为constexpr外，我们自定义的类也可以将构造函数以及其他成员函数声明为constexpr，这样子就能在编译器完成相关的语句执行了，如下 1234567891011121314151617class Point{} constexpr Point(double x_ = 0.0, double y_ = 0.0):x(x_),y(y_){} constexpr getx(){return x;} constexpr gety(){return y;}private: double x,y;;constexpr getmid(Point x1, Point x2){ return Point((x1.getx() + x2.getx()) / 2, (x1.gety() + x2.gety()) / 2);}int main(){ constexpr Point x1(5.3,2.3); constexpr Point x2(2.2,34.2); constexpr Point mid = getmid(x1,x2);} 以上的x1和x2都能在编译阶段都确定下来具体的值，mid也是","link":"/2022/09/14/effective-modern-c-13-15/"},{"title":"effective modern c ++ 19-21","text":"条款19讲的是shared_ptr的使用，他的实现大多数都是使用1个指向被管理资源的野指针+1个指向引用计数的对象的指针实现的，所以他的尺寸一般都是野指针的2倍被管理的资源并不知道这个引用计数的存在引用计数的内存也是动态分配管理的，其计数的增减也必须都是原子操作，而在自定义删除器上，shared_ptr并不需要指定他的模板形参为这个删除器的类别，因此我们可以用容器且类别为shared_ptr的方式去管理，而且不管这个删除器有多大，他都不会影响shared_ptr的大小，因为他是在引用计数那个对象上管理的，如图！{}()而这个控制块的生成时机，具体而言有以下几种1是使用make_shared的时候，必然是在构造一个新的shared_ptr,此时也得有一个控制块的生成2同理，给一个shared_ptr的实参是野指针的时候，也要1个新建的控制块，而如果传入的实参是1个shared_ptr的话，新的对象则是直接使用这个控制块而不是新建3是在用1个unique_ptr出发构建的时候，也是需要控制块的，因为unique_ptr本来就没有这玩意所以，在新建shared_ptr的时候，切记不要将1个野指针用于多次构造函数中，因为这样会产生多个控制块，如果控制块发现自己的计数是0的时候，就会析构这个对象，而这就会导致对象被析构多次，如下代码 123456789101112131415161718#include &lt;memory&gt;using namespace std;class A{public: A(){x=new int(0);} A(int _x):x(new int(_x)){} ~A(){delete x;} int * x;};int main(){ A *ptr = new A(3); A *ptr2 = new A(3); shared_ptr&lt;A&gt; p1(ptr); shared_ptr&lt;A&gt; p2(ptr); shared_ptr&lt;A&gt; p3(ptr2); p1 = p3; p2 = p3;} 上面的代码，对同1个对象ptr析构了2次，虽然能编译成功，但运行起来直接报错，所以，我们应该把ptr的new直接放在shared_ptr的构造函数里，这样子别人也就只能拿shared_ptr去做自己的构造函数的实参了，而这样子是不会创建新的控制块的还有1种情况，就是关于this指针的，如下代码会犯和上面的一样的错误 12345678910vector&lt;Widget&gt; processed_list{};...class Widget{ ... void process(){ ... processed_list.emplace_back(this); }};这里emplace_back会以this指针为参数去构建一个新的shared_ptr,而这个this指针很明显是一个野指针，也就是说，他会创建1个新的控制块，此时就像上面这种情况一样了，c++提供了enable_shared_from_this的玩意，使用起来如下： vector processed_list{};…class Widget:public enable_shared_from_this{ … void process(){ … processed_list.emplace_back(shared_from_this()); }}; 12当当前的对象已经被1个shared_ptr管理时，shared_from_this这个成员函数就能创建1个新的shared_ptr对象，且使用已经存在的控制块，否则会报异常条款20当然就是讲智能指针剩下的weak_ptr了，这个也是第1次了解他，因为之前觉得那2个指针就够用了捏。他主要是配合shared_ptr使用，最主要的功能是判断所管理的对象是否已经析构，如下代码 auto ptr1 = make_shared(3);weak_ptr wptr(ptr1);ptr1 = nullptr;cout &lt;&lt;wptr.expired()&lt;&lt;endl; 123上面的代码wptr这一行并不会改变ptr1所管理的对象的引用计数，第2行之后，其引用计数仍然为1，在第3行后为0后便析构了,因此我们可以使用weak_ptr的expired函数判断，其指向的资源是否已经析构，上面的代码为输出1而我们往往会想利用这1特性，去做出1个若未析构则访问的操作，但很明显这个操作并不是线程安全的，因为他不是一个原子操作，假如他expired后发现未析构，而另外1个线程执行了上面第3行的类似的操作，则会有未定义的行为了weak_ptr提供了lock（）来实现这种原子操作， shared_ptr ptr2 = wptr.lock(); 123如果该资源已经析构，ptr2为空后面作者具体给出了使用weak_ptr了场景第1个就是在某些工厂函数中，他对相同的输入下标id会有相同的输出，为了提高性能，一个直接的想法是使用智能指针去管理资源，当之前已经创建过这个资源，就直接返回该资源，具体代码如下 shared_ptr get_widget(int id){ static unordered_map&lt;int, weak_ptr&gt; cache; auto sptr = cache[id].lock(); if(!sptr){ //generate Widget for this id and use sptr to manage it cache[id] = weak_ptr(sptr); } retrun sptr;}这里的返回类型并不能使用unique_ptr,因为一旦返回了，这个工厂函数内部的那个unique_ptr就为空了，因为返回值是通过移动构造去移动了资源的管理权第2个就是在观察者设计模式中，这里具体等后面学设计模式再探讨吧！最后1个就是1个小例子，假设a和c都使用shared_ptr指向b，此时想要让b也能指向a，该使用什么指针呢，很明显shared_ptr是不能使用的，他最大的缺点就是在这种环路引用上的循环问题，野指针也不行，若a析构了，b的野指针无法得知，后面就可能做出未定义行为了，所以最优的方式是使用weak_ptr,a是否析构b能感知到，且weak_ptr不会对引用计数有任何影响，更准确的说，是不会对控制块的第1个引用计数有影响，而是对其第2个引用计数有影响条款21讲的是尽量使用make_shared和make_unique在11的标准中，是只有前者而没有后者的，我们当然可以容易实现 1234template&lt;typename T, typename ...Ts&gt;unique_ptr&lt;T&gt; make_unique(Ts&amp;&amp;... params){ return unique_ptr&lt;T&gt;(new T(forward&lt;Ts&gt;(params)...));} 首先是创建了一个T的对象，利用万能引用和完美转发将参数传入其构造函数，并使用unique_ptr去管理并返回到了14我们就有std的make_unique可以用了下面作者给出了使用make系列函数的优势点第1个是定义相关类型的时候，如下 12unique_ptr&lt;Widget&gt; ptr1 (new Widget(params));auto ptr2 (make_unique&lt;Widget&gt;(params)); 作者认为这里，第1行使用了2次widget，将这个型别声明了2次，造成了代码冗余，导致源代码会增加编译次数第2个优点在于异常安全，例如下面的代码 12345int calculate(){...}void process(shared_ptr&lt;Widget&gt;, int priority){...}process(shared_ptr&lt;Widget&gt;(new Widget), calculate()); 这里编译器只能保证，在进入process的代码段之前，构建一个widget对象，构建1个shared_ptr并管理这个widget对象，调用calculate函数3者一定执行完毕，但这3者的顺序并没有指定，如果calculate发生在另外2着中间并且发生了异常，会导致new出来的widget并没有被析构而导致了内存泄漏，这个其实在effective第一本书里有讲，我们可以直接在process调用之前就构建这个shared_ptr对象，并在process的传参中使用move()语义，移动该资源，这样子就没有任何复制操作了，如果只是把这个对象按值传进去可是需要对引用计数进行原子操作的增加的。而这里采用的是使用make_shared，因为这样子就能保证new出来的对象一定能被shared_ptr管理，就算calculate异常了也没关系第3个是在性能上的提升，对于make_shared来说，他只会分配1次内存块，这个内存块就可以用来为widget和控制块分配内存，而传统的方式是需要分配2次内存块，分别给2着用而make系列也不是完美的，在某些情况下他并不适用，比如说，他并不允许自定义删除器，只有一般方式如下 12unique_ptr&lt;int,decltype(mydelete)&gt; ptr1(new int(2), mydelete);shared_ptr&lt;int&gt; ptr2(new int(3), mydelete); make系列的函数是做不到这一点的还有1个就是他对大括号初始化的不支持如下代码 1auto ptr = make_shared&lt;vector&lt;int&gt;&gt; (10,20); 他在完美转发的时候是使用得当圆括号，也就是说调用的是非initializer_list形参的构造函数，上面的代码生成的是10个元素，每个元素都是20的vector的shared_ptr,但假如我们想用大括号初始的方式呢，就得这么做 12345shared_ptr&lt;vector&lt;int&gt;&gt; ptr1 (new vector&lt;int&gt;{10, 20});//传统方式auto ini_list = {10, 20};auto ptr2 = make_shared&lt;vector&lt;int&gt;&gt;(ini_list); 这样子，就能在完美转发的时候转发的是1个initializer_list形参，也就能调用相关的构造函数了 除了以上2个问题外，对于一些自定义了new和delete的类来说，因为他们通常分配的内存块大小都是等于1个类的大小的，而make系列分配的内存的大小还需要加上控制块的大小，此时使用make就不是1个好主意了还有就是由于weak_ptr的存在，一个使用make系列函数分配的内存块，他内部有被管理资源的内存和控制块的内存，只有当和其相关的shared_ptr和weak_ptr都没有了的时候才会释放内存，而普通的构造方式下，只要shared_ptr没了，被管理资源就会被析构，此时的weak_ptr只会影响控制块的析构，","link":"/2022/09/15/effective-modern-c-19-21/"},{"title":"effective modern c ++ 22-24","text":"接下来进入第5大章，也就是右值，移动语义和完美转发等一系列11中最重要的一大特性领域条款23讲的是move和forward这2个最常见到的2个函数，他们的本质只不过是进行了强制类型转换，前者无条件的把传进来的参数转换为右值，forward则是在某种特定条件下才把参数进行转化，move的实现大致如下 1234567template&lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp;move(T &amp;&amp; params){ using ReturnType = typename remove_reference&lt;T&gt;::type&amp;&amp;; return static_cast&lt;ReturnType&gt;(params);} 这里返回值是个右值，且为了不会因为传进来的是左值以及引用折叠导致说返回的变成了左值，需要使用remove_reference传给一个函数，或者构造函数一个move后的右值，往往是想进行移动的操作，所以才叫做move不过一个move的东西，他有时候不一定会进行所谓的移动操作，假如说一个函数他的参数是const的，接着我们调用move把这个参数从const &amp;变为了const &amp;&amp;，但此时他也只能匹配到复制构造函数了，因为移动构造函数只能接受非常的右值参数forward的使用场景也是十分的经典了，就是在万能引用下，因为引用本身是个左值了，所以如果把万能引用的参数传入某个函数，永远也只会调用这个函数的左值版本，如下 123456789101112131415161718192021void func(int &amp; num){ cout &lt;&lt; &quot;left&quot; &lt;&lt; num &lt;&lt; endl;}void func(int &amp;&amp; num){ cout &lt;&lt;&quot;right&quot; &lt;&lt; num &lt;&lt; endl;}template&lt;typename T&gt;void interface(T&amp;&amp; params){ func(params); func(forward&lt;T&gt;(params));}int main(){ int i = 2; interface(i); cout &lt;&lt; &quot;----&quot; &lt;&lt; endl; interface(3);} 两者的作用看上去似乎十分相似，但其实是十分泾渭分明的，move明确指定了要把参数转换为右值，为相关的移动操作做准备，但forward只是转发，参数是左值就转发为左值，是右值就转发为右值，2者并不是作用可以被一方替代的关系条款24讲的就是万能引用和右值引用的相关内容了万能引用最主要的2个使用方式就是如下 1234template&lt;typename T&gt;void func(T &amp;&amp; params){...}auto &amp;&amp; x = sth; 其最本质的，就是涉及到了型别推导，所以如果遇到具体的类，如Widget&amp;&amp;,他就只是1个简单的右值引用，因为他根本就没有型别推导而且这里的型别推导也必须得限制住，必须得是T&amp;&amp;的形式，其他的就不行了，如下 123template&lt;typename T&gt;void func(vector&lt;T&gt;&amp;&amp; params){...} 上面的params是个右值引用，而且，即使是加上const关键词，也会导致其不是一个万能引用而且就算是已经","link":"/2022/09/15/effective-modern-c-22-24/"},{"title":"effective modern c ++ 25-27","text":"条款25讲的还是move和forward的具体使用场景的对比，当明确要使用移动语义时用move，要使用完美转发时使用forward作者一开始就警告，千万不能在本应该使用forward语义的地方使用move，因为极有可能吧1个左值的内容移动到了调用方，此时的左值就肯定不能被使用了，但这并不是我们需要的实现了万能引用的函数模板如下： 123456789class Widget{public: template&lt;typename T&gt; void setname(T&amp;&amp; newname){ name = forward&lt;T&gt;(newname); }private: string name;}; 我们当然可以提供非模板的setname函数，因为若我们有保证当进来的是左值时不去修改他的要求时，需要把形参声明为const，而此时就不是完美引用了，因为其不能有任何限定词，代码如下 123456void setname( const string &amp; newname){ name = newname;}void setname(string &amp;&amp; newname){ name = std::move(newname);} 但这种重载的实现方式有几个问题，1是当我们传进来1个字面量，如setname(“my”)的时候，如果是万能引用+完美转发的做法，这个字面量就直接传到赋值那一行用于构造name了，就像执行name = “my”一样，而重载的右值引用版本，需要首先构造一个临时string对象，再把临时对象的值移动到name中，然后析构这个临时对象，这就可能带来性能效率上的问题；第2个问题就是，如果函数的参数有多个，那要重载的版本就呈指数爆炸的个数了，例如make_shared函数，其声明可以简化如下： 1234template&lt;typename T,typename ...Args&gt; shared_ptr&lt;T&gt; make_shared(Arg&amp;&amp; ...args){ return shared_ptr&lt;T&gt;(forward&lt;T&gt;(args)...); } 在这种情况下，重载肯定是1个很费力气的操作。接下来讲的是1个小原则——当我们对1个变量想使用move语义或者forward时，得保证之后不会再用这个对象，也就是说，只有在最后1次与该变量相关的语句中才能使用move/forward，这个就不用具体解释了。接下来就是讲按值返回的函数中对移动语义的使用了，这里我们需要分为2种情况第1种情况是，如果这个返回的内容，本身就是一个引用，不管是什么引用，都要在return语句使用move/forward，如下 1234Matrix operator+(Matrix &amp;&amp;lhs, Matrix&amp; rhs){ lhs += rhs; return move(lhs);} 假如不使用move，那在return的时候是的的确确会构造一个匿名对象然后再把这个对象的内容复制到返回值的储存位置，而加了移动语义，他就简单的把lhs这个右值移动到返回值的地方，还有可能的场景如下： 12345template&lt;typename T&gt;T func(T&amp;&amp; t){ dosth; return forward&lt;T&gt;(t);} 这样子当t是右值的时候，就能直接把他放入返回值的地方，而是左值的时候才会有复制的成本第2种情况是返回一个局部对象，这里编译器会有一种优化叫做(return value optimization），RVO,即直接在返回值的位置上去创建这个局部变量，从而省去了构造匿名对象并复制的成本而编译器使用到这个优化的条件非常的苛刻，他需要满足2个条件，1个是局部变量必须和返回值类型一样，这就是说不能有隐式转换在里面，二就是返回的就是局部变量本身，此时假如我们加上了move语义，就相当于返回了一个局部变量的右值引用了，就不满足RVO条件了，这反而是破坏了优化的可能性，而针对这条优化原则，还有相关的补充——如果满足了RVO条件，要么保证不复制（直接放到返回值），要么返回一个右值对象，即和使用move语言一样的效果。那也就是说，不使用move可以达到优化的效果，因为他的确有使用右值语义的机会，但使用了move则破坏了RVO的条件，这反而帮了倒忙条款26介绍的是避免依万能引用型别去重载，意思就是说，对于一个使用了万能引用作为参数的函数模板，我们要避免去重载同名的函数，具体的例子如下 12345678910template&lt;typename T&gt;void func(T&amp;&amp; t){ dosth...; string temp (t);}void func(int t){ dosth...; string temp;} 这样子的话，对下面的函数调用，编译是可以通过的 12345func(&quot;wm&quot;);string w(&quot;ww&quot;);func(w);func(string(&quot;new&quot;));func(3); 万能转发避免了许许多多的复制操作，这个是我们的的确确得到的好处，但有时候会有需要传入别的类型的参数的需要，此时我们的直觉就是去重载这个函数，让他来处理某些特定的形参的情况，但这里就有问题了，如下 12short i = 3;func(i); 由于调用int版本的重载函数不是完美匹配的，因为还需要隐式类型转换，而函数模板可以实例化出1个完美匹配的模板函数出来，这个叫精确匹配，精确匹配是优先于其他版本的，所以会调用函数模板的那个版本，而这时候问题来了，string并不能接受任何形式的short形参，编译就失败了问题在于函数模板是十分”贪婪”的东西，只要是他实例化出来的函数就激活都能看做是完美匹配的，也就导致了对short类型的形参无法匹配到int还有1个例子就是在类中使用万能引用函数模板作为构造函数的，如下 1234567891011121314151617class Widget{public: template&lt;typename T&gt;{ Widget(T &amp;&amp; n){ name = n; } } Widget(int n){ name = &quot;e&quot;; }private: string name;};Widget w(1);auto Widget(w); 以上代码会报错，错在找不到1个=运算符，其左右操作数分别为char*和Widget的，也就是说，他这里调用了万能引用的构造函数，可是这里编译器明明是会自动生成复制构造函数的，结果却调用了别的东西。这里的原因还是因为万能引用的“贪婪”，在传入参数是w，也就是Widget的情况下，他既可以实例化widget的构造函数，T为Widget，也可以使用默认的复制构造函数，但这个构造函数的函数的参数是const Widget&amp;，也就是说他并不是完美匹配的，此时编译器就会去找实例化后的模板函数了，也就出现了一个把n（Widget）类型的变量赋值给name（String）的情况，自然会报错但如果w是个const，自然的复制构造函数也完美匹配了，此时c++的标准规定，要优先使用非模板的函数，也就是说此时编译是可以通过的，但这样也莫名其妙地多了常量性进一步的，在派生类中，万能引用更是会使得程序的错误更加难以推测，如下 12345class Derived: public Widget{public: Derived(){} Derived(const Derived&amp; d):Widget(d){}}; 这段代码会报错，因为在派生类的复制构造函数里，Widget(d)的语句会由于实例化后的模板比基类的复制构造函数（要把d转化为widget类）更加完美匹配，所以就调用了实例化后的构造函数，string类本身肯定是没有derived为参数的构造函数的，肯定过不了编译所以以上的例子想说明的是，尽量不要在重载函数中使用万能引用接下来的条款27想解决的就是假如真的需要万能引用做重载函数的形参时，具体的可行方案有舍弃重载，传值，用常量左值引用做形参等，接下来就是本条款的重点——用标签分类，他的思想在于，上述的万能引用，由于对大多数传进来的参数，他都能实例化出1个完美匹配的模板函数出来，那只要我们能做到，对于某些特定的类型，只要他在传进来这个类型后无法实例化就能解决问题，而这可以通过增加1个标志位形参来做到，这个标志位可以利用std::is_integral()做到，具体的初步修改如下 12345template&lt;typename T&gt;void interface(T&amp;&amp; params){ impl(forward&lt;T&gt;(params), std::is_integral&lt;T&gt;());} 上面的这段代码，他是把所有的参数都用interface去接受，在内部再根据类型去派发具体的实现，这里后面肯定是需要2个impl的接下来是需要对这个函数去修改他不合理的地方，1是关于万能引用和引用折叠，如果传进来的参数是左值的话，T就会推导为type&amp;的形式，例如int&amp;，那标志位就会判断为false了，所以我们就需要利用std的移出引用的特性remove_reference了，如下 12345template&lt;typename T&gt;void interface(T&amp;&amp; params){ impl(forward&lt;T&gt;(params)), std::is_intergral&lt;typename std::remove_reference&lt;T&gt;::type&gt;());} 其中上述的方括号里的内容可以直接用std::remove_referenct_t代替，因为这个就是使用了using写的类型别名，不用写typename指明他是类型，接下来就是去写具体的实现函数了，我们需要利用std::false_type和std::true_type去做2个实现函数的标志位，因为true和false是运行时的东西，而我们需要的是一种能在编译期就告诉我们如何重载决议的东西，就是上面的2个*_type了，如下 123456789template&lt;typename T&gt;impl(T&amp;&amp; params, std::false_type){ cout &lt;&lt; &quot;this is not integral&quot; &lt;&lt; endl;}template&lt;typename T&gt;impl(T&amp;&amp; params, std::true_type){ cout &lt;&lt; &quot;this is intergral&quot; &lt;&lt; endl;} 到了这里，标签分类的具体内容就ok了，这些其实都算是模板元编程的东西，不过还没学2333，后续再开个坑吧接下来的另外1个方式是使用enable_if,让万能引用的函数模板在某些条件下禁止实例化，这里我们继续，先写1个初步使用该特性的例子 1234567class Person{public: template&lt;typename T, typename = enable_if&lt;condition&gt;::type&gt; Person(T&amp;&amp; params){ ... }}; 那么当括号里的condition为true的时候，这个实例化才被允许接下来我们就需要写出这个condition，我们需要在入参是person的时候调用的是复制构造函数而不是实例化的模板构造函数，所以我们可以搭配std::is_same&lt;Person,T&gt;来判断，当然了这里同样的和上面有一样的问题，如果T实例化之后有引用/const/volatile等修饰，这个判断就为假了，所以我们需要移除这些特性，可以使用std_decay，这里我们可以简单的理解为std::decay::type就是我们需要的东西了因此该condition可以写为&lt;!is_same&lt;Person, std::decay::type&gt;::value上面的写法解决了person本身的一个构造函数的重载决议问题了，但对于其派生类来说，当入参是派生类derived时，还是会调用基类模板构造函数而不是基类的复制构造函数，因为derived明显不是person类，解决方法就是使用is_base_of替代is_same即可，即is_base_of&lt;Person,typename = enable_if&lt;!is_base_of&lt;Person,std::decay::type&gt;::value&gt;::type&gt;这里看上去一大串，还是比较难读的，当然我们可以使用14标准的那些别名，如下is_base_if&lt;Person,typename = enable_if_t&lt;!is_base_of&lt;Person,decay_t&gt;::value&gt;总的来说，我们可以使用标签或者enable_of这2个现代c++特性去实现重载模板函数的决议","link":"/2022/09/20/effective-modern-c-25-27/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"c+2","slug":"c-2","link":"/tags/c-2/"},{"name":"tvm","slug":"tvm","link":"/tags/tvm/"},{"name":"小组件","slug":"小组件","link":"/tags/%E5%B0%8F%E7%BB%84%E4%BB%B6/"},{"name":"leveldb","slug":"leveldb","link":"/tags/leveldb/"},{"name":"effective_modern_c++","slug":"effective-modern-c","link":"/tags/effective-modern-c/"}],"categories":[]}