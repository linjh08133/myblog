<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="lin"><title>Hexo</title><meta name="description" content="this is my blog. love furry 捏"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a class="current" href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Hexo</a></h3><div class="description"><p>this is my blog. love furry 捏</p></div></div><ul class="social-links"><li><a href="mailto:275911105@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=275911105"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span>  </span><i class="fa fa-star"></i><span> lin</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/14/effective-modern-c-16-18/">effective modern c ++ 16-18</a></h3></div><div class="post-content"><div class="card"><p><p>条款16讲的是对于const成员函数的线程安全性，<br>具体而言，const成员函数只能保证不去修改那些没被声明为mutable的成员数据，那也就是说，多个线程访问同一个const函数的时候，就可能会出现data race的情况了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Poly&#123;</span><br><span class="line">public:</span><br><span class="line">    using type = std::vector&lt;double&gt;;</span><br><span class="line">    type getroot()const&#123;</span><br><span class="line">        if(valid)&#123;</span><br><span class="line">            ... //计算并修改root</span><br><span class="line">        &#125;</span><br><span class="line">        valid = true;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    mutable bool valid&#123;false&#125;;</span><br><span class="line">    mutable type root&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码可能在多线程下有问题，此时我们需要施加锁上去</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Poly&#123;</span><br><span class="line">public:</span><br><span class="line">    using type = std::vector&lt;double&gt;;</span><br><span class="line">    type getroot()const&#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; l(lock);</span><br><span class="line">        if(valid)&#123;</span><br><span class="line">            ... //计算并修改root</span><br><span class="line">        </span><br><span class="line">        valid = true;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    mutable bool valid&#123;false&#125;;</span><br><span class="line">    mutable type root&#123;&#125;;</span><br><span class="line">    mutable std::mutex lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过由于mutex是不可复制的，这个类的复制行为也就应该被禁止了，不过他还是可以移动的<br>书中还指出，如果mutable的变量只有1个，比如说某个计数器，那么我们可以直接用atomic去表示他，就不用大费周章的用锁了（虽然atomic有时候还是锁的实现），但atomic同样是不可复制的，所以该类同样只能移动而不能复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    void dosth()const&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        //dosth....</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    mutable std::atomic&lt;int&gt; count&#123;0&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为原子变量保证count++的执行是原子的，所以不用担心多线程带来的不确定性<br>而如果需要2个以上的mutable变量，使用atomic去表示他们的策略不是明智的，例如上面的例子，如果修改root的过程是在valid后面，那么就可能发生这种情况-线程1读valid发现为false，于是计算，然后设置valid，此时线程2也使用了这个函数，发现valid是true，于是直接返回root了，但线程1还没有修改root呢，这种现象发生的原因在于修改2个原子变量的过程并不是原子的，所以我们就需要加1个互斥锁来保证修改2个原子变量这一大动作的原子性，那既然都要用互斥锁了，那还不如直接把2个mutable的声明为普通变量，反正有了锁就能保证原子性了<br>所以总结的说，使用const成员函数时，要确保对mutable变量的操作能是线程安全的，可以通过互斥锁或者原子变量去实现</p>
<p>条款17说的是各种生成构造函数和生成运算符的生成规则，<br>规则1.当没有声明任何构造函数时，会生成1个默认的无参构造函数<br>规则2.如果没有声明复制构造函数等，在使用的时候会自动生成需要的函数<br>上面2个规则是98时代的，在11，大家都知道引入了移动构造函数和移动运算符，而编译器自动生成的移动操作，会默认的去“移动”每一个成员变量，移动加双引号是因为这个移动是有前提的，如果成员变量本身无法移动的，例如int这种，他执行的是复制，如果这个成员提供了移动操作，才是真正的移动这个变量，而本质上是使用std::move去处理每一个变量，得到的右值如果这个成员本身有移动构造函数能处理这个右值，就是执行移动操作，否则只能使用这个变量的复制构造函数了，因为复制构造函数的形参都是const &amp;，所以能去引用1个右值，这里我们可以写个例子示范如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Movable&#123;</span><br><span class="line">public:</span><br><span class="line">    Movable()=default;</span><br><span class="line">    Movable(Movable &amp;&amp; rhs)&#123;cout&lt;&lt;&quot;movable class moving&quot;&lt;&lt;endl;&#125;</span><br><span class="line">    Movable(const Movable &amp; rhs)&#123;cout&lt;&lt;&quot;movable class copying&quot;&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Copyable&#123;</span><br><span class="line">public:</span><br><span class="line">    Copyable()=default;</span><br><span class="line">    Copyable(const Copyable &amp; rhs)&#123;cout &lt;&lt; &quot;coping class copy&quot; &lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    A(Movable m_,Copyable c_):m(m_),c(c_)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    Movable m;</span><br><span class="line">    Copyable c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Movable m;</span><br><span class="line">    Copyable c;</span><br><span class="line">    cout &lt;&lt;&quot;==&quot;&lt;&lt;endl;</span><br><span class="line">    A a(std::move(m),c);</span><br><span class="line">    cout &lt;&lt;&quot;==&quot;&lt;&lt;endl;</span><br><span class="line">    A b(std::move(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于复制构造函数和复制运算符，他们是独立的，声明一种不会导致说编译器不会去生成另一种，但移动的2个操作就不同了，如果声明了其中的一种，编译器则不会去生成另外1个了，因为他会认为既然你自己实现的移动构造函数与默认的按数据成员移动的方式不一样，那么默认的移动运算符必然也与之不同，那还不如不生成<br>进一步的，复制操作和移动操作，只要定义了其中的一方，编译器就不会去生成另一种操作了，因为既然声明了其中的1种，说明对于另外1种来说，其实现方式也很有可能与默认的方式不同，编译器就采用这种思想。<br>接下来提到的是一个大三律的东西：复制构造函数，复制运算符和析构函数，只要声明了其中的一种，就应该实现另外的2个，其思想在于，我们之所以会去刻意地定义他们，是因为某些类成员函数的复制方式不同于默认的复制方式，例如说某些指针型的，例如说和资源管理相关的，那么析构函数也必须处理如何析构这些资源<br>从这个定律推出来，如果有了用户声明的析构函数，就说明默认生成的复制操作是不合用户心意的，因此编译器不应该自动生成，不过98的时代这个思想没有被编译器采纳，但到了11，移动操作应用于这种思想导致了——一旦用户声明了析构函数，移动操作就不会被自动生成<br>所以结合以上内容，如果想要自动生成移动操作，需要：1.不能声明复制操作2.不能声明移动操作3.不能声明析构函数<br>接下来我们可以写一个类，这个类只有1个vector的成员，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.vec.push_back(2);</span><br><span class="line">    a.vec.push_back(3);</span><br><span class="line">    A c = move(a);</span><br><span class="line">    cout &lt;&lt;a.vec.size()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当没有声明析构函数的时候，最终a的vec的size是0，的确是有移动操作在里面，但假如声明一下析构，最终输出是2，说明移动构造函数的确没有自动生成，假如这个vec的内容很多，这个复制的时间必然是多于移动的，此时我们简单的加上A(A&amp;&amp;)=default即可<br>当然了，有时候我们声明析构函数，是因为需要某个类作为基类，必须得声明他的析构函数并且声明为虚函数提供多态的特性，此时我们可以在那些无法自动生成的移动操作加上=default，告诉编译器这个移动操作使用默认的生成式可以的<br>所以最后总结如下<br>• 默认构造函数：与 C++98 的机制相同。仅当类中不包含用户声明的构造函数时<br>才生成。<br>• 析构函数：与 C++98 的机制基本相同，唯 的区别在千析构函数默认为<br>noexcept （参见条款 14) 。与 C++98 的机制相同，仅当基类的析构函数为虚的，<br>派生类的析构函数才是虚的。<br>• 复制构造函数：运行期行为与 C++98 相同：按成员进行非静态数据成员的复制<br>构造。仅当类中不包含用户声明的复制构造函数时才生成。如果该类声明了移动<br>操作，则复制构造函数将被删除。在已经存在复制赋值运算符或析构函数的条件<br>下，仍然生成复制构造函数已经成为了被废弃的行为。<br>• 复制赋值运算符：运行期行为与 C++98 相同：按成员进行非静态数据成员的复<br>制赋值。仅当类中不包含用户声明的复制赋值运算符时才生成。如果该类声明了<br>移动操作，则复制构造函数将被删除。在已经存在复制构造函数或析构函数的条<br>件下，仍然生成复制赋值运算符已经成为了被废弃的行为。<br>• 移动构造函数和移动赋值运算符：都按成员进行非静态数据成员的移动操作。仅<br>当类中不包含用户声明的复制操作、移动操作和析构函数时才生成。</p>
<p>接下来进入的是第4大章，关于智能指针的使用<br>条款18讲的是unique_ptr<br>我们可以认为一个uniqueptr和野指针有几乎一样的尺寸，且他不能复制，因为本身他的实际应用场景就是管理专用型资源的，而且他的构造函数也使用了explicit修饰，不能使用隐式类型转换去构造如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int&gt; p1(new int(3));</span><br><span class="line">unique_ptr&lt;int&gt; p2 = new int(3);</span><br><span class="line">unique_ptr&lt;int&gt; p3&#123;nullptr&#125;;</span><br><span class="line">p3 = p1;</span><br><span class="line">p3 = move(p1);</span><br></pre></td></tr></table></figure>
<p>第1行是拿一个野指针做参数构造p1，行的通；但第2行是想执行1个隐式类型转换，把int*转换为unique_ptr<int>,这个是行不通的,而第4行自然也error，只有第5行才可以，此时p1的资源就给p3管理了<br>unique_ptr可以自定义删除器，而且必须得把第二个模板参数声明为这个删除器，所以不同删除器的同个管理对象的类型是不同的，这个shared_ptr就不是了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Investment&#123;</span><br><span class="line">public:</span><br><span class="line">     ...</span><br><span class="line">     virtual ~Investment()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Stock : public Investment&#123;...&#125;;</span><br><span class="line">class Bond: pulibc Investment&#123;...&#125;;</span><br><span class="line">auto MyDelete = [](Investment * ptr)&#123;dosth; delete ptr;&#125;</span><br><span class="line">template&lt;typename ...Ts&gt;</span><br><span class="line">unique_ptr&lt;Investment, decltype(MyDelete)&gt;</span><br><span class="line">func(Ts&amp;&amp;... params)&#123;</span><br><span class="line">    unique_ptr&lt;Investment,decltype(MyDelete)&gt;</span><br><span class="line">    p (nullptr,MyDelete);</span><br><span class="line">    if (/*need stock*/)&#123;</span><br><span class="line">        p.reset(new Stock(forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        p.reset(new Bond(forward&lt;Ts&gt;(params)));</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的注意点：<br>我们使用自定义的删除器，则需要指定unique_ptr的第2个模板实参，且在创建该对象时将删除器传入第二个参数<br>后面的赋值操作并不能通过=的方式，原因上面提到了，需要使用reset函数去转换其管理的对象<br>而使用了自定义的删除器后，如果我们用的删除器是函数指针，这个unique_ptr的尺寸就比一般的野指针要大了，因为它还要储存函数指针，而如果是无捕获的lambda表达式，作者说是不会浪费任何空间的，这里有待了解详情。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-14</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 2904 words, 9 min 40 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/14/effective-modern-c-13-15/">effective modern c ++ 13-15</a></h3></div><div class="post-content"><div class="card"><p><p>条款13介绍的是const_iterator，一开始一大段介绍了在98中实现一个const_iterator有多么困难，但到了11，一切都迎难而解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vec;</span><br><span class="line"></span><br><span class="line">auto it = std::find(vec.cbegin(),vec.cend(),13);</span><br><span class="line">vec.insert(it,16);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以使用cbegin()cend()来获取容器的const 迭代器，就算是对非const容器也一样，且insert函数他的第一个参数是const_iterator,这样子就满足他的要求了<br>除此之外有一点要注意的是，c++11提供了非成员函数的begin，end等函数，为的就是满足容器是数组的情况下的需求，但11并没有提供cbegin或者cend等const函数，我们无法在只依赖std库的情况下做到const遍历数组，因此我们可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">decltype(auto) cbegin(const T&amp; container)&#123;</span><br><span class="line">    return std::begin(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把传进来的容器用const修饰，那么我就能用他去获取cbegin了，当然这种多余的步骤在14的时候就没必要了，14的时候就引入了非成员的cbegin，cend等函数</p>
<p>条款14介绍的是关于异常和noexcept关键字，在11的标准里，一个函数要么可能发射异常，要么保证不会发射异常，如果能确保他不会发射异常，我们就应该加上noexcept关键字，有关异常的知识我也不是很了解，作者这里介绍说加上noexcept比其他方式优化更好也不是很理解，等后续补坑<br>接着是几个标准库里和异常相关的函数，最重要的就是push_back函数，当需要扩容时，原本的版本是强异常安全性的——直到所有元素都复制到了新的内存上，旧内存上的元素才会析构，如果中途抛出了异常，则没啥事；但如果为了优化复制转而使用移动，假设我们已经移动了一部分元素了，但此时抛出了异常，程序就处在一部分元素在新的内存，一部分在旧的内存，原有的状态已经没有了，如果想恢复到原来的状态转而把移动过的元素移动回去也可能异常，而11的很多函数的实现，为了解决这种麻烦，采取的是“能移动就移动，不能移动才复制”的策略，而判断移动是不是安全就看这个操作有没有noexcept，其中有一部分的函数，例如swap他是否异常安全，完全取决于用户自定义的操作是否带有noexcept，具体例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, size_t N&gt;</span><br><span class="line">void swap( T(&amp;a)(N), T(&amp;b)(N)) noexcept(noexcept(swap(*a,*b)));</span><br></pre></td></tr></table></figure>
<p>上述代码中，noexcept这种使用方式称为条件式noexcept，只有当括号内T的swap的操作，也就是对a这个数组的每一个元素都进行swap操作时时noexcept的，括号里的结果就为true，此时外层的swap就也是保证异常安全了的</p>
<p>条款15介绍的是constexpr关键字，他表示的变量必须是个常量，且必须在编译期就能确定下来具体是什么值，这个一个值可以用在声明数组长度，array的模板实参（长度）等必须在编译阶段就已知的常量值，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constexpr int len = 2;</span><br><span class="line">std::array&lt;int, len&gt; arr;</span><br></pre></td></tr></table></figure>
<p>而const修饰的，他并没有会在编译期就知道具体值的保证，所以并不能把他用在array这种模板形参上<br>constexpr还可以修饰函数，不过此时就有点复杂了，如果传入的实参是编译期就能确定的常量值，那他必须保证该函数也能在编译期得到对应的结果，但如果传入的参数有1个是直到运行期才知道结果的，此时的函数就和一般的函数一样了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constexpr int pow (int base, int numconds)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">constexpr auto numconds = 5;</span><br><span class="line">std::array&lt;int, pow(3,numconds)&gt; arr;</span><br></pre></td></tr></table></figure>
<p>以上代码可以通过，因为2个参数都是编译期就知的常量，因此pow也能在编译期返回具体的值了<br>而上面pow的….的具体实现与版本有关，在c++11下，constexpr函数最多只能有1条可执行语句，因此得这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return numconds=0? 1:base*pow(base,numconds-1);</span><br></pre></td></tr></table></figure>
<p>而在c++14下这个限制就放开了，可以按一般的for循环去实现了 </p>
<p>除了内置类型可以声明为constexpr外，我们自定义的类也可以将构造函数以及其他成员函数声明为constexpr，这样子就能在编译器完成相关的语句执行了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;&#125;</span><br><span class="line">    constexpr Point(double x_ = 0.0, double y_ = 0.0):x(x_),y(y_)&#123;&#125;</span><br><span class="line">    constexpr getx()&#123;return x;&#125;</span><br><span class="line">    constexpr gety()&#123;return y;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    double x,y;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">constexpr getmid(Point x1, Point x2)&#123;</span><br><span class="line">    return Point((x1.getx() + x2.getx()) / 2, (x1.gety() + x2.gety()) / 2);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    constexpr Point x1(5.3,2.3);</span><br><span class="line">    constexpr Point x2(2.2,34.2);</span><br><span class="line">    constexpr Point mid = getmid(x1,x2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的x1和x2都能在编译阶段都确定下来具体的值，mid也是</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-14</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 1346 words, 4 min 29 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/13/effective-modern-c-10-12/">effective modern c ++ 10-12</a></h3></div><div class="post-content"><div class="card"><p><p>条款10介绍的是enum的2种类型，一种是非限定作用域的enum，一种是限定作用域的enum，他们主要有以下几点不同<br>一是作用域的不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color&#123;White, Black&#125;;</span><br><span class="line">auto White = false;</span><br></pre></td></tr></table></figure>
<p>上面代码的第2行不能通过编译，因为这里的enum不带class，他的大括号里的内容的作用域会扩散出来，而下面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum class Color&#123;White, Black&#125;;</span><br><span class="line">auto White = false;</span><br><span class="line">Color c = Color::White;</span><br></pre></td></tr></table></figure>
<p>则不会，因为这里是限定作用域的enum,所以下面可以声明一个White<br>二是能否隐式转换的问题<br>非限定作用域的enum，他能转化为整数型别，甚至是浮点数，而限定作用域的则不可了，除非是static_cast去强制转换，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Color&#123;White, Black&#125;;</span><br><span class="line"></span><br><span class="line">void func(int c)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Color c = White;</span><br><span class="line">c &gt;= 2;</span><br><span class="line">func(c);</span><br></pre></td></tr></table></figure>
<p>上面这种代码比较诡异，为什么要拿枚举类的东西去和整数比较呢，没有啥意义，因此限定作用域的enum就禁止这种行为了<br>三是关于能否前置声明而不定义的问题<br>非限定枚举本来是能只声明的，但因为他的底层具体使用的数据类型是需要具体的枚举型别去确定，例如可能用char，也可能用int等，因此如果在后面，我们修改了他，整个系统就需要重新编译了<br>而限定枚举能直接声明不定义，因为他默认底层的数据类型就是int，而非限定则没有默认值，只要我们加上默认值，也可以只声明了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Color：int;</span><br></pre></td></tr></table></figure>

<p>条款11介绍了delete关键词的使用场景<br>最常见的是我们不想我们的对象能被复制，在98时直接把复制构造函数声明为private且不定义即可，到了11我们可以在后面加上=delete且放在public，<br>另外1个就是，任何函数都能使用delete，这个应用场景如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void func(int num);</span><br><span class="line">func(&#x27;a&#x27;);</span><br><span class="line">func(3.2);</span><br><span class="line">func(true);</span><br></pre></td></tr></table></figure>
<p>如上，我们期望的实参是个int，但却传入了一堆不相关的，但这是允许的，因为他们还勉强能转化为int，为了明确禁止这种行为，我们可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void func(int num);</span><br><span class="line">void func(double)=delete;</span><br><span class="line">void func(bool) =delete;</span><br><span class="line">void func(char)=delete;</span><br></pre></td></tr></table></figure>
<p>这样子上面的3行函数调用会使用被删除的重载版本，也就不能通过编译了<br>还有1种场景就是模板，我们希望当模板被某种类型的参数实例化时不能通过编译，比如说对指针类型T*,我们不希望void<em>和char</em>通过编译，前者因为他过于特殊，无法自增，自减，后者因为他通常是用来表示c的string，我们假定我们的模板不会处理这两种，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T* ptr)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">template&lt;&gt;</span><br><span class="line">void func&lt;char&gt;(char * ptr)=delete;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">void func&lt;void&gt;(void * ptr)=delete;</span><br></pre></td></tr></table></figure>

<p>条款12讲的是关于override的使用<br>其最重要的使用场景在于，关于虚函数的重载，他的要求十分严格，函数的签名必须一致，const必须一致，异常必须一致（noexcept），引用修饰词也必须一致（在函数签名后加&amp;或&amp;&amp;表示这个函数是给左值对象或者右值对象调用），那么很有可能因为这些限制，我们写出来的“虚函数”实际已经丢失了虚函数的特性，而编译器有可能没有给我们提出warning，因此这个时候就需要override了，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived:public Base&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func() override;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样子编译器发现override的函数如果有什么不一致会报错<br>这个条款的最后补充说明了引用修饰词的用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    using datatype = std::vector&lt;int&gt;;</span><br><span class="line">    datatype&amp; getdata() &amp;&#123; return values; &#125;</span><br><span class="line">    datatype getdata() &amp;&amp; &#123;return std::move(values);&#125;</span><br><span class="line">private:</span><br><span class="line">    datatype values;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A getA()&#123;</span><br><span class="line">    return A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码A这个类有2个不同的引用修饰词修饰的函数，当左值对象调用时，返回的是左值对象的左值引用，而当右值对象，例如getA()的返回值调用getData时，使用的是&amp;&amp;修饰的函数，因为临时对象本身就是要被析构的，最佳使用方式是移动他的资源，而不是复制，所以&amp;&amp;版本使用了move移动语义，而且他的返回值也不是一个左值引用了，而是一个临时值，是个右值</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 1230 words, 4 min 5 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/13/effective-modern-c-7-9/">effective modern c ++ 7-9</a></h3></div><div class="post-content"><div class="card"><p><p>条款7开始是第3章的内容，具体就是介绍了一些c+11新特性特别好用的地方<br>条款7介绍的是{}的优缺点，第1点好处就是他用来初始化时适合于所有情况，一般而言有4种初始化方式，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = 2;</span><br><span class="line">int x(2);</span><br><span class="line">int x = &#123;2&#125;;</span><br><span class="line">int x&#123;2&#125;;</span><br></pre></td></tr></table></figure>
<p>后面2种其实都是同1个，而如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;</span><br><span class="line">Widget w2 = w1;</span><br><span class="line">w1 = w2;</span><br></pre></td></tr></table></figure>
<p>这里的赋值并不是初始化，而是复制构造函数,最后的调用的也是赋值运算符的重载<br>大括号初始化的第1点优势在于可以用其初始化容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vec &#123;1,3,4&#125;;</span><br></pre></td></tr></table></figure>
<p>第2点是可以用来给非静态成员赋初始值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int x&#123;2&#125;;</span><br><span class="line">    int y = 0;</span><br><span class="line">    int z(0); //error! </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第3点是可以用来给不可复制的对象进行初始化，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;int&gt; x = 0; //error!!!</span><br><span class="line">std::atomic&lt;int&gt; y&#123;2&#125;;</span><br><span class="line">std::atomic&lt;int&gt; z(0);</span><br></pre></td></tr></table></figure>
<p>从2和3点可以看出，只有大括号初始化在这些情况下是可以通用的，所以说大括号是一种大一统初始化的方式<br>大括号还有1种特性，括号内是不能使用窄式类型转换的，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doube x, y, z;</span><br><span class="line">int sum1 &#123;x + y + z&#125;;</span><br></pre></td></tr></table></figure>
<p>上面不能确定double之和能不能用int表示</p>
<p>大括号的第4点好处是避免了很烦人的解析语法，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget w(10);</span><br><span class="line">Widget w;</span><br><span class="line">Widget w();//变成函数声明了</span><br><span class="line">Widget w&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面第3行本想用无参构造函数，结果却声明了一个返回值是Widget的无参函数，使用第4行的方式就能避免这种麻烦了<br>而使用{}的缺点在于类的构造函数的选择问题上，如果构造函数的型参有std::initializer_list且传进来的参数有机会匹配到（有机会包括进行窄式类型转换），那么他会直接忽略其他任何的构造函数，不管说这些构造函数会多匹配如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    A(int x_, double y_):x(x_), y(y_)&#123;&#125;</span><br><span class="line">    A(std::initializer_list&lt;bool&gt; list)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    int x;</span><br><span class="line">    double y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    A a&#123;10,0.5&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会报错，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: narrowing conversion of ‘10’ from ‘int’ to ‘bool’ inside &#123; &#125; [-Wnarrowing]</span><br></pre></td></tr></table></figure>
<p>虽然有一个完美符合a的构造函数，但因为编译器看到了能使用initializer_list的希望，他就直接忽视了其他构造函数了<br>甚至说以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Widget w&#123;w2&#125;;</span><br><span class="line">Widget w3&#123;std::move(w)&#125;;</span><br></pre></td></tr></table></figure>
<p>本来会使用复制构造函数和移动构造函数的，但如果有上述条件。他还是会调用initializer_list<br>只有当真的没办法匹配到这个initializer_list型参的构造函数的时候，其他构造函数才会成为候选<br>最后1个问题就是上面的无参构造函数了，在使用{}的时候表示的是无参，而不是没有元素的空的初始化列表，如果想表示后者，应该这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w&#123;&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>而（）和{}的区别，也导致说初始化容器的时候，可能会有意想不到的结果，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vec (10, 20);</span><br><span class="line">vector&lt;int&gt; vec2 &#123;10, 20&#125;;</span><br></pre></td></tr></table></figure>
<p>第1个是创建了一个元素都是20.共10个的vector，而第2个则是有2个元素，分别为10和20<br>这种接口作者认为是失败的</p>
<p>条款8则是介绍了nullptr这个特性，在没有他之前，我们想表示空指针需要使用0和NULL,但前者本质是一个int，不是一个指针，而NULL根据具体的实现不同而不同，但本质也是1个整形数据而不是1个指针，所以在下面的场景中，那个参数为void *的函数是永远不会被调用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func(int)&#123;&#125;</span><br><span class="line">void func(void *)&#123;&#125;</span><br><span class="line">void func(bool)&#123;&#125;</span><br><span class="line">func(0);</span><br><span class="line">func(NULL);</span><br></pre></td></tr></table></figure>
<p>NULL可能是由long实现的，可能带来歧义，但这里本质的问题在于传入的本意是个指针，结果却调用了非指针版本的矛盾<br>因此，nullptr登上了舞台，他不具备整型类型，永远不会像0和NULL一样被解释为一个整形，且他可以隐式转换为任何其他类型的指针，此时func(nullptr)调用的就是void *类型的func了<br>使用他的优点是在使用auto的场景下，到底一个变量是整数还是空指针，这个在有nullptr的情况下就很明了了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">auto func()</span><br><span class="line">-&gt;decltype(result)</span><br><span class="line">&#123;</span><br><span class="line">    if(result == nullptr)&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如这里的nullptr是0的话，auto就推导为int，但我们本意是拿result去和空指针比较，所以用上nullptr，result就一定是个指针了<br>既然说到了auto，那模板推导也必然受益于nullptr了<br>如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename P&gt;</span><br><span class="line">void func(T t, P ptr)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">func(3, 0);</span><br><span class="line">func(3, NULL);</span><br><span class="line">func(3, nullptr);</span><br></pre></td></tr></table></figure>
<p>上面前2个调用会使得P被推导为int或long的整型数据，只有使用nullptr才使得P被推导为指针类型</p>
<p>条款9讲的是using用来声明类型别名的优势<br>在不使用类型别名的时候，我们声明一个变量可能很痛苦，使用using就变简单多了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using MyType = std::unique_ptr&lt;std::unordered_map&lt;std::string,int&gt;&gt;;</span><br></pre></td></tr></table></figure>
<p>当然我们可以使用typedef去弄别名，在上面的场景和下面这种，2者没啥区别，最多是可读性上不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using fp = void(*)(int ,double);</span><br><span class="line">typedef void (*fp)(int, double);</span><br></pre></td></tr></table></figure>
<p>而using的优点在于模板的别名上，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">using MyList = std::list&lt;T,MyAlloc&lt;T&gt;&gt;; //MyAlloc是自定义的</span><br><span class="line">MyList&lt;int&gt; l1;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct MyList&#123;</span><br><span class="line">    typedef std::list&lt;T,MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">MyList&lt;int&gt;::type l2;</span><br></pre></td></tr></table></figure>
<p>可以看出使用using比typedef方便多了，不用说去弄个struct写了一堆，而且如果想用上面的这个类型去用做类模板，using同样更加方便</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class&#123;</span><br><span class="line">private:</span><br><span class="line">    typename MyList&lt;T&gt;::type list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class&#123;</span><br><span class="line">private:</span><br><span class="line">    MyList&lt;T&gt; list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第2种就是使用using的写法，第1种既要typename又要::type，比较麻烦</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 1580 words, 5 min 16 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/12/effective-modern-c-4-6/">effective modern c ++ 4-6</a></h3></div><div class="post-content"><div class="card"><p><p>条款4是教如何去获取类型推导结果的，第一种就是利用IDE去获取，第2种我们可以声明一个类模板但不去定义他，然后使用decltype(x)让编译器报错，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class TD;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"> const int x = 3;</span><br><span class="line"> TD&lt;decltype(x)&gt; xtype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时编译器报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: aggregate ‘TD&lt;const int&gt; xtype’ has incomplete type and cannot be defined</span><br><span class="line">  TD&lt;decltype(x)&gt; xtype;</span><br></pre></td></tr></table></figure>
<p>可以看到x的确被推导为const int<br>还有1种就是使用type_info,在大多数情况下他是正确的，但他推导的方式是安值推导的，也就是说，引用和常量性会被忽略，所以他并不可靠，</p>
<p>接下来是条款5，是开始了第2大章，关于auto的使用<br>条款5具体讲了一些应用auto带来的方便与好处<br>第1个就是在使用iterator的时候，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename It&gt;</span><br><span class="line">void func(It b, It e)&#123;</span><br><span class="line">    while(b!=e)&#123;</span><br><span class="line">        typename std::iterator_traits&lt;It&gt;::value_type</span><br><span class="line">        val = *b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这一段，我们使用萃取去获取这个迭代器到底指向啥东西，写起来十分的拗口麻烦，我们可以利用auto直接写成auto val = *b；<br>第2个就是使用auto来保证变量一定能初始化，解决变量未初始化的行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto i; // 不能通过</span><br><span class="line">auto i = 2;</span><br></pre></td></tr></table></figure>
<p>第3个就是使用lambda表达式时，这个lambda对象到底是个什么类型，这个是由编译器决定的，所以我们需要利用auto用来把lambda表达式赋值给某个变量名，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto lam = []()&#123; return 0; &#125;;</span><br></pre></td></tr></table></figure>
<p>当然我们也可以用一个std::function去持有这个lambda，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;bool(int,int)&gt;</span><br><span class="line">myfunc = [](int x, int y)&#123; return true;&#125;;</span><br></pre></td></tr></table></figure>
<p>而其缺点在于function本身就是一个对象，他本身就是需要内存的，在内存上来说auto来的更好，<br>第4个就是对于一些硬件依赖的typename，比如unsigned，在32位上和在64位上不同的，单单指定某个变量是unsigned可能会在不同机器上带来出乎意料的结果，因此我们可以利用auto</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto size = v.size();</span><br></pre></td></tr></table></figure>
<p>第5个还是在迭代的时候，我们对于一些容器他储存方式不熟悉带来的问题，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(const std::pair&lt;std::string, int&gt; &amp;p :m)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>m是个unorder_map,他本身是由std::pair&lt;const std::string, int&gt;组成的，不是上面这种方式，也就是说，程序跑到这段代码，会复制容器里的每一个元素，然后引用再去指向这些临时对象，可想而知多非时间，而使用auto很容易就解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for（const auto &amp;p:m)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，auto也是得看实际的使用场景，大多数情况下使用得当能提升我们编程的效率的<br>条款6 介绍的是使用auto可能遇到的坑，在这种时候就得采用传统的方式了<br>第1个，就是vector&lt;bool&gt;这个和其他vector格格不入的对象，对于一般的vector&lt;T&gt;[],他能返回一个T&amp;类型的东西，但vector&lt;bool&gt;他本身是特化过的，他底层是使用比特去表示这1个1个的bool，而c++又不能返回1个对比特的引用，所以他只能返回一个用来模拟bool&amp;的reference，即std::vector&lt;bool&gt;::reference,他能够像bool进行隐式转换，所以对下面语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector\&lt;bool&gt; vec&#123;true,true&#125;;</span><br><span class="line">bool is_true = vec[0];</span><br></pre></td></tr></table></figure>
<p>这里取出来的vec[0]实际是个std::vector&lt;bool&gt;::reference，但他可以转换为bool，所以没啥问题<br>但假如我们使用auto去声明is_true,得到他类型就是std::vector<bool>::reference了，他就不是指代第1个元素是否为true的变量了<br>书里介绍的这种情况带来的问题在于可能出现悬空指针，例如，当我们函数的返回值是个vector<bool>时，他是个临时对象，而他实现获取第1个元素的方式，有一种实现是通过指针+偏移量的方式去获取，而我们如果使用auto is_true = bool_vectroy()[0]时，is_true和临时对象的指针指向同一个东西，而临时对象在这一句话后就解析了，那is_true就指向1个被析构了的地址了，</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 1156 words, 3 min 51 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/12/effective-modern-c-1-3/">effective modern c ++ 1-3</a></h3></div><div class="post-content"><div class="card"><p><p>条款1是对模板参数推导的几个细则，具体以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void func(ParamType param)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用func(expr)去调用时，它会推导T和param的形别，这2种有的时候是一样的，有的时候由于常量这些标识而不同，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void func(const T&amp; param)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在使用一个int 变量i去调用func时，T是iNT,而PARAMTYPE是const int&amp;<br>具体则分三种情况去讨论<br>第1种是paramtype是一个非万能引用，此时的判断方法是：如果expr具有引用，把引用给忽略，然后再去推导，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void func(T&amp; param)&#123;&#125;</span><br><span class="line"></span><br><span class="line">int x = 2;</span><br><span class="line">const int cx = x;</span><br><span class="line">const int&amp; rx = x;</span><br></pre></td></tr></table></figure>
<p>那么在调用func的时候，对x，T是int，paramtype是int&amp;，而后面2个T是const int，而paramtype是const int&amp;，因为第3个expr的引用是会被忽略的，这里也可以看出，持有T&amp;的模板，它能保证传进来的对量的常量性能被捕获<br>第2种是paramtype是一个万能引用，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T&amp;&amp; param)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候就使用引用折叠，可知如果传进来的expr是左值，T和paramtype都会推导为左值引用，如果expr是右值，则根据1的规矩即可</p>
<p>第3种情况就是paramtype不是引用，那么就是说函数是按值传参的，他复制了一个新的对象，此时他对expr，会忽视他的const，volatile和引用，所以对上面的，x，cx，rx，如果模板声明如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T param)</span><br></pre></td></tr></table></figure>
<p>那么T和paramtype最终都是int，这个也是可以理解的——本身传进来后我是构建的新的对象，不会对外面的一切造成干扰<br>这里还有1种特殊情况，即指向常量的常量指针，const int * const ptr,那么传进来之后，<em>右边的const会被忽略，因为传进来的本质是1个地址，这个值就像前面那个const int一样，所以他就被忽略了，那么进来后，T会被推导为const int</em>，指向常量的指针<br>最后就是关于数组的问题了，这里直接结论如下：<br>当paramtype是T param时，数组形参会退化为1个指针例如<br>template<typename T><br>void func(T param)<br>const char name[] = “22”;<br>此时把name传进来时，T会推导为const char*<br>但假如paramtype是个引用，T则会推导为const char[3],而paramtype则是cost char（&amp;）[13]<br>我们可以用这一特性去推导数组长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, int N&gt;</span><br><span class="line">constexpr int getlen(T(&amp;)[N]) noexcept&#123;</span><br><span class="line">    return N;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"> int x[2] = &#123;2,3&#125;;</span><br><span class="line"> char y[getlen(x)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条款2是auto推导的规则，他的规则上和模板推导的基本一致，但有一点很特别，在使用c++11引入的初始化方式中，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto x&#123;3&#125;;</span><br><span class="line">auto x=&#123;3&#125;;</span><br></pre></td></tr></table></figure>
<p>此时auto推导型别会推导出std:: initializer_list<int>，且其中只有1个元素的变量，所以如下代码编译是会失败的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto y&#123;2,3,3.0&#125;;</span><br></pre></td></tr></table></figure>
<p>因为对std:: initializer_list<T>的T推导不出是什么<br>这里的本质是有2次推导，第1个是推导出y的型别为std:: initializer_list（因为使用了大括号去初始化），第2次是推导std:: initializer_list<T>的T的类型，而如果我们想利用模板去实现这一点是做不到的，因为auto他本身对大括号初始化就假定了第1次推导必定是std:: initializer_list，而模板没办法，所以如果真要用模板，可以这么实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(std:: initializer_list&lt;T&gt; list);</span><br></pre></td></tr></table></figure>
<p>对于func({2,3,3})的调用，上面模板就起效了<br>最后还补充了1点，在c++14的标准中，可以单独用auto去说明函数返回值/lambda表达式的形参需要推导，但此时他是使用模板推导去推导的，所以说返回值不能使用大括号</p>
<p>条款3是decltype的使用<br>一般的，对于大多数std的容器，其[]的使用会返回对应位置的元素的引用，除了vector<bool>以外，<br>而在c++14中，正如在条款2中提到的，我们可以只使用auto不加decltype去推导返回值类型，此时使用的是模板类型的推导，那以下代码就有问题了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename container, typename index&gt;</span><br><span class="line">auto getindex(container &amp; c,index i)&#123;</span><br><span class="line">    return c[i];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"> std::vector&lt;int&gt; vec &#123;3,4,4&#125;;</span><br><span class="line"> getindex(vec,2) = 10;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>上面的代码执行如下：首先这里采用的是模板推导，且auto没有&amp;或者&amp;&amp;的修饰，即采用条款1种的第3种规则，此时型参的一切引用都会被忽略，即c[i]返回的int&amp;被看成是int，那么T和paramtype就是int了，此时返回的是1个临时值，是个右值，不能放在等号左侧，所以很明显他会报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: lvalue required as left operand of assignment</span><br><span class="line">  getindex(vec,2) = 10;</span><br></pre></td></tr></table></figure>
<p>解决方法是把auto改成decltype（auto），告诉他说推导过程用的是decltype的规则，而他对于int&amp;就是推导为int&amp;，或者我们直接使用后置类型推导，也比较清晰<br>那这里还有1个不完美的在于，getindex他只能接受1个左值容器，对于一些右值容器，比如说一些工厂函数的返回值，我们直接传入，此时需要用万能引用和完美转发去解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename container, typename index&gt;</span><br><span class="line">decltype(auto) func(container &amp;&amp; c, index i)&#123;</span><br><span class="line">    return std::forward&lt;container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，decltype还有一个坑，如果decltype（sth），sth仅仅只是1个变量名，如x，一切如旧；但假如sth是(x),c++仍把他看做是左值表达式，此时decltype必须推导出是一个引用类型，那么对下列代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">decltype(auto) func()&#123;</span><br><span class="line">    int x = 2;</span><br><span class="line">    return (x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他会返回1个局部变量的引用，这是一个危险的未定义行为，所以使用decltype一定要小心，里面的东西到底是什么</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 1615 words, 5 min 23 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/09/leveldb%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%971-skiplist/">leveldb源码系列1-skiplist</a></h3></div><div class="post-content"><div class="card"><p><p>本文分析的是leveldb中的跳表skip list的实现，他会把user key和user value打包成一个更大的key塞入list中<br>跳表的一个例子如下图</p>
<p>可以看到，每一个node，它都有不同的高度，且每个节点都在第0层都有出现，第0层就像最简单的链表一样，而到了上面的层数节点的个数越来越少，就像树状结构那种，跳表的许多操作都能在logn的复杂度下完成，<br>leveldb的主要结构包括skiplist，内部是由一系列的node构成的，他还实现了一个iterator用于遍历<br>接下来首先看node的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">struct SkipList&lt;Key, Comparator&gt;::Node &#123;</span><br><span class="line">  explicit Node(const Key&amp; k) : key(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Key const key;</span><br><span class="line"></span><br><span class="line">  // Accessors/mutators for links.  Wrapped in methods so we can</span><br><span class="line">  // add the appropriate barriers as necessary.</span><br><span class="line">  Node* Next(int n) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    // Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span><br><span class="line">    // version of the returned Node.</span><br><span class="line">    return next_[n].load(std::memory_order_acquire);</span><br><span class="line">  &#125;</span><br><span class="line">  void SetNext(int n, Node* x) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    // Use a &#x27;release store&#x27; so that anybody who reads through this</span><br><span class="line">    // pointer observes a fully initialized version of the inserted node.</span><br><span class="line">    next_[n].store(x, std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // No-barrier variants that can be safely used in a few locations.</span><br><span class="line">  Node* NoBarrier_Next(int n) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    return next_[n].load(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  void NoBarrier_SetNext(int n, Node* x) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    next_[n].store(x, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">   private:</span><br><span class="line">  // Array of length equal to the node height.  next_[0] is lowest level link.</span><br><span class="line">  // 1) 这里提前声明并申请了一个内存，用于存储第 0 层的数据，因为第 0 层必然存在数据。</span><br><span class="line">  // 2) 这里的数组长度其实就是层高，假设 next_ 长度为 n，那么就会从 next_[n-1] 开始查找。</span><br><span class="line">  // 3) 因为 skip list 的 level 并不会太大，使用数组存储 Node 指针的话对 CPU 内存更友好</span><br><span class="line">  // https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf</span><br><span class="line">  std::atomic&lt;Node*&gt; next_[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一部分主要是1个显式的构造函数，指定某个键并初始化key这个成员数据，然后是他的next_数组，这个数组主要是用来存放该结点的每一层的next结点的指针的，指定为1是因为必然要在第0层有该结点，接下来是他的2个无锁操作和2个不用内存屏障的操作，next这个无锁操作使用了next_这个原子对象的load函数，且指定了memory_order_acquire,那么在这个语句之前的都不会被重排到他后面了，而setnext则是store函数，指定了memory_order_release，则该语句后面的内容都不会重排到他前面去，<br>后面的2个则是使用了memory_order_relaxed,他只保证这条语句他是原子的，语句前后怎么重排都没有限制<br>接下来是一个生成新结点的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::NewNode(</span><br><span class="line">    const Key&amp; key, int height) &#123;</span><br><span class="line">  // 内存分配时只需要再分配 level - 1 层，因为第 0 层已经预先分配完毕了。</span><br><span class="line">  char* const node_memory = arena_-&gt;AllocateAligned(</span><br><span class="line">      sizeof(Node) + sizeof(std::atomic&lt;Node*&gt;) * (height - 1));</span><br><span class="line">  // 这里是 placement new 的写法，在现有的内存上进行 new object</span><br><span class="line">  return new (node_memory) Node(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2行开头的typename是为了告诉编译器，后面这个::Node是一个类型，那么整个函数的返回值就是NOde*了，首先分配内存，然后在这个内存上placement new，调用node的构造函数了</p>
<p>接下来是skiplist的成员函数<br>第一个是生成随机层数的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">int SkipList&lt;Key, Comparator&gt;::RandomHeight() &#123;</span><br><span class="line">  // Increase height with probability 1 in kBranching</span><br><span class="line">  static const unsigned int kBranching = 4;</span><br><span class="line">  int height = 1;</span><br><span class="line">  while (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == 0)) &#123;</span><br><span class="line">    height++;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(height &gt; 0);</span><br><span class="line">  assert(height &lt;= kMaxHeight);</span><br><span class="line">  return height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先初始化height为1，接着以1/4的概率使得while成立（在height比kmaxheight小的情况下），这样子第1层的node个数就大致是第0的1/4了，后面的层数以此类推，而用1/4这个概率貌似也是提出跳表的论文中建议的？<br>接下来是一个key的大小顺序的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">bool SkipList&lt;Key, Comparator&gt;::KeyIsAfterNode(const Key&amp; key, Node* n) const &#123;</span><br><span class="line">  // null n is considered infinite</span><br><span class="line">  return (n != nullptr) &amp;&amp; (compare_(n-&gt;key, key) &lt; 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当要比较的对象（比如说是next节点指向的某一层对象）不为空且compare比较器得到的结果小于0时，说明这个key在顺序上是在n后面的，</p>
<p>接下来就是查找在每一层上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(const Key&amp; key,</span><br><span class="line">                                              Node** prev) const &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  int level = GetMaxHeight() - 1;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    /* 获取当前 level 层的下一个节点 */</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line"></span><br><span class="line">    if (KeyIsAfterNode(key, next)) &#123;</span><br><span class="line">      // Keep searching in this list</span><br><span class="line">      x = next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // prev 数组主要记录的就是每一层的 prev 节点，主要用于插入和删除时使用</span><br><span class="line">      if (prev != nullptr) prev[level] = x;</span><br><span class="line">      if (level == 0) &#123;</span><br><span class="line">        return next;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // Switch to next list</span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的GetMaxHeight函数获取的是当前结点的层数，我们从这个节点的最高层开始找，不断获取他的next节点，判断这个node他</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-09</span><i class="fa fa-tag"></i><a class="tag" href="/tags/leveldb/" title="leveldb">leveldb </a><span class="leancloud_visitors"></span><span>About 1319 words, 4 min 23 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/09/4%E7%A7%8Dc-%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">4种c++风格的类型转换</a></h3></div><div class="post-content"><div class="card"><p><p>reinterpret_cast<typename1>(value),他可以把一个指针转化为另外1种指针，也可以把1个整型值赋给一个指针，其最本质在于不修改value的底层二进制位，只是修改了去解释他的方法，比如说同一个二进制数，我用整数补码（int）和float类型那个ieee标准去解释结果肯定不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a = 0;</span><br><span class="line">int* p = &amp;a;</span><br><span class="line">char* p2 = reinterpret_cast&lt;char *&gt;(p);</span><br><span class="line">*p2 = &#x27;1&#x27;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的输出结果为49，正好是a的asci值，首先他会把p这个int指针强制转换为char类型的指针，而且他指向了a的最低位（在我们机器上是小端存储的的），我们解引用赋值，其实就是在a的最低位字节上赋值了整数49，当用char的方式去解读时读出来的就是’a’,int则是49了，<br>还有另外一种使用方式就是把一个整数赋值给一个指针，然后这个指针就指向这个地址了，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* p;</span><br><span class="line">int address = 0x12345678;</span><br><span class="line">p = reinterpret_cast&lt;int*&gt;(address);</span><br></pre></td></tr></table></figure>
<p>当然这种得是你能访问这个地址才行</p>
<p>而这种强制转换在leveldb中的fixedint编码中就使用了，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inline void EncodeFixed32(char* dst, uint32_t value) &#123;</span><br><span class="line">    uint8_t* const buffer = reinterpret_cast&lt;uint8_t*&gt;(dst);</span><br><span class="line">    buffer[0] = static_cast&lt;uint8_t&gt;(value);</span><br><span class="line">    buffer[1] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 8);</span><br><span class="line">    buffer[2] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 16);</span><br><span class="line">    buffer[3] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 24);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先他把dst这个指针重新解释为1个指向uint8_t类型的指针然后赋值给buffer，现在buffer和dst指向同一个内存地址了，只不过他们解释这个地址里的东西的方式不同了，然后就是依次把value的每个字节的值写入buffer，也就是dst中，decode的则是反过来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline uint32_t DecodeFixed32(const char* ptr) &#123;</span><br><span class="line">  const uint8_t* const buffer = reinterpret_cast&lt;const uint8_t*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">  // Recent clang and gcc optimize this to a single mov / ldr instruction.</span><br><span class="line">  return (static_cast&lt;uint32_t&gt;(buffer[0])) |</span><br><span class="line">         (static_cast&lt;uint32_t&gt;(buffer[1]) &lt;&lt; 8) |</span><br><span class="line">         (static_cast&lt;uint32_t&gt;(buffer[2]) &lt;&lt; 16) |</span><br><span class="line">         (static_cast&lt;uint32_t&gt;(buffer[3]) &lt;&lt; 24);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是static_cast,基本等价于隐式转换，可以用在空指针转化为任意指针，可以用在整形和浮点数之间，对于继承的机制来说，可以把子类转化为父类，父类则不能反过来变为子类的，</p>
<p>const_cast</p>
<p>const_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。<br>它的使用场景我目前了解的具体是在与const string这种相关的函数签名上，具体而言，大家都知道只有const string &amp;才能引用一个右值（在不想写右值引用的情况下），而为了能让函数能接受(“ww”,”ee”)这种参数，我们就不得不把函数的参数声明为const string&amp;，那这个时候他就很有可能也返回一个const string &amp;，但往往我们并不需要这种const的限制，所以我们就可以写个没有cosnt约束的函数，在其内部使用const_cast添加或移去他的常量性，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const string &amp; shorter(const string &amp; s1, const string &amp; s2)&#123;</span><br><span class="line">  cout &lt;&lt;&quot; this is const&quot; &lt;&lt; endl;</span><br><span class="line">  return s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string &amp; shorter(string &amp; s1, string &amp; s2)&#123;</span><br><span class="line"> cout &lt;&lt;&quot;this is non const&quot; &lt;&lt; endl;</span><br><span class="line"> auto &amp;res = shorter(const_cast&lt;const string &amp;&gt;(s1), const_cast&lt;const string &amp;&gt;(s2));</span><br><span class="line"> return const_cast&lt;string &amp;&gt;(res);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"> string s1(&quot;ww&quot;);</span><br><span class="line"> string s2(&quot;Ee&quot;);</span><br><span class="line"> shorter(s1,s2);</span><br><span class="line"> shorter(&quot;ww&quot;,&quot;ee&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子不管进来的是什么样的内容，就都能处理了，</p>
<p>dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。</p>
<p>dynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-09</span><i class="fa fa-tag"></i><a class="tag" href="/tags/c/" title="c++">c++ </a><span class="leancloud_visitors"></span><span>About 1158 words, 3 min 51 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/09/CRTP%E4%B8%8E%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/">CRTP与静态多态</a></h3></div><div class="post-content"><div class="card"><p><p>CuriouslyRecurringTemplatePattern，简称CRTP，是一种实现静态多态的机制，简单而言，他的核心在于：父类是一个模板类，派生类会继承父类，且以派生类自身作为父类的模板参数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">  void print()&#123;</span><br><span class="line">    static_cast&lt;T*&gt;(*this)-&gt;imp();</span><br><span class="line">  &#125;</span><br><span class="line">  void imp()&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;this is base&quot; &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son1: public Base&lt;Son1&gt;&#123;</span><br><span class="line">  void imp()&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;this is son 1&quot; &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son2: public Base&lt;Son2&gt;&#123;</span><br><span class="line">  void imp()&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;this is son 2&quot; &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T &amp; t)&#123;</span><br><span class="line">  t.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我传入func的对象是Son1时， Base实例化为Son1，print中的static_cast就会把this指针强制转换为Son1*，也就能调用Son1自己实现的函数了，不过这里严格意义上来说并不算是多态，因为每个派生类继承的是各自实例化后的模板类，使用static_cast就能把从基类去访问派生类的成员函数了<br>似乎llvm的visitor模式采用的就是这种捏，tvm中的貌似也有涉及这种设计，后续再看</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-09</span><i class="fa fa-tag"></i><a class="tag" href="/tags/c/" title="c++">c++ </a><span class="leancloud_visitors"></span><span>About 306 words, 1 min 1 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/08/tvm%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94te%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/">tvm系列1——te代码阅读</a></h3></div><div class="post-content"><div class="card"><p><p>这篇是想探索一下tvm的te的compute和schedule具体的实现代码，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = te.var(&quot;n&quot;)</span><br><span class="line">A = te.placeholder((n,), name=&quot;A&quot;)</span><br><span class="line">B = te.placeholder((n,), name=&quot;B&quot;)</span><br><span class="line">C = te.compute(A.shape, lambda i: A[i] + B[i], name=&quot;C&quot;)</span><br></pre></td></tr></table></figure>
<p>上面这段假如熟悉tvm的应该再熟悉不过了，首先第1句话，返回的是tvm.tir.Var的数据类型的变量，这个是tir上的数据结构，后面再解析<br>下面的A和B的placeholder如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def placeholder(shape, dtype=None, name=&quot;placeholder&quot;):</span><br><span class="line">    shape = (shape,) if isinstance(shape, tvm.tir.PrimExpr) else shape</span><br><span class="line">    dtype = &quot;float32&quot; if dtype is None else dtype</span><br><span class="line">    return _ffi_api.Placeholder(shape, dtype, name)</span><br></pre></td></tr></table></figure>
<p>这个tvm.tir.PrimExpr是tir大多数类的父类，然后就会调用ffi机制去使用c++写的代码，这里也没啥可以说的，返回的就是</p>
<p>到了compute，这里源码的一开始一大段都是处理参数变量名称的，不用理会，这里他会if else到最后，直接把argspec.args当做arg——names，这里他是使用inspect的getfullargspec去获取一个lambda表达式的所有信息的<br>到下面<br>dim_var = [tvm.tir.IterVar((0, s), x, 0) for x, s in zip(arg_names, shape[:out_ndim])]<br>    body = fcompute(*[v.var for v in dim_var])</p>
<p>out_ndim是第1个参数的维度，这里是1，然后s是只有1个，就是n，会用他们去构造IterVar，第1个参数是这个iter的范围，第2个是这个iter的标识，第3个是这个iter的类型，源码中写着他是datapar，应该是一般的那种iter这里构造出来的dim_var打印如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line">接下来的body部分的var其实就是上面的第2个参数，fcompute就是C中的lambda表达式，首先把var的列表给解包，在调用fcompute这个可调用对象，就是上面C的lambda表达式，这里我们再写1个看看</span><br></pre></td></tr></table></figure>
<p>n = te.var(“n”)<br>A = te.placeholder((n,n), name=”A”)<br>B = te.placeholder((n,n), name=”B”)<br>C = te.compute(A.shape, lambda i,j: A[i,j] + B[i,j], name=”C”)</p>
<pre><code>这里返回的body的类型是tvm.tir.expr.Add,主要是因为A和B都是tvm.te.Tensor,他们继承自ExprOp类，而这个类又写了一堆魔法方法，重载了一系列的运算符，比如说这里的+运算符，写了__add__函数后，最终调用这个函数
假如说在compute中，有te.sum这种reduce操作的，还会识别出其中达到reduce_axis,
</code></pre>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-08</span><i class="fa fa-tag"></i><a class="tag" href="/tags/tvm/" title="tvm">tvm </a><span class="leancloud_visitors"></span><span>About 648 words, 2 min 9 sec  read</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">Next</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>