<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="lin"><title>Hexo</title><meta name="description" content="this is my blog. love furry 捏"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a class="current" href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Hexo</a></h3><div class="description"><p>this is my blog. love furry 捏</p></div></div><ul class="social-links"><li><a href="mailto:275911105@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=275911105"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span>  </span><i class="fa fa-star"></i><span> lin</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/13/effective-modern-c-7-9/">effective modern c ++ 7-9</a></h3></div><div class="post-content"><div class="card"><p><p>条款7开始是第3章的内容，具体就是介绍了一些c+11新特性特别好用的地方<br>条款7介绍的是{}的优缺点，第1点好处就是他用来初始化时适合于所有情况，一般而言有4种初始化方式，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = 2;</span><br><span class="line">int x(2);</span><br><span class="line">int x = &#123;2&#125;;</span><br><span class="line">int x&#123;2&#125;;</span><br></pre></td></tr></table></figure>
<p>后面2种其实都是同1个，而如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;</span><br><span class="line">Widget w2 = w1;</span><br><span class="line">w1 = w2;</span><br></pre></td></tr></table></figure>
<p>这里的赋值并不是初始化，而是复制构造函数,最后的调用的也是赋值运算符的重载<br>大括号初始化的第1点优势在于可以用其初始化容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vec &#123;1,3,4&#125;;</span><br></pre></td></tr></table></figure>
<p>第2点是可以用来给非静态成员赋初始值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int x&#123;2&#125;;</span><br><span class="line">    int y = 0;</span><br><span class="line">    int z(0); //error! </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第3点是可以用来给不可复制的对象进行初始化，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;int&gt; x = 0; //error!!!</span><br><span class="line">std::atomic&lt;int&gt; y&#123;2&#125;;</span><br><span class="line">std::atomic&lt;int&gt; z(0);</span><br></pre></td></tr></table></figure>
<p>从2和3点可以看出，只有大括号初始化在这些情况下是可以通用的，所以说大括号是一种大一统初始化的方式<br>大括号还有1种特性，括号内是不能使用窄式类型转换的，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doube x, y, z;</span><br><span class="line">int sum1 &#123;x + y + z&#125;;</span><br></pre></td></tr></table></figure>
<p>上面不能确定double之和能不能用int表示</p>
<p>大括号的第4点好处是避免了很烦人的解析语法，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget w(10);</span><br><span class="line">Widget w;</span><br><span class="line">Widget w();//变成函数声明了</span><br><span class="line">Widget w&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面第3行本想用无参构造函数，结果却声明了一个返回值是Widget的无参函数，使用第4行的方式就能避免这种麻烦了<br>而使用{}的缺点在于类的构造函数的选择问题上，如果构造函数的型参有std::initializer_list且传进来的参数有机会匹配到（有机会包括进行窄式类型转换），那么他会直接忽略其他任何的构造函数，不管说这些构造函数会多匹配如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    A(int x_, double y_):x(x_), y(y_)&#123;&#125;</span><br><span class="line">    A(std::initializer_list&lt;bool&gt; list)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    int x;</span><br><span class="line">    double y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    A a&#123;10,0.5&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会报错，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: narrowing conversion of ‘10’ from ‘int’ to ‘bool’ inside &#123; &#125; [-Wnarrowing]</span><br></pre></td></tr></table></figure>
<p>虽然有一个完美符合a的构造函数，但因为编译器看到了能使用initializer_list的希望，他就直接忽视了其他构造函数了<br>甚至说以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Widget w&#123;w2&#125;;</span><br><span class="line">Widget w3&#123;std::move(w)&#125;;</span><br></pre></td></tr></table></figure>
<p>本来会使用复制构造函数和移动构造函数的，但如果有上述条件。他还是会调用initializer_list<br>只有当真的没办法匹配到这个initializer_list型参的构造函数的时候，其他构造函数才会成为候选<br>最后1个问题就是上面的无参构造函数了，在使用{}的时候表示的是无参，而不是没有元素的空的初始化列表，如果想表示后者，应该这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w&#123;&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>而（）和{}的区别，也导致说初始化容器的时候，可能会有意想不到的结果，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vec (10, 20);</span><br><span class="line">vector&lt;int&gt; vec2 &#123;10, 20&#125;;</span><br></pre></td></tr></table></figure>
<p>第1个是创建了一个元素都是20.共10个的vector，而第2个则是有2个元素，分别为10和20<br>这种接口作者认为是失败的</p>
<p>条款8则是介绍了nullptr这个特性，在没有他之前，我们想表示空指针需要使用0和NULL,但前者本质是一个int，不是一个指针，而NULL根据具体的实现不同而不同，但本质也是1个整形数据而不是1个指针，所以在下面的场景中，那个参数为void *的函数是永远不会被调用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func(int)&#123;&#125;</span><br><span class="line">void func(void *)&#123;&#125;</span><br><span class="line">void func(bool)&#123;&#125;</span><br><span class="line">func(0);</span><br><span class="line">func(NULL);</span><br></pre></td></tr></table></figure>
<p>NULL可能是由long实现的，可能带来歧义，但这里本质的问题在于传入的本意是个指针，结果却调用了非指针版本的矛盾<br>因此，nullptr登上了舞台，他不具备整型类型，永远不会像0和NULL一样被解释为一个整形，且他可以隐式转换为任何其他类型的指针，此时func(nullptr)调用的就是void *类型的func了<br>使用他的优点是在使用auto的场景下，到底一个变量是整数还是空指针，这个在有nullptr的情况下就很明了了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">auto func()</span><br><span class="line">-&gt;decltype(result)</span><br><span class="line">&#123;</span><br><span class="line">    if(result == nullptr)&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如这里的nullptr是0的话，auto就推导为int，但我们本意是拿result去和空指针比较，所以用上nullptr，result就一定是个指针了<br>既然说到了auto，那模板推导也必然受益于nullptr了<br>如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename P&gt;</span><br><span class="line">void func(T t, P ptr)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">func(3, 0);</span><br><span class="line">func(3, NULL);</span><br><span class="line">func(3, nullptr);</span><br></pre></td></tr></table></figure>
<p>上面前2个调用会使得P被推导为int或long的整型数据，只有使用nullptr才使得P被推导为指针类型</p>
<p>条款9讲的是using用来声明类型别名的优势<br>在不使用类型别名的时候，我们声明一个变量可能很痛苦，使用using就变简单多了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using MyType = std::unique_ptr&lt;std::unordered_map&lt;std::string,int&gt;&gt;;</span><br></pre></td></tr></table></figure>
<p>当然我们可以使用typedef去弄别名，在上面的场景和下面这种，2者没啥区别，最多是可读性上不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using fp = void(*)(int ,double);</span><br><span class="line">typedef void (*fp)(int, double);</span><br></pre></td></tr></table></figure>
<p>而using的优点在于模板的别名上，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">using MyList = std::list&lt;T,MyAlloc&lt;T&gt;&gt;; //MyAlloc是自定义的</span><br><span class="line">MyList&lt;int&gt; l1;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct MyList&#123;</span><br><span class="line">    typedef std::list&lt;T,MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">MyList&lt;int&gt;::type l2;</span><br></pre></td></tr></table></figure>
<p>可以看出使用using比typedef方便多了，不用说去弄个struct写了一堆，而且如果想用上面的这个类型去用做类模板，using同样更加方便</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class&#123;</span><br><span class="line">private:</span><br><span class="line">    typename MyList&lt;T&gt;::type list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class&#123;</span><br><span class="line">private:</span><br><span class="line">    MyList&lt;T&gt; list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第2种就是使用using的写法，第1种既要typename又要::type，比较麻烦</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 1580 words, 5 min 16 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/12/effective-modern-c-4-6/">effective modern c ++ 4-6</a></h3></div><div class="post-content"><div class="card"><p><p>条款4是教如何去获取类型推导结果的，第一种就是利用IDE去获取，第2种我们可以声明一个类模板但不去定义他，然后使用decltype(x)让编译器报错，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class TD;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"> const int x = 3;</span><br><span class="line"> TD&lt;decltype(x)&gt; xtype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时编译器报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: aggregate ‘TD&lt;const int&gt; xtype’ has incomplete type and cannot be defined</span><br><span class="line">  TD&lt;decltype(x)&gt; xtype;</span><br></pre></td></tr></table></figure>
<p>可以看到x的确被推导为const int<br>还有1种就是使用type_info,在大多数情况下他是正确的，但他推导的方式是安值推导的，也就是说，引用和常量性会被忽略，所以他并不可靠，</p>
<p>接下来是条款5，是开始了第2大章，关于auto的使用<br>条款5具体讲了一些应用auto带来的方便与好处<br>第1个就是在使用iterator的时候，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename It&gt;</span><br><span class="line">void func(It b, It e)&#123;</span><br><span class="line">    while(b!=e)&#123;</span><br><span class="line">        typename std::iterator_traits&lt;It&gt;::value_type</span><br><span class="line">        val = *b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这一段，我们使用萃取去获取这个迭代器到底指向啥东西，写起来十分的拗口麻烦，我们可以利用auto直接写成auto val = *b；<br>第2个就是使用auto来保证变量一定能初始化，解决变量未初始化的行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto i; // 不能通过</span><br><span class="line">auto i = 2;</span><br></pre></td></tr></table></figure>
<p>第3个就是使用lambda表达式时，这个lambda对象到底是个什么类型，这个是由编译器决定的，所以我们需要利用auto用来把lambda表达式赋值给某个变量名，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto lam = []()&#123; return 0; &#125;;</span><br></pre></td></tr></table></figure>
<p>当然我们也可以用一个std::function去持有这个lambda，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;bool(int,int)&gt;</span><br><span class="line">myfunc = [](int x, int y)&#123; return true;&#125;;</span><br></pre></td></tr></table></figure>
<p>而其缺点在于function本身就是一个对象，他本身就是需要内存的，在内存上来说auto来的更好，<br>第4个就是对于一些硬件依赖的typename，比如unsigned，在32位上和在64位上不同的，单单指定某个变量是unsigned可能会在不同机器上带来出乎意料的结果，因此我们可以利用auto</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto size = v.size();</span><br></pre></td></tr></table></figure>
<p>第5个还是在迭代的时候，我们对于一些容器他储存方式不熟悉带来的问题，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(const std::pair&lt;std::string, int&gt; &amp;p :m)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>m是个unorder_map,他本身是由std::pair&lt;const std::string, int&gt;组成的，不是上面这种方式，也就是说，程序跑到这段代码，会复制容器里的每一个元素，然后引用再去指向这些临时对象，可想而知多非时间，而使用auto很容易就解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for（const auto &amp;p:m)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，auto也是得看实际的使用场景，大多数情况下使用得当能提升我们编程的效率的<br>条款6 介绍的是使用auto可能遇到的坑，在这种时候就得采用传统的方式了<br>第1个，就是vector&lt;bool&gt;这个和其他vector格格不入的对象，对于一般的vector&lt;T&gt;[],他能返回一个T&amp;类型的东西，但vector&lt;bool&gt;他本身是特化过的，他底层是使用比特去表示这1个1个的bool，而c++又不能返回1个对比特的引用，所以他只能返回一个用来模拟bool&amp;的reference，即std::vector&lt;bool&gt;::reference,他能够像bool进行隐式转换，所以对下面语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector\&lt;bool&gt; vec&#123;true,true&#125;;</span><br><span class="line">bool is_true = vec[0];</span><br></pre></td></tr></table></figure>
<p>这里取出来的vec[0]实际是个std::vector&lt;bool&gt;::reference，但他可以转换为bool，所以没啥问题<br>但假如我们使用auto去声明is_true,得到他类型就是std::vector<bool>::reference了，他就不是指代第1个元素是否为true的变量了<br>书里介绍的这种情况带来的问题在于可能出现悬空指针，例如，当我们函数的返回值是个vector<bool>时，他是个临时对象，而他实现获取第1个元素的方式，有一种实现是通过指针+偏移量的方式去获取，而我们如果使用auto is_true = bool_vectroy()[0]时，is_true和临时对象的指针指向同一个东西，而临时对象在这一句话后就解析了，那is_true就指向1个被析构了的地址了，</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 1156 words, 3 min 51 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/12/effective-modern-c-1-3/">effective modern c ++ 1-3</a></h3></div><div class="post-content"><div class="card"><p><p>条款1是对模板参数推导的几个细则，具体以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void func(ParamType param)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用func(expr)去调用时，它会推导T和param的形别，这2种有的时候是一样的，有的时候由于常量这些标识而不同，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void func(const T&amp; param)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在使用一个int 变量i去调用func时，T是iNT,而PARAMTYPE是const int&amp;<br>具体则分三种情况去讨论<br>第1种是paramtype是一个非万能引用，此时的判断方法是：如果expr具有引用，把引用给忽略，然后再去推导，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void func(T&amp; param)&#123;&#125;</span><br><span class="line"></span><br><span class="line">int x = 2;</span><br><span class="line">const int cx = x;</span><br><span class="line">const int&amp; rx = x;</span><br></pre></td></tr></table></figure>
<p>那么在调用func的时候，对x，T是int，paramtype是int&amp;，而后面2个T是const int，而paramtype是const int&amp;，因为第3个expr的引用是会被忽略的，这里也可以看出，持有T&amp;的模板，它能保证传进来的对量的常量性能被捕获<br>第2种是paramtype是一个万能引用，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T&amp;&amp; param)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候就使用引用折叠，可知如果传进来的expr是左值，T和paramtype都会推导为左值引用，如果expr是右值，则根据1的规矩即可</p>
<p>第3种情况就是paramtype不是引用，那么就是说函数是按值传参的，他复制了一个新的对象，此时他对expr，会忽视他的const，volatile和引用，所以对上面的，x，cx，rx，如果模板声明如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T param)</span><br></pre></td></tr></table></figure>
<p>那么T和paramtype最终都是int，这个也是可以理解的——本身传进来后我是构建的新的对象，不会对外面的一切造成干扰<br>这里还有1种特殊情况，即指向常量的常量指针，const int * const ptr,那么传进来之后，<em>右边的const会被忽略，因为传进来的本质是1个地址，这个值就像前面那个const int一样，所以他就被忽略了，那么进来后，T会被推导为const int</em>，指向常量的指针<br>最后就是关于数组的问题了，这里直接结论如下：<br>当paramtype是T param时，数组形参会退化为1个指针例如<br>template<typename T><br>void func(T param)<br>const char name[] = “22”;<br>此时把name传进来时，T会推导为const char*<br>但假如paramtype是个引用，T则会推导为const char[3],而paramtype则是cost char（&amp;）[13]<br>我们可以用这一特性去推导数组长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, int N&gt;</span><br><span class="line">constexpr int getlen(T(&amp;)[N]) noexcept&#123;</span><br><span class="line">    return N;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"> int x[2] = &#123;2,3&#125;;</span><br><span class="line"> char y[getlen(x)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条款2是auto推导的规则，他的规则上和模板推导的基本一致，但有一点很特别，在使用c++11引入的初始化方式中，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto x&#123;3&#125;;</span><br><span class="line">auto x=&#123;3&#125;;</span><br></pre></td></tr></table></figure>
<p>此时auto推导型别会推导出std:: initializer_list<int>，且其中只有1个元素的变量，所以如下代码编译是会失败的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto y&#123;2,3,3.0&#125;;</span><br></pre></td></tr></table></figure>
<p>因为对std:: initializer_list<T>的T推导不出是什么<br>这里的本质是有2次推导，第1个是推导出y的型别为std:: initializer_list（因为使用了大括号去初始化），第2次是推导std:: initializer_list<T>的T的类型，而如果我们想利用模板去实现这一点是做不到的，因为auto他本身对大括号初始化就假定了第1次推导必定是std:: initializer_list，而模板没办法，所以如果真要用模板，可以这么实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(std:: initializer_list&lt;T&gt; list);</span><br></pre></td></tr></table></figure>
<p>对于func({2,3,3})的调用，上面模板就起效了<br>最后还补充了1点，在c++14的标准中，可以单独用auto去说明函数返回值/lambda表达式的形参需要推导，但此时他是使用模板推导去推导的，所以说返回值不能使用大括号</p>
<p>条款3是decltype的使用<br>一般的，对于大多数std的容器，其[]的使用会返回对应位置的元素的引用，除了vector<bool>以外，<br>而在c++14中，正如在条款2中提到的，我们可以只使用auto不加decltype去推导返回值类型，此时使用的是模板类型的推导，那以下代码就有问题了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename container, typename index&gt;</span><br><span class="line">auto getindex(container &amp; c,index i)&#123;</span><br><span class="line">    return c[i];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"> std::vector&lt;int&gt; vec &#123;3,4,4&#125;;</span><br><span class="line"> getindex(vec,2) = 10;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>上面的代码执行如下：首先这里采用的是模板推导，且auto没有&amp;或者&amp;&amp;的修饰，即采用条款1种的第3种规则，此时型参的一切引用都会被忽略，即c[i]返回的int&amp;被看成是int，那么T和paramtype就是int了，此时返回的是1个临时值，是个右值，不能放在等号左侧，所以很明显他会报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: lvalue required as left operand of assignment</span><br><span class="line">  getindex(vec,2) = 10;</span><br></pre></td></tr></table></figure>
<p>解决方法是把auto改成decltype（auto），告诉他说推导过程用的是decltype的规则，而他对于int&amp;就是推导为int&amp;，或者我们直接使用后置类型推导，也比较清晰<br>那这里还有1个不完美的在于，getindex他只能接受1个左值容器，对于一些右值容器，比如说一些工厂函数的返回值，我们直接传入，此时需要用万能引用和完美转发去解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename container, typename index&gt;</span><br><span class="line">decltype(auto) func(container &amp;&amp; c, index i)&#123;</span><br><span class="line">    return std::forward&lt;container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，decltype还有一个坑，如果decltype（sth），sth仅仅只是1个变量名，如x，一切如旧；但假如sth是(x),c++仍把他看做是左值表达式，此时decltype必须推导出是一个引用类型，那么对下列代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">decltype(auto) func()&#123;</span><br><span class="line">    int x = 2;</span><br><span class="line">    return (x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他会返回1个局部变量的引用，这是一个危险的未定义行为，所以使用decltype一定要小心，里面的东西到底是什么</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 1615 words, 5 min 23 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/09/leveldb%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%971-skiplist/">leveldb源码系列1-skiplist</a></h3></div><div class="post-content"><div class="card"><p><p>本文分析的是leveldb中的跳表skip list的实现，他会把user key和user value打包成一个更大的key塞入list中<br>跳表的一个例子如下图</p>
<p>可以看到，每一个node，它都有不同的高度，且每个节点都在第0层都有出现，第0层就像最简单的链表一样，而到了上面的层数节点的个数越来越少，就像树状结构那种，跳表的许多操作都能在logn的复杂度下完成，<br>leveldb的主要结构包括skiplist，内部是由一系列的node构成的，他还实现了一个iterator用于遍历<br>接下来首先看node的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">struct SkipList&lt;Key, Comparator&gt;::Node &#123;</span><br><span class="line">  explicit Node(const Key&amp; k) : key(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Key const key;</span><br><span class="line"></span><br><span class="line">  // Accessors/mutators for links.  Wrapped in methods so we can</span><br><span class="line">  // add the appropriate barriers as necessary.</span><br><span class="line">  Node* Next(int n) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    // Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span><br><span class="line">    // version of the returned Node.</span><br><span class="line">    return next_[n].load(std::memory_order_acquire);</span><br><span class="line">  &#125;</span><br><span class="line">  void SetNext(int n, Node* x) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    // Use a &#x27;release store&#x27; so that anybody who reads through this</span><br><span class="line">    // pointer observes a fully initialized version of the inserted node.</span><br><span class="line">    next_[n].store(x, std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // No-barrier variants that can be safely used in a few locations.</span><br><span class="line">  Node* NoBarrier_Next(int n) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    return next_[n].load(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  void NoBarrier_SetNext(int n, Node* x) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    next_[n].store(x, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">   private:</span><br><span class="line">  // Array of length equal to the node height.  next_[0] is lowest level link.</span><br><span class="line">  // 1) 这里提前声明并申请了一个内存，用于存储第 0 层的数据，因为第 0 层必然存在数据。</span><br><span class="line">  // 2) 这里的数组长度其实就是层高，假设 next_ 长度为 n，那么就会从 next_[n-1] 开始查找。</span><br><span class="line">  // 3) 因为 skip list 的 level 并不会太大，使用数组存储 Node 指针的话对 CPU 内存更友好</span><br><span class="line">  // https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf</span><br><span class="line">  std::atomic&lt;Node*&gt; next_[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一部分主要是1个显式的构造函数，指定某个键并初始化key这个成员数据，然后是他的next_数组，这个数组主要是用来存放该结点的每一层的next结点的指针的，指定为1是因为必然要在第0层有该结点，接下来是他的2个无锁操作和2个不用内存屏障的操作，next这个无锁操作使用了next_这个原子对象的load函数，且指定了memory_order_acquire,那么在这个语句之前的都不会被重排到他后面了，而setnext则是store函数，指定了memory_order_release，则该语句后面的内容都不会重排到他前面去，<br>后面的2个则是使用了memory_order_relaxed,他只保证这条语句他是原子的，语句前后怎么重排都没有限制<br>接下来是一个生成新结点的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::NewNode(</span><br><span class="line">    const Key&amp; key, int height) &#123;</span><br><span class="line">  // 内存分配时只需要再分配 level - 1 层，因为第 0 层已经预先分配完毕了。</span><br><span class="line">  char* const node_memory = arena_-&gt;AllocateAligned(</span><br><span class="line">      sizeof(Node) + sizeof(std::atomic&lt;Node*&gt;) * (height - 1));</span><br><span class="line">  // 这里是 placement new 的写法，在现有的内存上进行 new object</span><br><span class="line">  return new (node_memory) Node(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2行开头的typename是为了告诉编译器，后面这个::Node是一个类型，那么整个函数的返回值就是NOde*了，首先分配内存，然后在这个内存上placement new，调用node的构造函数了</p>
<p>接下来是skiplist的成员函数<br>第一个是生成随机层数的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">int SkipList&lt;Key, Comparator&gt;::RandomHeight() &#123;</span><br><span class="line">  // Increase height with probability 1 in kBranching</span><br><span class="line">  static const unsigned int kBranching = 4;</span><br><span class="line">  int height = 1;</span><br><span class="line">  while (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == 0)) &#123;</span><br><span class="line">    height++;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(height &gt; 0);</span><br><span class="line">  assert(height &lt;= kMaxHeight);</span><br><span class="line">  return height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先初始化height为1，接着以1/4的概率使得while成立（在height比kmaxheight小的情况下），这样子第1层的node个数就大致是第0的1/4了，后面的层数以此类推，而用1/4这个概率貌似也是提出跳表的论文中建议的？<br>接下来是一个key的大小顺序的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">bool SkipList&lt;Key, Comparator&gt;::KeyIsAfterNode(const Key&amp; key, Node* n) const &#123;</span><br><span class="line">  // null n is considered infinite</span><br><span class="line">  return (n != nullptr) &amp;&amp; (compare_(n-&gt;key, key) &lt; 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当要比较的对象（比如说是next节点指向的某一层对象）不为空且compare比较器得到的结果小于0时，说明这个key在顺序上是在n后面的，</p>
<p>接下来就是查找在每一层上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(const Key&amp; key,</span><br><span class="line">                                              Node** prev) const &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  int level = GetMaxHeight() - 1;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    /* 获取当前 level 层的下一个节点 */</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line"></span><br><span class="line">    if (KeyIsAfterNode(key, next)) &#123;</span><br><span class="line">      // Keep searching in this list</span><br><span class="line">      x = next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // prev 数组主要记录的就是每一层的 prev 节点，主要用于插入和删除时使用</span><br><span class="line">      if (prev != nullptr) prev[level] = x;</span><br><span class="line">      if (level == 0) &#123;</span><br><span class="line">        return next;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // Switch to next list</span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的GetMaxHeight函数获取的是当前结点的层数，我们从这个节点的最高层开始找，不断获取他的next节点，判断这个node他</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-09</span><i class="fa fa-tag"></i><a class="tag" href="/tags/leveldb/" title="leveldb">leveldb </a><span class="leancloud_visitors"></span><span>About 1319 words, 4 min 23 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/09/4%E7%A7%8Dc-%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">4种c++风格的类型转换</a></h3></div><div class="post-content"><div class="card"><p><p>reinterpret_cast<typename1>(value),他可以把一个指针转化为另外1种指针，也可以把1个整型值赋给一个指针，其最本质在于不修改value的底层二进制位，只是修改了去解释他的方法，比如说同一个二进制数，我用整数补码（int）和float类型那个ieee标准去解释结果肯定不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a = 0;</span><br><span class="line">int* p = &amp;a;</span><br><span class="line">char* p2 = reinterpret_cast&lt;char *&gt;(p);</span><br><span class="line">*p2 = &#x27;1&#x27;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的输出结果为49，正好是a的asci值，首先他会把p这个int指针强制转换为char类型的指针，而且他指向了a的最低位（在我们机器上是小端存储的的），我们解引用赋值，其实就是在a的最低位字节上赋值了整数49，当用char的方式去解读时读出来的就是’a’,int则是49了，<br>还有另外一种使用方式就是把一个整数赋值给一个指针，然后这个指针就指向这个地址了，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* p;</span><br><span class="line">int address = 0x12345678;</span><br><span class="line">p = reinterpret_cast&lt;int*&gt;(address);</span><br></pre></td></tr></table></figure>
<p>当然这种得是你能访问这个地址才行</p>
<p>而这种强制转换在leveldb中的fixedint编码中就使用了，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inline void EncodeFixed32(char* dst, uint32_t value) &#123;</span><br><span class="line">    uint8_t* const buffer = reinterpret_cast&lt;uint8_t*&gt;(dst);</span><br><span class="line">    buffer[0] = static_cast&lt;uint8_t&gt;(value);</span><br><span class="line">    buffer[1] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 8);</span><br><span class="line">    buffer[2] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 16);</span><br><span class="line">    buffer[3] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 24);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先他把dst这个指针重新解释为1个指向uint8_t类型的指针然后赋值给buffer，现在buffer和dst指向同一个内存地址了，只不过他们解释这个地址里的东西的方式不同了，然后就是依次把value的每个字节的值写入buffer，也就是dst中，decode的则是反过来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline uint32_t DecodeFixed32(const char* ptr) &#123;</span><br><span class="line">  const uint8_t* const buffer = reinterpret_cast&lt;const uint8_t*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">  // Recent clang and gcc optimize this to a single mov / ldr instruction.</span><br><span class="line">  return (static_cast&lt;uint32_t&gt;(buffer[0])) |</span><br><span class="line">         (static_cast&lt;uint32_t&gt;(buffer[1]) &lt;&lt; 8) |</span><br><span class="line">         (static_cast&lt;uint32_t&gt;(buffer[2]) &lt;&lt; 16) |</span><br><span class="line">         (static_cast&lt;uint32_t&gt;(buffer[3]) &lt;&lt; 24);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是static_cast,基本等价于隐式转换，可以用在空指针转化为任意指针，可以用在整形和浮点数之间，对于继承的机制来说，可以把子类转化为父类，父类则不能反过来变为子类的，</p>
<p>const_cast</p>
<p>const_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。<br>它的使用场景我目前了解的具体是在与const string这种相关的函数签名上，具体而言，大家都知道只有const string &amp;才能引用一个右值（在不想写右值引用的情况下），而为了能让函数能接受(“ww”,”ee”)这种参数，我们就不得不把函数的参数声明为const string&amp;，那这个时候他就很有可能也返回一个const string &amp;，但往往我们并不需要这种const的限制，所以我们就可以写个没有cosnt约束的函数，在其内部使用const_cast添加或移去他的常量性，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const string &amp; shorter(const string &amp; s1, const string &amp; s2)&#123;</span><br><span class="line">  cout &lt;&lt;&quot; this is const&quot; &lt;&lt; endl;</span><br><span class="line">  return s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string &amp; shorter(string &amp; s1, string &amp; s2)&#123;</span><br><span class="line"> cout &lt;&lt;&quot;this is non const&quot; &lt;&lt; endl;</span><br><span class="line"> auto &amp;res = shorter(const_cast&lt;const string &amp;&gt;(s1), const_cast&lt;const string &amp;&gt;(s2));</span><br><span class="line"> return const_cast&lt;string &amp;&gt;(res);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"> string s1(&quot;ww&quot;);</span><br><span class="line"> string s2(&quot;Ee&quot;);</span><br><span class="line"> shorter(s1,s2);</span><br><span class="line"> shorter(&quot;ww&quot;,&quot;ee&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子不管进来的是什么样的内容，就都能处理了，</p>
<p>dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。</p>
<p>dynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-09</span><i class="fa fa-tag"></i><a class="tag" href="/tags/c/" title="c++">c++ </a><span class="leancloud_visitors"></span><span>About 1158 words, 3 min 51 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/09/CRTP%E4%B8%8E%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/">CRTP与静态多态</a></h3></div><div class="post-content"><div class="card"><p><p>CuriouslyRecurringTemplatePattern，简称CRTP，是一种实现静态多态的机制，简单而言，他的核心在于：父类是一个模板类，派生类会继承父类，且以派生类自身作为父类的模板参数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">  void print()&#123;</span><br><span class="line">    static_cast&lt;T*&gt;(*this)-&gt;imp();</span><br><span class="line">  &#125;</span><br><span class="line">  void imp()&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;this is base&quot; &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son1: public Base&lt;Son1&gt;&#123;</span><br><span class="line">  void imp()&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;this is son 1&quot; &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son2: public Base&lt;Son2&gt;&#123;</span><br><span class="line">  void imp()&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;this is son 2&quot; &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T &amp; t)&#123;</span><br><span class="line">  t.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我传入func的对象是Son1时， Base实例化为Son1，print中的static_cast就会把this指针强制转换为Son1*，也就能调用Son1自己实现的函数了，不过这里严格意义上来说并不算是多态，因为每个派生类继承的是各自实例化后的模板类，使用static_cast就能把从基类去访问派生类的成员函数了<br>似乎llvm的visitor模式采用的就是这种捏，tvm中的貌似也有涉及这种设计，后续再看</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-09</span><i class="fa fa-tag"></i><a class="tag" href="/tags/c/" title="c++">c++ </a><span class="leancloud_visitors"></span><span>About 306 words, 1 min 1 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/08/tvm%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94te%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/">tvm系列1——te代码阅读</a></h3></div><div class="post-content"><div class="card"><p><p>这篇是想探索一下tvm的te的compute和schedule具体的实现代码，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = te.var(&quot;n&quot;)</span><br><span class="line">A = te.placeholder((n,), name=&quot;A&quot;)</span><br><span class="line">B = te.placeholder((n,), name=&quot;B&quot;)</span><br><span class="line">C = te.compute(A.shape, lambda i: A[i] + B[i], name=&quot;C&quot;)</span><br></pre></td></tr></table></figure>
<p>上面这段假如熟悉tvm的应该再熟悉不过了，首先第1句话，返回的是tvm.tir.Var的数据类型的变量，这个是tir上的数据结构，后面再解析<br>下面的A和B的placeholder如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def placeholder(shape, dtype=None, name=&quot;placeholder&quot;):</span><br><span class="line">    shape = (shape,) if isinstance(shape, tvm.tir.PrimExpr) else shape</span><br><span class="line">    dtype = &quot;float32&quot; if dtype is None else dtype</span><br><span class="line">    return _ffi_api.Placeholder(shape, dtype, name)</span><br></pre></td></tr></table></figure>
<p>这个tvm.tir.PrimExpr是tir大多数类的父类，然后就会调用ffi机制去使用c++写的代码，这里也没啥可以说的，返回的就是</p>
<p>到了compute，这里源码的一开始一大段都是处理参数变量名称的，不用理会，这里他会if else到最后，直接把argspec.args当做arg——names，这里他是使用inspect的getfullargspec去获取一个lambda表达式的所有信息的<br>到下面<br>dim_var = [tvm.tir.IterVar((0, s), x, 0) for x, s in zip(arg_names, shape[:out_ndim])]<br>    body = fcompute(*[v.var for v in dim_var])</p>
<p>out_ndim是第1个参数的维度，这里是1，然后s是只有1个，就是n，会用他们去构造IterVar，第1个参数是这个iter的范围，第2个是这个iter的标识，第3个是这个iter的类型，源码中写着他是datapar，应该是一般的那种iter这里构造出来的dim_var打印如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line">接下来的body部分的var其实就是上面的第2个参数，fcompute就是C中的lambda表达式，首先把var的列表给解包，在调用fcompute这个可调用对象，就是上面C的lambda表达式，这里我们再写1个看看</span><br></pre></td></tr></table></figure>
<p>n = te.var(“n”)<br>A = te.placeholder((n,n), name=”A”)<br>B = te.placeholder((n,n), name=”B”)<br>C = te.compute(A.shape, lambda i,j: A[i,j] + B[i,j], name=”C”)</p>
<pre><code>这里返回的body的类型是tvm.tir.expr.Add,主要是因为A和B都是tvm.te.Tensor,他们继承自ExprOp类，而这个类又写了一堆魔法方法，重载了一系列的运算符，比如说这里的+运算符，写了__add__函数后，最终调用这个函数
假如说在compute中，有te.sum这种reduce操作的，还会识别出其中达到reduce_axis,
</code></pre>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-08</span><i class="fa fa-tag"></i><a class="tag" href="/tags/tvm/" title="tvm">tvm </a><span class="leancloud_visitors"></span><span>About 648 words, 2 min 9 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/07/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE/">函数返回类型后置</a></h3></div><div class="post-content"><div class="card"><p><p>返回类型后置，主要的用处在于某些函数他返回的类型可能很复杂，例如返回一个函数指针等，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef void(* ret)(int,double);</span><br><span class="line">ret myfunc()&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>为了更加简洁，我们可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto myfunc() -&gt; void(*)(int,double)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的auto只是个占位符，真正的返回类型在后面，感觉和Python的写法很像捏</p>
<p>除此之外，我们还可以用decltype来推导函数的返回类型，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1, typename T2&gt;</span><br><span class="line">auto func(T1 t1, T2 t2)-&gt;decltype(t1 + t2)&#123;</span><br><span class="line">  return t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么生成的模板函数就会根据t1+t2的实际类型决定返回类型了<br>c++也允许decltype放在函数名之前表示返回类型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1, typename T2&gt;</span><br><span class="line">decltype(T1() + T2()) func(T1 t1, T2 t2)&#123;</span><br><span class="line">  return t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么写虽然说也可以，但实际不这么建议使用，1是他需要要求T1和T2有无参构造函数，2是不够简洁</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-07</span><i class="fa fa-tag"></i><a class="tag" href="/tags/c/" title="c++">c++ </a><span class="leancloud_visitors"></span><span>About 258 words, 51 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/07/%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0/">引用折叠</a></h3></div><div class="post-content"><div class="card"><p><p>所谓的万能引用主要是用在以下2种场合：<br>第1种是模板如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T&amp;&amp; t)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中的&amp;&amp;并不是右值引用的意思，他是表示说这个t肯定是一个引用类型，但具体是左值引用还是右值引用我们得根据传进来的参数确定<br>那如何根据传进来的参数确定呢，这里就用到了引用折叠了，具体而言，当T被推导出来是右值时，T&amp;&amp;是一个右值引用（&amp;&amp; &amp;&amp; 折叠为了&amp;&amp;），而其他情况都是折叠为&amp;，即左值引用<br>为了验证，我们可以用完美转发来验证一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">void print(int&amp; t)&#123;</span><br><span class="line">  std::cout &lt;&lt; &quot;left&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void print(int&amp;&amp; t)&#123;</span><br><span class="line">  std::cout &lt;&lt; &quot;right&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T&amp;&amp; t)&#123;</span><br><span class="line">  print(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  int x = 10;</span><br><span class="line">  func(x);</span><br><span class="line">  func(12);</span><br><span class="line">  func(std::move(x));</span><br><span class="line">  int&amp; y = x;</span><br><span class="line">  func(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码第1个显示是left，x是一个左值为什么被推导为左值引用呢，因为在func的参数里，传进来的T&amp;&amp;必须被解释为1个引用，那T就可以是int，int&amp;，int&amp;&amp;，只有int&amp;能被推断为左值(int&amp; &amp;&amp;折叠为&amp;)，第2个则是right，T是实例化为int，第3个为right，T为int&amp;&amp;，第4个T为int&amp;，折叠为&amp;，所以结果是left</p>
<p>第2种使用万能引用的场合是在auto推断中，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto&amp;&amp; i = 3； //auto推断为int，i为int&amp;&amp;类型，即右值引用</span><br><span class="line">auto&amp;&amp; j = i; // auto推断为int&amp;，i为int&amp;，即左值引用</span><br></pre></td></tr></table></figure>

</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-07</span><i class="fa fa-tag"></i><a class="tag" href="/tags/c/" title="c++">c++ </a><span class="leancloud_visitors"></span><span>About 475 words, 1 min 35 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/07/%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%89%A9%E5%B1%95%E5%93%88%E5%B8%8C%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/">一个可扩展哈希代码阅读</a></h3></div><div class="post-content"><div class="card"><p><p>可扩展哈希一般是用在数据库中管理1条1条的record的，虽然现在很多都是用B+树了<br>这个主要是做15-445的project时接触到的，project2需要实现1个可扩展哈希<br>静态的哈希随着记录的增多，其冲突的概率也越来越大，此时如果能动态扩容就能优化性能了<br>可扩展哈希的主要成员就2个，一个是bucket，它内部存放的就是1条1条的记录，一般初始化的时候就指定他的可存放记录的数目，多个bucket就构成了整个hash表<br>第2个是directory，他是1个可以扩展的数组，每个成员都是指针，指向对应的bucket，其对应的bucket就是通过哈希函数算出对应的下标，且可能会有多个成员指向同个bucket的情况，这个后面再说<br>还有的就是2个重要的概念：global depth和local depth，前者是directory的成员，它指明了每个bucket最大的local depth，也限制了其管理的bucket指针数组的大小，例如说global depth是5的时候，他的bucket数组最多就有32个，而local depth是每个bucket的成员，他指明了找到该bucket需要的位数，例如说</p>
<p>这里我分析的是<a target="_blank" rel="noopener" href="https://github.com/nitish6174/extendible-hashing/blob/master/main.cpp">https://github.com/nitish6174/extendible-hashing/blob/master/main.cpp</a><br>里面的代码，内容还是比较好懂的<br>接下来首先是他的bucket部分，这个比较简单，就是一些常规的增删查改操作，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">Bucket::Bucket(int depth, int size)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;depth = depth;</span><br><span class="line">    this-&gt;size = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Bucket::insert(int key, string value)</span><br><span class="line">&#123;</span><br><span class="line">    std::map&lt;int,string&gt;::iterator it;</span><br><span class="line">    it = values.find(key);</span><br><span class="line">    if(it!=values.end())</span><br><span class="line">        return -1;</span><br><span class="line">    if(isFull())</span><br><span class="line">        return 0;</span><br><span class="line">    values[key] = value;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Bucket::remove(int key)</span><br><span class="line">&#123;</span><br><span class="line">    std::map&lt;int,string&gt;::iterator it;</span><br><span class="line">    it = values.find(key);</span><br><span class="line">    if(it!=values.end())</span><br><span class="line">    &#123;</span><br><span class="line">        values.erase(it);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Cannot remove : This key does not exists&quot;&lt;&lt;endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Bucket::update(int key, string value)</span><br><span class="line">&#123;</span><br><span class="line">    std::map&lt;int,string&gt;::iterator it;</span><br><span class="line">    it = values.find(key);</span><br><span class="line">    if(it!=values.end())</span><br><span class="line">    &#123;</span><br><span class="line">        values[key] = value;</span><br><span class="line">        cout&lt;&lt;&quot;Value updated&quot;&lt;&lt;endl;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Cannot update : This key does not exists&quot;&lt;&lt;endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Bucket::search(int key)</span><br><span class="line">&#123;</span><br><span class="line">    std::map&lt;int,string&gt;::iterator it;</span><br><span class="line">    it = values.find(key);</span><br><span class="line">    if(it!=values.end())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Value = &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;This key does not exists&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Bucket::isFull(void)</span><br><span class="line">&#123;</span><br><span class="line">    if(values.size()==size)</span><br><span class="line">        return 1;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Bucket::isEmpty(void)</span><br><span class="line">&#123;</span><br><span class="line">    if(values.size()==0)</span><br><span class="line">        return 1;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Bucket::getDepth(void)</span><br><span class="line">&#123;</span><br><span class="line">    return depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Bucket::increaseDepth(void)</span><br><span class="line">&#123;</span><br><span class="line">    depth++;</span><br><span class="line">    return depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Bucket::decreaseDepth(void)</span><br><span class="line">&#123;</span><br><span class="line">    depth--;</span><br><span class="line">    return depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::map&lt;int, string&gt; Bucket::copy(void)</span><br><span class="line">&#123;</span><br><span class="line">    std::map&lt;int, string&gt; temp(values.begin(),values.end());</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Bucket::clear(void)</span><br><span class="line">&#123;</span><br><span class="line">    values.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Bucket::display()</span><br><span class="line">&#123;</span><br><span class="line">    std::map&lt;int,string&gt;::iterator it;</span><br><span class="line">    for(it=values.begin();it!=values.end();it++)</span><br><span class="line">        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是directory的内容，首先是他的构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Directory::Directory(int depth, int bucket_size)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;global_depth = depth;</span><br><span class="line">    this-&gt;bucket_size = bucket_size;</span><br><span class="line">    for(int i = 0 ; i &lt; 1&lt;&lt;depth ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        buckets.push_back(new Bucket(depth,bucket_size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，他一开始的local depth和global depth是一样的，其哈希函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int Directory::hash(int n)</span><br><span class="line">&#123;</span><br><span class="line">    return n&amp;((1&lt;&lt;global_depth)-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很直白的，就是取n的二进制位的最后global depth位做为哈希值，例如说当global depth为3时，上面就是n&amp;7（111）了<br>下面是一个取pair的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int Directory::pairIndex(int bucket_no, int depth)</span><br><span class="line">&#123;</span><br><span class="line">    return bucket_no^(1&lt;&lt;(depth-1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是在桶进行split的时候调用的，这里在被调用时被分裂的桶的bucket_no+1才等于参数depth，例如说bucket_no是6（110）的时候，depth是4，那么做取异操作后，返回的是14（1110），和原来的6（0110）相比，就是在增加的哈希位上不同了，这里具体为啥这么做见后面的grow就知道了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Directory::grow(void)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0 ; i &lt; 1&lt;&lt;global_depth ; i++ )</span><br><span class="line">        buckets.push_back(buckets[i]);</span><br><span class="line">    global_depth++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>grow函数是在bucket分裂时发现他分裂后的local depth比global depth还大时调用的，调用后bucket数组翻倍，而且他翻倍后多出来的数组元素，比如说原来是n个，现在2n个，第n+1个和第1个指向同1个bucket，因为push_back会生成原来指针的副本，他也指向原来的指针所指对象，所以grow的过程并没有真正的创建bucket对象，只是多出了一些类似占位符的东西。而且看到这里上面的pairindex函数就明白了，pair指的就是这里的指针11对应的关系，bucket数组的第6个和第14个都指向同1个bucket对象，我们取得他的下标，给他赋予真正的新的bucket对象（见下面的split)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void Directory::split(int bucket_no)</span><br><span class="line">&#123;</span><br><span class="line">    int local_depth,pair_index,index_diff,dir_size,i;</span><br><span class="line">    map&lt;int, string&gt; temp;</span><br><span class="line">    map&lt;int, string&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">    local_depth = buckets[bucket_no]-&gt;increaseDepth();</span><br><span class="line">    if(local_depth&gt;global_depth)</span><br><span class="line">        grow();</span><br><span class="line">    pair_index = pairIndex(bucket_no,local_depth);</span><br><span class="line">    buckets[pair_index] = new Bucket(local_depth,bucket_size);</span><br><span class="line">    temp = buckets[bucket_no]-&gt;copy();</span><br><span class="line">    buckets[bucket_no]-&gt;clear();</span><br><span class="line">    index_diff = 1&lt;&lt;local_depth;</span><br><span class="line">    dir_size = 1&lt;&lt;global_depth;</span><br><span class="line">    for( i=pair_index-index_diff ; i&gt;=0 ; i-=index_diff )</span><br><span class="line">        buckets[i] = buckets[pair_index];</span><br><span class="line">    for( i=pair_index+index_diff ; i&lt;dir_size ; i+=index_diff )</span><br><span class="line">        buckets[i] = buckets[pair_index];</span><br><span class="line">    for(it=temp.begin();it!=temp.end();it++)</span><br><span class="line">        insert((*it).first,(*it).second,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是调用要分裂的那个bucket的increasedepth函数，他的local depth+1了，如果需要扩容调用grow函数，接着是找到指向同1个bucket的bucket_no(pairindex函数)，然后在他上面真正的创建1个新的bucket，然后把需要分裂的那个桶的内容赋值给temp变量并清空，准备后面的分配，而接下来的操作则是bucket数组里的某几个指向新建立的bucket，这里我们具体以一个例子说明<br>假设一开始global depth和local depth都是3，后来有某个桶7（111）他要split，发现global depth不够，于是需要grow，然后就走上述流程，接着算出index_diff和dir_size都是16，pair_index是15（1111），那么很明显2个for循环都不满足条件不执行，因为除了7和15外就没有哪个bucket_no指向相关的桶了，但假如后来桶7（0111，这个时候是4层了）又不够了，又要扩容了，global depth就变成5了，一切如上照旧；后来桶7又不够用。又分裂了，global depth变为6了，不过这个时候和原来8个桶相比，只多了3个桶而已<br>到了后面，终于是1个local depth是3的桶要分裂了，假设他是6（110），他发现global depth够用，就不用grow了，他的pair_index是14（1110），index_diff是16，dir_size是64，第1个for没走，但第2个，他会遍历30（011110），46（101110），62（111110），这3个桶都指向新分裂出来的桶，原本他们指向的和6一样的桶，至于为啥这么做，我的想法是，当global depth比local depth多到1定程度时，指向同1个桶的哈希下标是有很多的，这个时候就需要新生成的桶来分担一些，例如上面的6，在没分裂前，后3位是110的桶的下标都指向了6,的桶，分裂后，后四位是0110的依旧，但1110的则被分配去新的桶了，假如不这么做的话，到后面可能就出现某些桶需要频繁地分裂的结果<br>接下来就是insert函数，其实现如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void Directory::insert(int key,string value,bool reinserted)</span><br><span class="line">&#123;</span><br><span class="line">    int bucket_no = hash(key);</span><br><span class="line">    int status = buckets[bucket_no]-&gt;insert(key,value);</span><br><span class="line">    if(status==1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!reinserted)</span><br><span class="line">            cout&lt;&lt;&quot;Inserted key &quot;&lt;&lt;key&lt;&lt;&quot; in bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;&quot;Moved key &quot;&lt;&lt;key&lt;&lt;&quot; to bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(status==0)</span><br><span class="line">    &#123;</span><br><span class="line">        split(bucket_no);</span><br><span class="line">        insert(key,value,reinserted);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Key &quot;&lt;&lt;key&lt;&lt;&quot; already exists in bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是计算哈希值，例如说上面的例子继续下去，此时的global depth是6，这里根据上面的例子，对于后4位是1110的，他们会指向同1个桶，而后4位是0110的，他们会指向另外1个桶，可万一他原本就要溢出的桶里面，每条记录的后4位都是0110呢，这个时候他们就都走到同1个桶了，就又溢出了，这个时候上面代码就根据insert的返回值判断是否溢出，溢出了，则要对bucket_no这个桶再一次split，例如说我们假设的6（0110，现在是4位local depth），6的pair index这个时候是22了（10110），split也顺带把54指向了新生成的桶（110110，接下来就是根据5位二进制去判断了，因为我们原本假设他们后4位都是0110，现在就进一步地根据第5位是0还是1去判断走哪个桶了，如果还溢出，就继续分裂，知道没有溢出为止。<br>总结目前上述内容，就是一种平衡吧，当global depth是6的时候，在6（110）这个下标的桶还没分裂前，有8个哈希下标会指向他，分裂的同时也应该能使得new出来的桶分担一些<br>那接下来有分必有合，shrink操作函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void Directory::shrink(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i,flag=1;</span><br><span class="line">    for( i=0 ; i&lt;buckets.size() ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        if(buckets[i]-&gt;getDepth()==global_depth)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=0;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    global_depth--;</span><br><span class="line">    for(i = 0 ; i &lt; 1&lt;&lt;global_depth ; i++ )</span><br><span class="line">        buckets.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有1个桶的local depth和global depth一样，就无法缩小了，原因可以看到后面他缩小的操作，实际上就是把后半部分的bucket给去掉了，而能没有后果的去掉的前提是，这些bucket指向的对象完全和前半部分的一样，但假如其中某个桶的local depth和global depth一样，说明是经过了split中的new Bucket(local_depth,bucket_size)操作，导致这后半部分有某个桶他指向了新的对象，也就无法删除了，<br>下面是merge函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void Directory::merge(int bucket_no)</span><br><span class="line">&#123;</span><br><span class="line">    int local_depth,pair_index,index_diff,dir_size,i;</span><br><span class="line"></span><br><span class="line">    local_depth = buckets[bucket_no]-&gt;getDepth();</span><br><span class="line">    pair_index = pairIndex(bucket_no,local_depth);</span><br><span class="line">    index_diff = 1&lt;&lt;local_depth;</span><br><span class="line">    dir_size = 1&lt;&lt;global_depth;</span><br><span class="line"></span><br><span class="line">    if( buckets[pair_index]-&gt;getDepth() == local_depth )</span><br><span class="line">    &#123;</span><br><span class="line">        buckets[pair_index]-&gt;decreaseDepth();</span><br><span class="line">        delete(buckets[bucket_no]);</span><br><span class="line">        buckets[bucket_no] = buckets[pair_index];</span><br><span class="line">        for( i=bucket_no-index_diff ; i&gt;=0 ; i-=index_diff )</span><br><span class="line">            buckets[i] = buckets[pair_index];</span><br><span class="line">        for( i=bucket_no+index_diff ; i&lt;dir_size ; i+=index_diff )</span><br><span class="line">            buckets[i] = buckets[pair_index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是split反过来，例如说上面的例子，我想merge22，他的pair index是6，且他们的local depth都是5，这个时候就可以走if里面的流程，把这个local depth减1，然后删去22这个桶，且让6所指的桶的指针给了22，然后就是把那些原来指向22的桶现在指向6，就是和上面split一样的思路<br>下面是remove函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void Directory::remove(int key,int mode)</span><br><span class="line">&#123;</span><br><span class="line">    int bucket_no = hash(key);</span><br><span class="line">    if(buckets[bucket_no]-&gt;remove(key))</span><br><span class="line">        cout&lt;&lt;&quot;Deleted key &quot;&lt;&lt;key&lt;&lt;&quot; from bucket &quot;&lt;&lt;bucket_id(bucket_no)&lt;&lt;endl;</span><br><span class="line">    if(mode&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        if(buckets[bucket_no]-&gt;isEmpty() &amp;&amp; buckets[bucket_no]-&gt;getDepth()&gt;1)</span><br><span class="line">            merge(bucket_no);</span><br><span class="line">    &#125;</span><br><span class="line">    if(mode&gt;1)</span><br><span class="line">    &#123;</span><br><span class="line">        shrink();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mode是用户输入的，根据他来判断是要merge（删去某个桶）还是直接对半砍去<br>剩下的几个没列出来的也只是很简单的操作，这个代码也就分析完咯，下面就开始做project2捏</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-07</span><i class="fa fa-tag"></i><a class="tag" href="/tags/小组件/" title="小组件">小组件 </a><span class="leancloud_visitors"></span><span>About 2955 words, 9 min 51 sec  read</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">Next</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>