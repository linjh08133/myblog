<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="lin"><title>Hexo</title><meta name="description" content="this is my blog. love furry 捏"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a class="current" href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Hexo</a></h3><div class="description"><p>this is my blog. love furry 捏</p></div></div><ul class="social-links"><li><a href="mailto:275911105@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=275911105"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span>  </span><i class="fa fa-star"></i><span> lin</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/20/effective-modern-c-25-27/">effective modern c ++ 25-27</a></h3></div><div class="post-content"><div class="card"><p><p>条款25讲的还是move和forward的具体使用场景的对比，当明确要使用移动语义时用move，要使用完美转发时使用forward<br>作者一开始就警告，千万不能在本应该使用forward语义的地方使用move，因为极有可能吧1个左值的内容移动到了调用方，此时的左值就肯定不能被使用了，但这并不是我们需要的<br>实现了万能引用的函数模板如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Widget&#123;</span><br><span class="line">public:</span><br><span class="line">  template&lt;typename T&gt;</span><br><span class="line">  void setname(T&amp;&amp; newname)&#123;</span><br><span class="line">    name = forward&lt;T&gt;(newname);    </span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们当然可以提供非模板的setname函数，因为若我们有保证当进来的是左值时不去修改他的要求时，需要把形参声明为const，而此时就不是完美引用了，因为其不能有任何限定词，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void setname( const string &amp; newname)&#123;</span><br><span class="line">    name = newname;</span><br><span class="line">&#125;</span><br><span class="line">void setname(string &amp;&amp; newname)&#123;</span><br><span class="line">    name = std::move(newname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这种重载的实现方式有几个问题，1是当我们传进来1个字面量，如setname(“my”)的时候，如果是万能引用+完美转发的做法，这个字面量就直接传到赋值那一行用于构造name了，就像执行name = “my”一样，而重载的右值引用版本，需要首先构造一个临时string对象，再把临时对象的值移动到name中，然后析构这个临时对象，这就可能带来性能效率上的问题；第2个问题就是，如果函数的参数有多个，那要重载的版本就呈指数爆炸的个数了，例如make_shared函数，其声明可以简化如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T,typename ...Args&gt;</span><br><span class="line">  shared_ptr&lt;T&gt; make_shared(Arg&amp;&amp; ...args)&#123;</span><br><span class="line">    return shared_ptr&lt;T&gt;(forward&lt;T&gt;(args)...);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，重载肯定是1个很费力气的操作。<br>接下来讲的是1个小原则——当我们对1个变量想使用move语义或者forward时，得保证之后不会再用这个对象，也就是说，只有在最后1次与该变量相关的语句中才能使用move/forward，这个就不用具体解释了。<br>接下来就是讲按值返回的函数中对移动语义的使用了，这里我们需要分为2种情况<br>第1种情况是，如果这个返回的内容，本身就是一个引用，不管是什么引用，都要在return语句使用move/forward，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Matrix operator+(Matrix &amp;&amp;lhs, Matrix&amp; rhs)&#123;</span><br><span class="line">    lhs += rhs;</span><br><span class="line">    return move(lhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如不使用move，那在return的时候是的的确确会构造一个匿名对象然后再把这个对象的内容复制到返回值的储存位置，而加了移动语义，他就简单的把lhs这个右值移动到返回值的地方，还有可能的场景如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">T func(T&amp;&amp; t)&#123;</span><br><span class="line">    dosth;</span><br><span class="line">    return forward&lt;T&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子当t是右值的时候，就能直接把他放入返回值的地方，而是左值的时候才会有复制的成本<br>第2种情况是返回一个局部对象，这里编译器会有一种优化叫做(return value optimization），RVO,即直接在返回值的位置上去创建这个局部变量，从而省去了构造匿名对象并复制的成本<br>而编译器使用到这个优化的条件非常的苛刻，他需要满足2个条件，1个是局部变量必须和返回值类型一样，这就是说不能有隐式转换在里面，二就是返回的就是局部变量本身，此时假如我们加上了move语义，就相当于返回了一个局部变量的右值引用了，就不满足RVO条件了，这反而是破坏了优化的可能性，而针对这条优化原则，还有相关的补充——如果满足了RVO条件，要么保证不复制（直接放到返回值），要么返回一个右值对象，即和使用move语言一样的效果。那也就是说，不使用move可以达到优化的效果，因为他的确有使用右值语义的机会，但使用了move则破坏了RVO的条件，这反而帮了倒忙<br>条款26介绍的是避免依万能引用型别去重载，意思就是说，对于一个使用了万能引用作为参数的函数模板，我们要避免去重载同名的函数，具体的例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T&amp;&amp; t)&#123;</span><br><span class="line">    dosth...;</span><br><span class="line">    string temp (t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func(int t)&#123;</span><br><span class="line">    dosth...;</span><br><span class="line">    string temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子的话，对下面的函数调用，编译是可以通过的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func(&quot;wm&quot;);</span><br><span class="line">string w(&quot;ww&quot;);</span><br><span class="line">func(w);</span><br><span class="line">func(string(&quot;new&quot;));</span><br><span class="line">func(3);</span><br></pre></td></tr></table></figure>
<p>万能转发避免了许许多多的复制操作，这个是我们的的确确得到的好处，但有时候会有需要传入别的类型的参数的需要，此时我们的直觉就是去重载这个函数，让他来处理某些特定的形参的情况，但这里就有问题了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short i = 3;</span><br><span class="line">func(i);</span><br></pre></td></tr></table></figure>
<p>由于调用int版本的重载函数不是完美匹配的，因为还需要隐式类型转换，而函数模板可以实例化出1个完美匹配的模板函数出来，这个叫精确匹配，精确匹配是优先于其他版本的，所以会调用函数模板的那个版本，而这时候问题来了，string并不能接受任何形式的short形参，编译就失败了<br>问题在于函数模板是十分”贪婪”的东西，只要是他实例化出来的函数就激活都能看做是完美匹配的，也就导致了对short类型的形参无法匹配到int<br>还有1个例子就是在类中使用万能引用函数模板作为构造函数的，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Widget&#123;</span><br><span class="line">public:</span><br><span class="line">  template&lt;typename T&gt;&#123;</span><br><span class="line">    Widget(T &amp;&amp; n)&#123;</span><br><span class="line">      name = n;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Widget(int n)&#123;</span><br><span class="line">    name = &quot;e&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w(1);</span><br><span class="line"></span><br><span class="line">auto Widget(w);</span><br></pre></td></tr></table></figure>
<p>以上代码会报错，错在找不到1个=运算符，其左右操作数分别为char*和Widget的，也就是说，他这里调用了万能引用的构造函数，可是这里编译器明明是会自动生成复制构造函数的，结果却调用了别的东西。这里的原因还是因为万能引用的“贪婪”，在传入参数是w，也就是Widget的情况下，他既可以实例化widget的构造函数，T为Widget，也可以使用默认的复制构造函数，但这个构造函数的函数的参数是const Widget&amp;，也就是说他并不是完美匹配的，此时编译器就会去找实例化后的模板函数了，也就出现了一个把n（Widget）类型的变量赋值给name（String）的情况，自然会报错<br>但如果w是个const，自然的复制构造函数也完美匹配了，此时c++的标准规定，要优先使用非模板的函数，也就是说此时编译是可以通过的，但这样也莫名其妙地多了常量性<br>进一步的，在派生类中，万能引用更是会使得程序的错误更加难以推测，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Derived: public Widget&#123;</span><br><span class="line">public:</span><br><span class="line">  Derived()&#123;&#125;</span><br><span class="line">  Derived(const Derived&amp; d):Widget(d)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码会报错，因为在派生类的复制构造函数里，Widget(d)的语句会由于实例化后的模板比基类的复制构造函数（要把d转化为widget类）更加完美匹配，所以就调用了实例化后的构造函数，string类本身肯定是没有derived为参数的构造函数的，肯定过不了编译<br>所以以上的例子想说明的是，尽量不要在重载函数中使用万能引用<br>接下来的条款27想解决的就是假如真的需要万能引用做重载函数的形参时，具体的可行方案有舍弃重载，传值，用常量左值引用做形参等，接下来就是本条款的重点——用标签分类，他的思想在于，上述的万能引用，由于对大多数传进来的参数，他都能实例化出1个完美匹配的模板函数出来，那只要我们能做到，对于某些特定的类型，只要他在传进来这个类型后无法实例化就能解决问题，而这可以通过增加1个标志位形参来做到，这个标志位可以利用std::is_integral<T>()做到，具体的初步修改如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void interface(T&amp;&amp; params)&#123;</span><br><span class="line">    impl(forward&lt;T&gt;(params),</span><br><span class="line">    std::is_integral&lt;T&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这段代码，他是把所有的参数都用interface去接受，在内部再根据类型去派发具体的实现，这里后面肯定是需要2个impl的<br>接下来是需要对这个函数去修改他不合理的地方，1是关于万能引用和引用折叠，如果传进来的参数是左值的话，T就会推导为type&amp;的形式，例如int&amp;，那标志位就会判断为false了，所以我们就需要利用std的移出引用的特性remove_reference了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void interface(T&amp;&amp; params)&#123;</span><br><span class="line">    impl(forward&lt;T&gt;(params)),</span><br><span class="line">    std::is_intergral&lt;typename std::remove_reference&lt;T&gt;::type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中上述的方括号里的内容可以直接用std::remove_referenct_t<T>代替，因为这个就是使用了using写的类型别名，不用写typename指明他是类型，<br>接下来就是去写具体的实现函数了，我们需要利用std::false_type和std::true_type去做2个实现函数的标志位，因为true和false是运行时的东西，而我们需要的是一种能在编译期就告诉我们如何重载决议的东西，就是上面的2个*_type了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">impl(T&amp;&amp; params, std::false_type)&#123;</span><br><span class="line">    cout &lt;&lt; &quot;this is not integral&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">impl(T&amp;&amp; params, std::true_type)&#123;</span><br><span class="line">    cout &lt;&lt; &quot;this is intergral&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了这里，标签分类的具体内容就ok了，这些其实都算是模板元编程的东西，不过还没学2333，后续再开个坑吧<br>接下来的另外1个方式是使用enable_if,让万能引用的函数模板在某些条件下禁止实例化，这里我们继续，先写1个初步使用该特性的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">  template&lt;typename T, typename = enable_if&lt;condition&gt;::type&gt;</span><br><span class="line">  Person(T&amp;&amp; params)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么当括号里的condition为true的时候，这个实例化才被允许<br>接下来我们就需要写出这个condition，我们需要在入参是person的时候调用的是复制构造函数而不是实例化的模板构造函数，所以我们可以搭配std::is_same&lt;Person,T&gt;来判断，当然了这里同样的和上面有一样的问题，如果T实例化之后有引用/const/volatile等修饰，这个判断就为假了，所以我们需要移除这些特性，可以使用std_decay，这里我们可以简单的理解为std::decay<T>::type就是我们需要的东西了<br>因此该condition可以写为&lt;!is_same&lt;Person, std::decay<T>::type&gt;::value<br>上面的写法解决了person本身的一个构造函数的重载决议问题了，但对于其派生类来说，当入参是派生类derived时，还是会调用基类模板构造函数而不是基类的复制构造函数，因为derived明显不是person类，解决方法就是使用is_base_of替代is_same即可，即is_base_of&lt;Person,typename = enable_if&lt;!is_base_of&lt;Person,std::decay<T>::type&gt;::value&gt;::type&gt;<br>这里看上去一大串，还是比较难读的，当然我们可以使用14标准的那些别名，如下<br>is_base_if&lt;Person,typename = enable_if_t&lt;!is_base_of&lt;Person,decay_t<T>&gt;::value&gt;<br>总的来说，我们可以使用标签或者enable_of这2个现代c++特性去实现重载模板函数的决议</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-20</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 3291 words, 10 min 58 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/15/effective-modern-c-22-24/">effective modern c ++ 22-24</a></h3></div><div class="post-content"><div class="card"><p><p>接下来进入第5大章，也就是右值，移动语义和完美转发等一系列11中最重要的一大特性领域<br>条款23讲的是move和forward这2个最常见到的2个函数，他们的本质只不过是进行了强制类型转换，前者无条件的把传进来的参数转换为右值，forward则是在某种特定条件下才把参数进行转化，move的实现大致如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename remove_reference&lt;T&gt;::type&amp;&amp;</span><br><span class="line">move(T &amp;&amp; params)&#123;</span><br><span class="line">    using ReturnType =</span><br><span class="line">      typename remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    return static_cast&lt;ReturnType&gt;(params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里返回值是个右值，且为了不会因为传进来的是左值以及引用折叠导致说返回的变成了左值，需要使用remove_reference<br>传给一个函数，或者构造函数一个move后的右值，往往是想进行移动的操作，所以才叫做move<br>不过一个move的东西，他有时候不一定会进行所谓的移动操作，假如说一个函数他的参数是const的，接着我们调用move把这个参数从const &amp;变为了const &amp;&amp;，但此时他也只能匹配到复制构造函数了，因为移动构造函数只能接受非常的右值参数<br>forward的使用场景也是十分的经典了，就是在万能引用下，因为引用本身是个左值了，所以如果把万能引用的参数传入某个函数，永远也只会调用这个函数的左值版本，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void func(int &amp; num)&#123;</span><br><span class="line">    cout &lt;&lt; &quot;left&quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func(int &amp;&amp; num)&#123;</span><br><span class="line">    cout &lt;&lt;&quot;right&quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void interface(T&amp;&amp; params)&#123;</span><br><span class="line">    func(params);</span><br><span class="line">    func(forward&lt;T&gt;(params));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int i = 2;</span><br><span class="line">    interface(i);</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    interface(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两者的作用看上去似乎十分相似，但其实是十分泾渭分明的，move明确指定了要把参数转换为右值，为相关的移动操作做准备，但forward只是转发，参数是左值就转发为左值，是右值就转发为右值，2者并不是作用可以被一方替代的关系<br>条款24讲的就是万能引用和右值引用的相关内容了<br>万能引用最主要的2个使用方式就是如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T &amp;&amp; params)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">auto &amp;&amp; x = sth;</span><br></pre></td></tr></table></figure>
<p>其最本质的，就是涉及到了型别推导，所以如果遇到具体的类，如Widget&amp;&amp;,他就只是1个简单的右值引用，因为他根本就没有型别推导<br>而且这里的型别推导也必须得限制住，必须得是T&amp;&amp;的形式，其他的就不行了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(vector&lt;T&gt;&amp;&amp; params)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>上面的params是个右值引用，而且，即使是加上const关键词，也会导致其不是一个万能引用<br>而且就算是已经</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-15</span><span class="leancloud_visitors"></span><span>About 799 words, 2 min 39 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/15/effective-modern-c-19-21/">effective modern c ++ 19-21</a></h3></div><div class="post-content"><div class="card"><p><p>条款19讲的是shared_ptr的使用，他的实现大多数都是使用1个指向被管理资源的野指针+1个指向引用计数的对象的指针实现的，所以他的尺寸一般都是野指针的2倍<br>被管理的资源并不知道这个引用计数的存在<br>引用计数的内存也是动态分配管理的，其计数的增减也必须都是原子操作，<br>而在自定义删除器上，shared_ptr并不需要指定他的模板形参为这个删除器的类别，因此我们可以用容器且类别为shared_ptr<SomeClass>的方式去管理，而且不管这个删除器有多大，他都不会影响shared_ptr的大小，因为他是在引用计数那个对象上管理的，如图<br>！{}()<br>而这个控制块的生成时机，具体而言有以下几种<br>1是使用make_shared的时候，必然是在构造一个新的shared_ptr,此时也得有一个控制块的生成<br>2同理，给一个shared_ptr的实参是野指针的时候，也要1个新建的控制块，而如果传入的实参是1个shared_ptr的话，新的对象则是直接使用这个控制块而不是新建<br>3是在用1个unique_ptr出发构建的时候，也是需要控制块的，因为unique_ptr本来就没有这玩意<br>所以，在新建shared_ptr的时候，切记不要将1个野指针用于多次构造函数中，因为这样会产生多个控制块，如果控制块发现自己的计数是0的时候，就会析构这个对象，而这就会导致对象被析构多次，如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    A()&#123;x=new int(0);&#125;</span><br><span class="line">    A(int _x):x(new int(_x))&#123;&#125;</span><br><span class="line">    ~A()&#123;delete x;&#125;</span><br><span class="line">    int * x;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    A *ptr = new A(3);</span><br><span class="line">    A *ptr2 = new A(3);</span><br><span class="line">    shared_ptr&lt;A&gt; p1(ptr);</span><br><span class="line">    shared_ptr&lt;A&gt; p2(ptr);</span><br><span class="line">    shared_ptr&lt;A&gt; p3(ptr2);</span><br><span class="line">    p1 = p3;</span><br><span class="line">    p2 = p3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，对同1个对象ptr析构了2次，虽然能编译成功，但运行起来直接报错，所以，我们应该把ptr的new直接放在shared_ptr的构造函数里，这样子别人也就只能拿shared_ptr去做自己的构造函数的实参了，而这样子是不会创建新的控制块的<br>还有1种情况，就是关于this指针的，如下代码会犯和上面的一样的错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Widget&gt; processed_list&#123;&#125;;</span><br><span class="line">...</span><br><span class="line">class Widget&#123;</span><br><span class="line">    ...</span><br><span class="line">    void process()&#123;</span><br><span class="line">        ...</span><br><span class="line">        processed_list.emplace_back(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">这里emplace_back会以this指针为参数去构建一个新的shared_ptr,而这个this指针很明显是一个野指针，也就是说，他会创建1个新的控制块，此时就像上面这种情况一样了，c++提供了enable_shared_from_this的玩意，使用起来如下：</span><br></pre></td></tr></table></figure>
<p>vector<Widget> processed_list{};<br>…<br>class Widget:public enable_shared_from_this<Widget>{<br>    …<br>    void process(){<br>        …<br>        processed_list.emplace_back(shared_from_this());<br>    }<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当当前的对象已经被1个shared_ptr管理时，shared_from_this这个成员函数就能创建1个新的shared_ptr对象，且使用已经存在的控制块，否则会报异常</span><br><span class="line">条款20当然就是讲智能指针剩下的weak_ptr了，这个也是第1次了解他，因为之前觉得那2个指针就够用了捏。他主要是配合shared_ptr使用，最主要的功能是判断所管理的对象是否已经析构，如下代码</span><br></pre></td></tr></table></figure>
<p>auto ptr1 = make_shared<int>(3);<br>weak_ptr<int> wptr(ptr1);<br>ptr1 = nullptr;<br>cout &lt;&lt;wptr.expired()&lt;&lt;endl;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面的代码wptr这一行并不会改变ptr1所管理的对象的引用计数，第2行之后，其引用计数仍然为1，在第3行后为0后便析构了,因此我们可以使用weak_ptr的expired函数判断，其指向的资源是否已经析构，上面的代码为输出1</span><br><span class="line">而我们往往会想利用这1特性，去做出1个若未析构则访问的操作，但很明显这个操作并不是线程安全的，因为他不是一个原子操作，假如他expired后发现未析构，而另外1个线程执行了上面第3行的类似的操作，则会有未定义的行为了</span><br><span class="line">weak_ptr提供了lock（）来实现这种原子操作，</span><br></pre></td></tr></table></figure>
<p>shared_ptr<int> ptr2 = wptr.lock();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果该资源已经析构，ptr2为空</span><br><span class="line">后面作者具体给出了使用weak_ptr了场景</span><br><span class="line">第1个就是在某些工厂函数中，他对相同的输入下标id会有相同的输出，为了提高性能，一个直接的想法是使用智能指针去管理资源，当之前已经创建过这个资源，就直接返回该资源，具体代码如下</span><br></pre></td></tr></table></figure>
<p>shared_ptr<const Widget> get_widget(int id){<br>    static unordered_map&lt;int, weak_ptr<Widget>&gt; cache;<br>    auto sptr = cache[id].lock();<br>    if(!sptr){<br>        //generate Widget for this id and use sptr to manage it<br>        cache[id] = weak_ptr<Widget>(sptr);<br>    }<br>    retrun sptr;<br>}<br>这里的返回类型并不能使用unique_ptr,因为一旦返回了，这个工厂函数内部的那个unique_ptr就为空了，因为返回值是通过移动构造去移动了资源的管理权<br>第2个就是在观察者设计模式中，这里具体等后面学设计模式再探讨吧！<br>最后1个就是1个小例子，假设a和c都使用shared_ptr指向b，此时想要让b也能指向a，该使用什么指针呢，很明显shared_ptr是不能使用的，他最大的缺点就是在这种环路引用上的循环问题，野指针也不行，若a析构了，b的野指针无法得知，后面就可能做出未定义行为了，所以最优的方式是使用weak_ptr,a是否析构b能感知到，且weak_ptr不会对引用计数有任何影响，更准确的说，是不会对控制块的第1个引用计数有影响，而是对其第2个引用计数有影响<br>条款21讲的是尽量使用make_shared和make_unique<br>在11的标准中，是只有前者而没有后者的，我们当然可以容易实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename ...Ts&gt;</span><br><span class="line">unique_ptr&lt;T&gt; make_unique(Ts&amp;&amp;... params)&#123;</span><br><span class="line">    return unique_ptr&lt;T&gt;(new T(forward&lt;Ts&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是创建了一个T的对象，利用万能引用和完美转发将参数传入其构造函数，并使用unique_ptr去管理并返回<br>到了14我们就有std的make_unique可以用了<br>下面作者给出了使用make系列函数的优势点<br>第1个是定义相关类型的时候，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Widget&gt; ptr1 (new Widget(params));</span><br><span class="line">auto ptr2 (make_unique&lt;Widget&gt;(params));</span><br></pre></td></tr></table></figure>
<p>作者认为这里，第1行使用了2次widget，将这个型别声明了2次，造成了代码冗余，导致源代码会增加编译次数<br>第2个优点在于异常安全，例如下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int calculate()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">void process(shared_ptr&lt;Widget&gt;, int priority)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">process(shared_ptr&lt;Widget&gt;(new Widget), calculate());</span><br></pre></td></tr></table></figure>
<p>这里编译器只能保证，在进入process的代码段之前，构建一个widget对象，构建1个shared_ptr并管理这个widget对象，调用calculate函数3者一定执行完毕，但这3者的顺序并没有指定，如果calculate发生在另外2着中间并且发生了异常，会导致new出来的widget并没有被析构而导致了内存泄漏，这个其实在effective第一本书里有讲，我们可以直接在process调用之前就构建这个shared_ptr对象，并在process的传参中使用move()语义，移动该资源，这样子就没有任何复制操作了，如果只是把这个对象按值传进去可是需要对引用计数进行原子操作的增加的。<br>而这里采用的是使用make_shared，因为这样子就能保证new出来的对象一定能被shared_ptr管理，就算calculate异常了也没关系<br>第3个是在性能上的提升，对于make_shared来说，他只会分配1次内存块，这个内存块就可以用来为widget和控制块分配内存，而传统的方式是需要分配2次内存块，分别给2着用<br>而make系列也不是完美的，在某些情况下他并不适用，比如说，他并不允许自定义删除器，只有一般方式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int,decltype(mydelete)&gt; ptr1(new int(2), mydelete);</span><br><span class="line">shared_ptr&lt;int&gt; ptr2(new int(3), mydelete);</span><br></pre></td></tr></table></figure>
<p>make系列的函数是做不到这一点的<br>还有1个就是他对大括号初始化的不支持如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto ptr = make_shared&lt;vector&lt;int&gt;&gt; (10,20);</span><br></pre></td></tr></table></figure>
<p>他在完美转发的时候是使用得当圆括号，也就是说调用的是非initializer_list形参的构造函数，上面的代码生成的是10个元素，每个元素都是20的vector的shared_ptr,但假如我们想用大括号初始的方式呢，就得这么做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;vector&lt;int&gt;&gt; ptr1 (new vector&lt;int&gt;&#123;10, 20&#125;);//传统方式</span><br><span class="line"></span><br><span class="line">auto ini_list = &#123;10, 20&#125;;</span><br><span class="line"></span><br><span class="line">auto ptr2 = make_shared&lt;vector&lt;int&gt;&gt;(ini_list);</span><br></pre></td></tr></table></figure>
<p>这样子，就能在完美转发的时候转发的是1个initializer_list形参，也就能调用相关的构造函数了</p>
<p>除了以上2个问题外，对于一些自定义了new和delete的类来说，因为他们通常分配的内存块大小都是等于1个类的大小的，而make系列分配的内存的大小还需要加上控制块的大小，此时使用make就不是1个好主意了<br>还有就是由于weak_ptr的存在，一个使用make系列函数分配的内存块，他内部有被管理资源的内存和控制块的内存，只有当和其相关的shared_ptr和weak_ptr都没有了的时候才会释放内存，而普通的构造方式下，只要shared_ptr没了，被管理资源就会被析构，此时的weak_ptr只会影响控制块的析构，</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-15</span><span class="leancloud_visitors"></span><span>About 2646 words, 8 min 49 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/14/effective-modern-c-16-18/">effective modern c ++ 16-18</a></h3></div><div class="post-content"><div class="card"><p><p>条款16讲的是对于const成员函数的线程安全性，<br>具体而言，const成员函数只能保证不去修改那些没被声明为mutable的成员数据，那也就是说，多个线程访问同一个const函数的时候，就可能会出现data race的情况了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Poly&#123;</span><br><span class="line">public:</span><br><span class="line">    using type = std::vector&lt;double&gt;;</span><br><span class="line">    type getroot()const&#123;</span><br><span class="line">        if(valid)&#123;</span><br><span class="line">            ... //计算并修改root</span><br><span class="line">        &#125;</span><br><span class="line">        valid = true;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    mutable bool valid&#123;false&#125;;</span><br><span class="line">    mutable type root&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码可能在多线程下有问题，此时我们需要施加锁上去</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Poly&#123;</span><br><span class="line">public:</span><br><span class="line">    using type = std::vector&lt;double&gt;;</span><br><span class="line">    type getroot()const&#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; l(lock);</span><br><span class="line">        if(valid)&#123;</span><br><span class="line">            ... //计算并修改root</span><br><span class="line">        </span><br><span class="line">        valid = true;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    mutable bool valid&#123;false&#125;;</span><br><span class="line">    mutable type root&#123;&#125;;</span><br><span class="line">    mutable std::mutex lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过由于mutex是不可复制的，这个类的复制行为也就应该被禁止了，不过他还是可以移动的<br>书中还指出，如果mutable的变量只有1个，比如说某个计数器，那么我们可以直接用atomic去表示他，就不用大费周章的用锁了（虽然atomic有时候还是锁的实现），但atomic同样是不可复制的，所以该类同样只能移动而不能复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    void dosth()const&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        //dosth....</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    mutable std::atomic&lt;int&gt; count&#123;0&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为原子变量保证count++的执行是原子的，所以不用担心多线程带来的不确定性<br>而如果需要2个以上的mutable变量，使用atomic去表示他们的策略不是明智的，例如上面的例子，如果修改root的过程是在valid后面，那么就可能发生这种情况-线程1读valid发现为false，于是计算，然后设置valid，此时线程2也使用了这个函数，发现valid是true，于是直接返回root了，但线程1还没有修改root呢，这种现象发生的原因在于修改2个原子变量的过程并不是原子的，所以我们就需要加1个互斥锁来保证修改2个原子变量这一大动作的原子性，那既然都要用互斥锁了，那还不如直接把2个mutable的声明为普通变量，反正有了锁就能保证原子性了<br>所以总结的说，使用const成员函数时，要确保对mutable变量的操作能是线程安全的，可以通过互斥锁或者原子变量去实现</p>
<p>条款17说的是各种生成构造函数和生成运算符的生成规则，<br>规则1.当没有声明任何构造函数时，会生成1个默认的无参构造函数<br>规则2.如果没有声明复制构造函数等，在使用的时候会自动生成需要的函数<br>上面2个规则是98时代的，在11，大家都知道引入了移动构造函数和移动运算符，而编译器自动生成的移动操作，会默认的去“移动”每一个成员变量，移动加双引号是因为这个移动是有前提的，如果成员变量本身无法移动的，例如int这种，他执行的是复制，如果这个成员提供了移动操作，才是真正的移动这个变量，而本质上是使用std::move去处理每一个变量，得到的右值如果这个成员本身有移动构造函数能处理这个右值，就是执行移动操作，否则只能使用这个变量的复制构造函数了，因为复制构造函数的形参都是const &amp;，所以能去引用1个右值，这里我们可以写个例子示范如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Movable&#123;</span><br><span class="line">public:</span><br><span class="line">    Movable()=default;</span><br><span class="line">    Movable(Movable &amp;&amp; rhs)&#123;cout&lt;&lt;&quot;movable class moving&quot;&lt;&lt;endl;&#125;</span><br><span class="line">    Movable(const Movable &amp; rhs)&#123;cout&lt;&lt;&quot;movable class copying&quot;&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Copyable&#123;</span><br><span class="line">public:</span><br><span class="line">    Copyable()=default;</span><br><span class="line">    Copyable(const Copyable &amp; rhs)&#123;cout &lt;&lt; &quot;coping class copy&quot; &lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    A(Movable m_,Copyable c_):m(m_),c(c_)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    Movable m;</span><br><span class="line">    Copyable c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Movable m;</span><br><span class="line">    Copyable c;</span><br><span class="line">    cout &lt;&lt;&quot;==&quot;&lt;&lt;endl;</span><br><span class="line">    A a(std::move(m),c);</span><br><span class="line">    cout &lt;&lt;&quot;==&quot;&lt;&lt;endl;</span><br><span class="line">    A b(std::move(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于复制构造函数和复制运算符，他们是独立的，声明一种不会导致说编译器不会去生成另一种，但移动的2个操作就不同了，如果声明了其中的一种，编译器则不会去生成另外1个了，因为他会认为既然你自己实现的移动构造函数与默认的按数据成员移动的方式不一样，那么默认的移动运算符必然也与之不同，那还不如不生成<br>进一步的，复制操作和移动操作，只要定义了其中的一方，编译器就不会去生成另一种操作了，因为既然声明了其中的1种，说明对于另外1种来说，其实现方式也很有可能与默认的方式不同，编译器就采用这种思想。<br>接下来提到的是一个大三律的东西：复制构造函数，复制运算符和析构函数，只要声明了其中的一种，就应该实现另外的2个，其思想在于，我们之所以会去刻意地定义他们，是因为某些类成员函数的复制方式不同于默认的复制方式，例如说某些指针型的，例如说和资源管理相关的，那么析构函数也必须处理如何析构这些资源<br>从这个定律推出来，如果有了用户声明的析构函数，就说明默认生成的复制操作是不合用户心意的，因此编译器不应该自动生成，不过98的时代这个思想没有被编译器采纳，但到了11，移动操作应用于这种思想导致了——一旦用户声明了析构函数，移动操作就不会被自动生成<br>所以结合以上内容，如果想要自动生成移动操作，需要：1.不能声明复制操作2.不能声明移动操作3.不能声明析构函数<br>接下来我们可以写一个类，这个类只有1个vector的成员，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.vec.push_back(2);</span><br><span class="line">    a.vec.push_back(3);</span><br><span class="line">    A c = move(a);</span><br><span class="line">    cout &lt;&lt;a.vec.size()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当没有声明析构函数的时候，最终a的vec的size是0，的确是有移动操作在里面，但假如声明一下析构，最终输出是2，说明移动构造函数的确没有自动生成，假如这个vec的内容很多，这个复制的时间必然是多于移动的，此时我们简单的加上A(A&amp;&amp;)=default即可<br>当然了，有时候我们声明析构函数，是因为需要某个类作为基类，必须得声明他的析构函数并且声明为虚函数提供多态的特性，此时我们可以在那些无法自动生成的移动操作加上=default，告诉编译器这个移动操作使用默认的生成式可以的<br>所以最后总结如下<br>• 默认构造函数：与 C++98 的机制相同。仅当类中不包含用户声明的构造函数时<br>才生成。<br>• 析构函数：与 C++98 的机制基本相同，唯 的区别在千析构函数默认为<br>noexcept （参见条款 14) 。与 C++98 的机制相同，仅当基类的析构函数为虚的，<br>派生类的析构函数才是虚的。<br>• 复制构造函数：运行期行为与 C++98 相同：按成员进行非静态数据成员的复制<br>构造。仅当类中不包含用户声明的复制构造函数时才生成。如果该类声明了移动<br>操作，则复制构造函数将被删除。在已经存在复制赋值运算符或析构函数的条件<br>下，仍然生成复制构造函数已经成为了被废弃的行为。<br>• 复制赋值运算符：运行期行为与 C++98 相同：按成员进行非静态数据成员的复<br>制赋值。仅当类中不包含用户声明的复制赋值运算符时才生成。如果该类声明了<br>移动操作，则复制构造函数将被删除。在已经存在复制构造函数或析构函数的条<br>件下，仍然生成复制赋值运算符已经成为了被废弃的行为。<br>• 移动构造函数和移动赋值运算符：都按成员进行非静态数据成员的移动操作。仅<br>当类中不包含用户声明的复制操作、移动操作和析构函数时才生成。</p>
<p>接下来进入的是第4大章，关于智能指针的使用<br>条款18讲的是unique_ptr<br>我们可以认为一个uniqueptr和野指针有几乎一样的尺寸，且他不能复制，因为本身他的实际应用场景就是管理专用型资源的，而且他的构造函数也使用了explicit修饰，不能使用隐式类型转换去构造如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int&gt; p1(new int(3));</span><br><span class="line">unique_ptr&lt;int&gt; p2 = new int(3);</span><br><span class="line">unique_ptr&lt;int&gt; p3&#123;nullptr&#125;;</span><br><span class="line">p3 = p1;</span><br><span class="line">p3 = move(p1);</span><br></pre></td></tr></table></figure>
<p>第1行是拿一个野指针做参数构造p1，行的通；但第2行是想执行1个隐式类型转换，把int*转换为unique_ptr<int>,这个是行不通的,而第4行自然也error，只有第5行才可以，此时p1的资源就给p3管理了<br>unique_ptr可以自定义删除器，而且必须得把第二个模板参数声明为这个删除器，所以不同删除器的同个管理对象的类型是不同的，这个shared_ptr就不是了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Investment&#123;</span><br><span class="line">public:</span><br><span class="line">     ...</span><br><span class="line">     virtual ~Investment()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Stock : public Investment&#123;...&#125;;</span><br><span class="line">class Bond: pulibc Investment&#123;...&#125;;</span><br><span class="line">auto MyDelete = [](Investment * ptr)&#123;dosth; delete ptr;&#125;</span><br><span class="line">template&lt;typename ...Ts&gt;</span><br><span class="line">unique_ptr&lt;Investment, decltype(MyDelete)&gt;</span><br><span class="line">func(Ts&amp;&amp;... params)&#123;</span><br><span class="line">    unique_ptr&lt;Investment,decltype(MyDelete)&gt;</span><br><span class="line">    p (nullptr,MyDelete);</span><br><span class="line">    if (/*need stock*/)&#123;</span><br><span class="line">        p.reset(new Stock(forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        p.reset(new Bond(forward&lt;Ts&gt;(params)));</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的注意点：<br>我们使用自定义的删除器，则需要指定unique_ptr的第2个模板实参，且在创建该对象时将删除器传入第二个参数<br>后面的赋值操作并不能通过=的方式，原因上面提到了，需要使用reset函数去转换其管理的对象<br>而使用了自定义的删除器后，如果我们用的删除器是函数指针，这个unique_ptr的尺寸就比一般的野指针要大了，因为它还要储存函数指针，而如果是无捕获的lambda表达式，作者说是不会浪费任何空间的，这里有待了解详情。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-14</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 2904 words, 9 min 40 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/14/effective-modern-c-13-15/">effective modern c ++ 13-15</a></h3></div><div class="post-content"><div class="card"><p><p>条款13介绍的是const_iterator，一开始一大段介绍了在98中实现一个const_iterator有多么困难，但到了11，一切都迎难而解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vec;</span><br><span class="line"></span><br><span class="line">auto it = std::find(vec.cbegin(),vec.cend(),13);</span><br><span class="line">vec.insert(it,16);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以使用cbegin()cend()来获取容器的const 迭代器，就算是对非const容器也一样，且insert函数他的第一个参数是const_iterator,这样子就满足他的要求了<br>除此之外有一点要注意的是，c++11提供了非成员函数的begin，end等函数，为的就是满足容器是数组的情况下的需求，但11并没有提供cbegin或者cend等const函数，我们无法在只依赖std库的情况下做到const遍历数组，因此我们可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">decltype(auto) cbegin(const T&amp; container)&#123;</span><br><span class="line">    return std::begin(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把传进来的容器用const修饰，那么我就能用他去获取cbegin了，当然这种多余的步骤在14的时候就没必要了，14的时候就引入了非成员的cbegin，cend等函数</p>
<p>条款14介绍的是关于异常和noexcept关键字，在11的标准里，一个函数要么可能发射异常，要么保证不会发射异常，如果能确保他不会发射异常，我们就应该加上noexcept关键字，有关异常的知识我也不是很了解，作者这里介绍说加上noexcept比其他方式优化更好也不是很理解，等后续补坑<br>接着是几个标准库里和异常相关的函数，最重要的就是push_back函数，当需要扩容时，原本的版本是强异常安全性的——直到所有元素都复制到了新的内存上，旧内存上的元素才会析构，如果中途抛出了异常，则没啥事；但如果为了优化复制转而使用移动，假设我们已经移动了一部分元素了，但此时抛出了异常，程序就处在一部分元素在新的内存，一部分在旧的内存，原有的状态已经没有了，如果想恢复到原来的状态转而把移动过的元素移动回去也可能异常，而11的很多函数的实现，为了解决这种麻烦，采取的是“能移动就移动，不能移动才复制”的策略，而判断移动是不是安全就看这个操作有没有noexcept，其中有一部分的函数，例如swap他是否异常安全，完全取决于用户自定义的操作是否带有noexcept，具体例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, size_t N&gt;</span><br><span class="line">void swap( T(&amp;a)(N), T(&amp;b)(N)) noexcept(noexcept(swap(*a,*b)));</span><br></pre></td></tr></table></figure>
<p>上述代码中，noexcept这种使用方式称为条件式noexcept，只有当括号内T的swap的操作，也就是对a这个数组的每一个元素都进行swap操作时时noexcept的，括号里的结果就为true，此时外层的swap就也是保证异常安全了的</p>
<p>条款15介绍的是constexpr关键字，他表示的变量必须是个常量，且必须在编译期就能确定下来具体是什么值，这个一个值可以用在声明数组长度，array的模板实参（长度）等必须在编译阶段就已知的常量值，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constexpr int len = 2;</span><br><span class="line">std::array&lt;int, len&gt; arr;</span><br></pre></td></tr></table></figure>
<p>而const修饰的，他并没有会在编译期就知道具体值的保证，所以并不能把他用在array这种模板形参上<br>constexpr还可以修饰函数，不过此时就有点复杂了，如果传入的实参是编译期就能确定的常量值，那他必须保证该函数也能在编译期得到对应的结果，但如果传入的参数有1个是直到运行期才知道结果的，此时的函数就和一般的函数一样了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constexpr int pow (int base, int numconds)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">constexpr auto numconds = 5;</span><br><span class="line">std::array&lt;int, pow(3,numconds)&gt; arr;</span><br></pre></td></tr></table></figure>
<p>以上代码可以通过，因为2个参数都是编译期就知的常量，因此pow也能在编译期返回具体的值了<br>而上面pow的….的具体实现与版本有关，在c++11下，constexpr函数最多只能有1条可执行语句，因此得这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return numconds=0? 1:base*pow(base,numconds-1);</span><br></pre></td></tr></table></figure>
<p>而在c++14下这个限制就放开了，可以按一般的for循环去实现了 </p>
<p>除了内置类型可以声明为constexpr外，我们自定义的类也可以将构造函数以及其他成员函数声明为constexpr，这样子就能在编译器完成相关的语句执行了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;&#125;</span><br><span class="line">    constexpr Point(double x_ = 0.0, double y_ = 0.0):x(x_),y(y_)&#123;&#125;</span><br><span class="line">    constexpr getx()&#123;return x;&#125;</span><br><span class="line">    constexpr gety()&#123;return y;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    double x,y;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">constexpr getmid(Point x1, Point x2)&#123;</span><br><span class="line">    return Point((x1.getx() + x2.getx()) / 2, (x1.gety() + x2.gety()) / 2);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    constexpr Point x1(5.3,2.3);</span><br><span class="line">    constexpr Point x2(2.2,34.2);</span><br><span class="line">    constexpr Point mid = getmid(x1,x2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的x1和x2都能在编译阶段都确定下来具体的值，mid也是</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-14</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 1346 words, 4 min 29 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/13/effective-modern-c-10-12/">effective modern c ++ 10-12</a></h3></div><div class="post-content"><div class="card"><p><p>条款10介绍的是enum的2种类型，一种是非限定作用域的enum，一种是限定作用域的enum，他们主要有以下几点不同<br>一是作用域的不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color&#123;White, Black&#125;;</span><br><span class="line">auto White = false;</span><br></pre></td></tr></table></figure>
<p>上面代码的第2行不能通过编译，因为这里的enum不带class，他的大括号里的内容的作用域会扩散出来，而下面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum class Color&#123;White, Black&#125;;</span><br><span class="line">auto White = false;</span><br><span class="line">Color c = Color::White;</span><br></pre></td></tr></table></figure>
<p>则不会，因为这里是限定作用域的enum,所以下面可以声明一个White<br>二是能否隐式转换的问题<br>非限定作用域的enum，他能转化为整数型别，甚至是浮点数，而限定作用域的则不可了，除非是static_cast去强制转换，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Color&#123;White, Black&#125;;</span><br><span class="line"></span><br><span class="line">void func(int c)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Color c = White;</span><br><span class="line">c &gt;= 2;</span><br><span class="line">func(c);</span><br></pre></td></tr></table></figure>
<p>上面这种代码比较诡异，为什么要拿枚举类的东西去和整数比较呢，没有啥意义，因此限定作用域的enum就禁止这种行为了<br>三是关于能否前置声明而不定义的问题<br>非限定枚举本来是能只声明的，但因为他的底层具体使用的数据类型是需要具体的枚举型别去确定，例如可能用char，也可能用int等，因此如果在后面，我们修改了他，整个系统就需要重新编译了<br>而限定枚举能直接声明不定义，因为他默认底层的数据类型就是int，而非限定则没有默认值，只要我们加上默认值，也可以只声明了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Color：int;</span><br></pre></td></tr></table></figure>

<p>条款11介绍了delete关键词的使用场景<br>最常见的是我们不想我们的对象能被复制，在98时直接把复制构造函数声明为private且不定义即可，到了11我们可以在后面加上=delete且放在public，<br>另外1个就是，任何函数都能使用delete，这个应用场景如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void func(int num);</span><br><span class="line">func(&#x27;a&#x27;);</span><br><span class="line">func(3.2);</span><br><span class="line">func(true);</span><br></pre></td></tr></table></figure>
<p>如上，我们期望的实参是个int，但却传入了一堆不相关的，但这是允许的，因为他们还勉强能转化为int，为了明确禁止这种行为，我们可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void func(int num);</span><br><span class="line">void func(double)=delete;</span><br><span class="line">void func(bool) =delete;</span><br><span class="line">void func(char)=delete;</span><br></pre></td></tr></table></figure>
<p>这样子上面的3行函数调用会使用被删除的重载版本，也就不能通过编译了<br>还有1种场景就是模板，我们希望当模板被某种类型的参数实例化时不能通过编译，比如说对指针类型T*,我们不希望void<em>和char</em>通过编译，前者因为他过于特殊，无法自增，自减，后者因为他通常是用来表示c的string，我们假定我们的模板不会处理这两种，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T* ptr)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">template&lt;&gt;</span><br><span class="line">void func&lt;char&gt;(char * ptr)=delete;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">void func&lt;void&gt;(void * ptr)=delete;</span><br></pre></td></tr></table></figure>

<p>条款12讲的是关于override的使用<br>其最重要的使用场景在于，关于虚函数的重载，他的要求十分严格，函数的签名必须一致，const必须一致，异常必须一致（noexcept），引用修饰词也必须一致（在函数签名后加&amp;或&amp;&amp;表示这个函数是给左值对象或者右值对象调用），那么很有可能因为这些限制，我们写出来的“虚函数”实际已经丢失了虚函数的特性，而编译器有可能没有给我们提出warning，因此这个时候就需要override了，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived:public Base&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func() override;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样子编译器发现override的函数如果有什么不一致会报错<br>这个条款的最后补充说明了引用修饰词的用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    using datatype = std::vector&lt;int&gt;;</span><br><span class="line">    datatype&amp; getdata() &amp;&#123; return values; &#125;</span><br><span class="line">    datatype getdata() &amp;&amp; &#123;return std::move(values);&#125;</span><br><span class="line">private:</span><br><span class="line">    datatype values;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A getA()&#123;</span><br><span class="line">    return A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码A这个类有2个不同的引用修饰词修饰的函数，当左值对象调用时，返回的是左值对象的左值引用，而当右值对象，例如getA()的返回值调用getData时，使用的是&amp;&amp;修饰的函数，因为临时对象本身就是要被析构的，最佳使用方式是移动他的资源，而不是复制，所以&amp;&amp;版本使用了move移动语义，而且他的返回值也不是一个左值引用了，而是一个临时值，是个右值</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 1230 words, 4 min 5 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/13/effective-modern-c-7-9/">effective modern c ++ 7-9</a></h3></div><div class="post-content"><div class="card"><p><p>条款7开始是第3章的内容，具体就是介绍了一些c+11新特性特别好用的地方<br>条款7介绍的是{}的优缺点，第1点好处就是他用来初始化时适合于所有情况，一般而言有4种初始化方式，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = 2;</span><br><span class="line">int x(2);</span><br><span class="line">int x = &#123;2&#125;;</span><br><span class="line">int x&#123;2&#125;;</span><br></pre></td></tr></table></figure>
<p>后面2种其实都是同1个，而如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;</span><br><span class="line">Widget w2 = w1;</span><br><span class="line">w1 = w2;</span><br></pre></td></tr></table></figure>
<p>这里的赋值并不是初始化，而是复制构造函数,最后的调用的也是赋值运算符的重载<br>大括号初始化的第1点优势在于可以用其初始化容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vec &#123;1,3,4&#125;;</span><br></pre></td></tr></table></figure>
<p>第2点是可以用来给非静态成员赋初始值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int x&#123;2&#125;;</span><br><span class="line">    int y = 0;</span><br><span class="line">    int z(0); //error! </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第3点是可以用来给不可复制的对象进行初始化，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;int&gt; x = 0; //error!!!</span><br><span class="line">std::atomic&lt;int&gt; y&#123;2&#125;;</span><br><span class="line">std::atomic&lt;int&gt; z(0);</span><br></pre></td></tr></table></figure>
<p>从2和3点可以看出，只有大括号初始化在这些情况下是可以通用的，所以说大括号是一种大一统初始化的方式<br>大括号还有1种特性，括号内是不能使用窄式类型转换的，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doube x, y, z;</span><br><span class="line">int sum1 &#123;x + y + z&#125;;</span><br></pre></td></tr></table></figure>
<p>上面不能确定double之和能不能用int表示</p>
<p>大括号的第4点好处是避免了很烦人的解析语法，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget w(10);</span><br><span class="line">Widget w;</span><br><span class="line">Widget w();//变成函数声明了</span><br><span class="line">Widget w&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面第3行本想用无参构造函数，结果却声明了一个返回值是Widget的无参函数，使用第4行的方式就能避免这种麻烦了<br>而使用{}的缺点在于类的构造函数的选择问题上，如果构造函数的型参有std::initializer_list且传进来的参数有机会匹配到（有机会包括进行窄式类型转换），那么他会直接忽略其他任何的构造函数，不管说这些构造函数会多匹配如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    A(int x_, double y_):x(x_), y(y_)&#123;&#125;</span><br><span class="line">    A(std::initializer_list&lt;bool&gt; list)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    int x;</span><br><span class="line">    double y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    A a&#123;10,0.5&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会报错，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: narrowing conversion of ‘10’ from ‘int’ to ‘bool’ inside &#123; &#125; [-Wnarrowing]</span><br></pre></td></tr></table></figure>
<p>虽然有一个完美符合a的构造函数，但因为编译器看到了能使用initializer_list的希望，他就直接忽视了其他构造函数了<br>甚至说以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Widget w&#123;w2&#125;;</span><br><span class="line">Widget w3&#123;std::move(w)&#125;;</span><br></pre></td></tr></table></figure>
<p>本来会使用复制构造函数和移动构造函数的，但如果有上述条件。他还是会调用initializer_list<br>只有当真的没办法匹配到这个initializer_list型参的构造函数的时候，其他构造函数才会成为候选<br>最后1个问题就是上面的无参构造函数了，在使用{}的时候表示的是无参，而不是没有元素的空的初始化列表，如果想表示后者，应该这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w&#123;&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>而（）和{}的区别，也导致说初始化容器的时候，可能会有意想不到的结果，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vec (10, 20);</span><br><span class="line">vector&lt;int&gt; vec2 &#123;10, 20&#125;;</span><br></pre></td></tr></table></figure>
<p>第1个是创建了一个元素都是20.共10个的vector，而第2个则是有2个元素，分别为10和20<br>这种接口作者认为是失败的</p>
<p>条款8则是介绍了nullptr这个特性，在没有他之前，我们想表示空指针需要使用0和NULL,但前者本质是一个int，不是一个指针，而NULL根据具体的实现不同而不同，但本质也是1个整形数据而不是1个指针，所以在下面的场景中，那个参数为void *的函数是永远不会被调用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func(int)&#123;&#125;</span><br><span class="line">void func(void *)&#123;&#125;</span><br><span class="line">void func(bool)&#123;&#125;</span><br><span class="line">func(0);</span><br><span class="line">func(NULL);</span><br></pre></td></tr></table></figure>
<p>NULL可能是由long实现的，可能带来歧义，但这里本质的问题在于传入的本意是个指针，结果却调用了非指针版本的矛盾<br>因此，nullptr登上了舞台，他不具备整型类型，永远不会像0和NULL一样被解释为一个整形，且他可以隐式转换为任何其他类型的指针，此时func(nullptr)调用的就是void *类型的func了<br>使用他的优点是在使用auto的场景下，到底一个变量是整数还是空指针，这个在有nullptr的情况下就很明了了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">auto func()</span><br><span class="line">-&gt;decltype(result)</span><br><span class="line">&#123;</span><br><span class="line">    if(result == nullptr)&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如这里的nullptr是0的话，auto就推导为int，但我们本意是拿result去和空指针比较，所以用上nullptr，result就一定是个指针了<br>既然说到了auto，那模板推导也必然受益于nullptr了<br>如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename P&gt;</span><br><span class="line">void func(T t, P ptr)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">func(3, 0);</span><br><span class="line">func(3, NULL);</span><br><span class="line">func(3, nullptr);</span><br></pre></td></tr></table></figure>
<p>上面前2个调用会使得P被推导为int或long的整型数据，只有使用nullptr才使得P被推导为指针类型</p>
<p>条款9讲的是using用来声明类型别名的优势<br>在不使用类型别名的时候，我们声明一个变量可能很痛苦，使用using就变简单多了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using MyType = std::unique_ptr&lt;std::unordered_map&lt;std::string,int&gt;&gt;;</span><br></pre></td></tr></table></figure>
<p>当然我们可以使用typedef去弄别名，在上面的场景和下面这种，2者没啥区别，最多是可读性上不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using fp = void(*)(int ,double);</span><br><span class="line">typedef void (*fp)(int, double);</span><br></pre></td></tr></table></figure>
<p>而using的优点在于模板的别名上，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">using MyList = std::list&lt;T,MyAlloc&lt;T&gt;&gt;; //MyAlloc是自定义的</span><br><span class="line">MyList&lt;int&gt; l1;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct MyList&#123;</span><br><span class="line">    typedef std::list&lt;T,MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">MyList&lt;int&gt;::type l2;</span><br></pre></td></tr></table></figure>
<p>可以看出使用using比typedef方便多了，不用说去弄个struct写了一堆，而且如果想用上面的这个类型去用做类模板，using同样更加方便</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class&#123;</span><br><span class="line">private:</span><br><span class="line">    typename MyList&lt;T&gt;::type list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class&#123;</span><br><span class="line">private:</span><br><span class="line">    MyList&lt;T&gt; list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第2种就是使用using的写法，第1种既要typename又要::type，比较麻烦</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 1580 words, 5 min 16 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/12/effective-modern-c-4-6/">effective modern c ++ 4-6</a></h3></div><div class="post-content"><div class="card"><p><p>条款4是教如何去获取类型推导结果的，第一种就是利用IDE去获取，第2种我们可以声明一个类模板但不去定义他，然后使用decltype(x)让编译器报错，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class TD;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"> const int x = 3;</span><br><span class="line"> TD&lt;decltype(x)&gt; xtype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时编译器报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: aggregate ‘TD&lt;const int&gt; xtype’ has incomplete type and cannot be defined</span><br><span class="line">  TD&lt;decltype(x)&gt; xtype;</span><br></pre></td></tr></table></figure>
<p>可以看到x的确被推导为const int<br>还有1种就是使用type_info,在大多数情况下他是正确的，但他推导的方式是安值推导的，也就是说，引用和常量性会被忽略，所以他并不可靠，</p>
<p>接下来是条款5，是开始了第2大章，关于auto的使用<br>条款5具体讲了一些应用auto带来的方便与好处<br>第1个就是在使用iterator的时候，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename It&gt;</span><br><span class="line">void func(It b, It e)&#123;</span><br><span class="line">    while(b!=e)&#123;</span><br><span class="line">        typename std::iterator_traits&lt;It&gt;::value_type</span><br><span class="line">        val = *b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这一段，我们使用萃取去获取这个迭代器到底指向啥东西，写起来十分的拗口麻烦，我们可以利用auto直接写成auto val = *b；<br>第2个就是使用auto来保证变量一定能初始化，解决变量未初始化的行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto i; // 不能通过</span><br><span class="line">auto i = 2;</span><br></pre></td></tr></table></figure>
<p>第3个就是使用lambda表达式时，这个lambda对象到底是个什么类型，这个是由编译器决定的，所以我们需要利用auto用来把lambda表达式赋值给某个变量名，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto lam = []()&#123; return 0; &#125;;</span><br></pre></td></tr></table></figure>
<p>当然我们也可以用一个std::function去持有这个lambda，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;bool(int,int)&gt;</span><br><span class="line">myfunc = [](int x, int y)&#123; return true;&#125;;</span><br></pre></td></tr></table></figure>
<p>而其缺点在于function本身就是一个对象，他本身就是需要内存的，在内存上来说auto来的更好，<br>第4个就是对于一些硬件依赖的typename，比如unsigned，在32位上和在64位上不同的，单单指定某个变量是unsigned可能会在不同机器上带来出乎意料的结果，因此我们可以利用auto</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto size = v.size();</span><br></pre></td></tr></table></figure>
<p>第5个还是在迭代的时候，我们对于一些容器他储存方式不熟悉带来的问题，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(const std::pair&lt;std::string, int&gt; &amp;p :m)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>m是个unorder_map,他本身是由std::pair&lt;const std::string, int&gt;组成的，不是上面这种方式，也就是说，程序跑到这段代码，会复制容器里的每一个元素，然后引用再去指向这些临时对象，可想而知多非时间，而使用auto很容易就解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for（const auto &amp;p:m)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，auto也是得看实际的使用场景，大多数情况下使用得当能提升我们编程的效率的<br>条款6 介绍的是使用auto可能遇到的坑，在这种时候就得采用传统的方式了<br>第1个，就是vector&lt;bool&gt;这个和其他vector格格不入的对象，对于一般的vector&lt;T&gt;[],他能返回一个T&amp;类型的东西，但vector&lt;bool&gt;他本身是特化过的，他底层是使用比特去表示这1个1个的bool，而c++又不能返回1个对比特的引用，所以他只能返回一个用来模拟bool&amp;的reference，即std::vector&lt;bool&gt;::reference,他能够像bool进行隐式转换，所以对下面语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector\&lt;bool&gt; vec&#123;true,true&#125;;</span><br><span class="line">bool is_true = vec[0];</span><br></pre></td></tr></table></figure>
<p>这里取出来的vec[0]实际是个std::vector&lt;bool&gt;::reference，但他可以转换为bool，所以没啥问题<br>但假如我们使用auto去声明is_true,得到他类型就是std::vector<bool>::reference了，他就不是指代第1个元素是否为true的变量了<br>书里介绍的这种情况带来的问题在于可能出现悬空指针，例如，当我们函数的返回值是个vector<bool>时，他是个临时对象，而他实现获取第1个元素的方式，有一种实现是通过指针+偏移量的方式去获取，而我们如果使用auto is_true = bool_vectroy()[0]时，is_true和临时对象的指针指向同一个东西，而临时对象在这一句话后就解析了，那is_true就指向1个被析构了的地址了，</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 1156 words, 3 min 51 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/12/effective-modern-c-1-3/">effective modern c ++ 1-3</a></h3></div><div class="post-content"><div class="card"><p><p>条款1是对模板参数推导的几个细则，具体以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void func(ParamType param)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用func(expr)去调用时，它会推导T和param的形别，这2种有的时候是一样的，有的时候由于常量这些标识而不同，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void func(const T&amp; param)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在使用一个int 变量i去调用func时，T是iNT,而PARAMTYPE是const int&amp;<br>具体则分三种情况去讨论<br>第1种是paramtype是一个非万能引用，此时的判断方法是：如果expr具有引用，把引用给忽略，然后再去推导，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void func(T&amp; param)&#123;&#125;</span><br><span class="line"></span><br><span class="line">int x = 2;</span><br><span class="line">const int cx = x;</span><br><span class="line">const int&amp; rx = x;</span><br></pre></td></tr></table></figure>
<p>那么在调用func的时候，对x，T是int，paramtype是int&amp;，而后面2个T是const int，而paramtype是const int&amp;，因为第3个expr的引用是会被忽略的，这里也可以看出，持有T&amp;的模板，它能保证传进来的对量的常量性能被捕获<br>第2种是paramtype是一个万能引用，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T&amp;&amp; param)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候就使用引用折叠，可知如果传进来的expr是左值，T和paramtype都会推导为左值引用，如果expr是右值，则根据1的规矩即可</p>
<p>第3种情况就是paramtype不是引用，那么就是说函数是按值传参的，他复制了一个新的对象，此时他对expr，会忽视他的const，volatile和引用，所以对上面的，x，cx，rx，如果模板声明如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T param)</span><br></pre></td></tr></table></figure>
<p>那么T和paramtype最终都是int，这个也是可以理解的——本身传进来后我是构建的新的对象，不会对外面的一切造成干扰<br>这里还有1种特殊情况，即指向常量的常量指针，const int * const ptr,那么传进来之后，<em>右边的const会被忽略，因为传进来的本质是1个地址，这个值就像前面那个const int一样，所以他就被忽略了，那么进来后，T会被推导为const int</em>，指向常量的指针<br>最后就是关于数组的问题了，这里直接结论如下：<br>当paramtype是T param时，数组形参会退化为1个指针例如<br>template<typename T><br>void func(T param)<br>const char name[] = “22”;<br>此时把name传进来时，T会推导为const char*<br>但假如paramtype是个引用，T则会推导为const char[3],而paramtype则是cost char（&amp;）[13]<br>我们可以用这一特性去推导数组长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, int N&gt;</span><br><span class="line">constexpr int getlen(T(&amp;)[N]) noexcept&#123;</span><br><span class="line">    return N;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"> int x[2] = &#123;2,3&#125;;</span><br><span class="line"> char y[getlen(x)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条款2是auto推导的规则，他的规则上和模板推导的基本一致，但有一点很特别，在使用c++11引入的初始化方式中，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto x&#123;3&#125;;</span><br><span class="line">auto x=&#123;3&#125;;</span><br></pre></td></tr></table></figure>
<p>此时auto推导型别会推导出std:: initializer_list<int>，且其中只有1个元素的变量，所以如下代码编译是会失败的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto y&#123;2,3,3.0&#125;;</span><br></pre></td></tr></table></figure>
<p>因为对std:: initializer_list<T>的T推导不出是什么<br>这里的本质是有2次推导，第1个是推导出y的型别为std:: initializer_list（因为使用了大括号去初始化），第2次是推导std:: initializer_list<T>的T的类型，而如果我们想利用模板去实现这一点是做不到的，因为auto他本身对大括号初始化就假定了第1次推导必定是std:: initializer_list，而模板没办法，所以如果真要用模板，可以这么实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(std:: initializer_list&lt;T&gt; list);</span><br></pre></td></tr></table></figure>
<p>对于func({2,3,3})的调用，上面模板就起效了<br>最后还补充了1点，在c++14的标准中，可以单独用auto去说明函数返回值/lambda表达式的形参需要推导，但此时他是使用模板推导去推导的，所以说返回值不能使用大括号</p>
<p>条款3是decltype的使用<br>一般的，对于大多数std的容器，其[]的使用会返回对应位置的元素的引用，除了vector<bool>以外，<br>而在c++14中，正如在条款2中提到的，我们可以只使用auto不加decltype去推导返回值类型，此时使用的是模板类型的推导，那以下代码就有问题了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename container, typename index&gt;</span><br><span class="line">auto getindex(container &amp; c,index i)&#123;</span><br><span class="line">    return c[i];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"> std::vector&lt;int&gt; vec &#123;3,4,4&#125;;</span><br><span class="line"> getindex(vec,2) = 10;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>上面的代码执行如下：首先这里采用的是模板推导，且auto没有&amp;或者&amp;&amp;的修饰，即采用条款1种的第3种规则，此时型参的一切引用都会被忽略，即c[i]返回的int&amp;被看成是int，那么T和paramtype就是int了，此时返回的是1个临时值，是个右值，不能放在等号左侧，所以很明显他会报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: lvalue required as left operand of assignment</span><br><span class="line">  getindex(vec,2) = 10;</span><br></pre></td></tr></table></figure>
<p>解决方法是把auto改成decltype（auto），告诉他说推导过程用的是decltype的规则，而他对于int&amp;就是推导为int&amp;，或者我们直接使用后置类型推导，也比较清晰<br>那这里还有1个不完美的在于，getindex他只能接受1个左值容器，对于一些右值容器，比如说一些工厂函数的返回值，我们直接传入，此时需要用万能引用和完美转发去解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename container, typename index&gt;</span><br><span class="line">decltype(auto) func(container &amp;&amp; c, index i)&#123;</span><br><span class="line">    return std::forward&lt;container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，decltype还有一个坑，如果decltype（sth），sth仅仅只是1个变量名，如x，一切如旧；但假如sth是(x),c++仍把他看做是左值表达式，此时decltype必须推导出是一个引用类型，那么对下列代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">decltype(auto) func()&#123;</span><br><span class="line">    int x = 2;</span><br><span class="line">    return (x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他会返回1个局部变量的引用，这是一个危险的未定义行为，所以使用decltype一定要小心，里面的东西到底是什么</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/effective-modern-c/" title="effective_modern_c++">effective_modern_c++ </a><span class="leancloud_visitors"></span><span>About 1615 words, 5 min 23 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/09/09/leveldb%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%971-skiplist/">leveldb源码系列1-skiplist</a></h3></div><div class="post-content"><div class="card"><p><p>本文分析的是leveldb中的跳表skip list的实现，他会把user key和user value打包成一个更大的key塞入list中<br>跳表的一个例子如下图</p>
<p>可以看到，每一个node，它都有不同的高度，且每个节点都在第0层都有出现，第0层就像最简单的链表一样，而到了上面的层数节点的个数越来越少，就像树状结构那种，跳表的许多操作都能在logn的复杂度下完成，<br>leveldb的主要结构包括skiplist，内部是由一系列的node构成的，他还实现了一个iterator用于遍历<br>接下来首先看node的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">struct SkipList&lt;Key, Comparator&gt;::Node &#123;</span><br><span class="line">  explicit Node(const Key&amp; k) : key(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Key const key;</span><br><span class="line"></span><br><span class="line">  // Accessors/mutators for links.  Wrapped in methods so we can</span><br><span class="line">  // add the appropriate barriers as necessary.</span><br><span class="line">  Node* Next(int n) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    // Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span><br><span class="line">    // version of the returned Node.</span><br><span class="line">    return next_[n].load(std::memory_order_acquire);</span><br><span class="line">  &#125;</span><br><span class="line">  void SetNext(int n, Node* x) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    // Use a &#x27;release store&#x27; so that anybody who reads through this</span><br><span class="line">    // pointer observes a fully initialized version of the inserted node.</span><br><span class="line">    next_[n].store(x, std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // No-barrier variants that can be safely used in a few locations.</span><br><span class="line">  Node* NoBarrier_Next(int n) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    return next_[n].load(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  void NoBarrier_SetNext(int n, Node* x) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    next_[n].store(x, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">   private:</span><br><span class="line">  // Array of length equal to the node height.  next_[0] is lowest level link.</span><br><span class="line">  // 1) 这里提前声明并申请了一个内存，用于存储第 0 层的数据，因为第 0 层必然存在数据。</span><br><span class="line">  // 2) 这里的数组长度其实就是层高，假设 next_ 长度为 n，那么就会从 next_[n-1] 开始查找。</span><br><span class="line">  // 3) 因为 skip list 的 level 并不会太大，使用数组存储 Node 指针的话对 CPU 内存更友好</span><br><span class="line">  // https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf</span><br><span class="line">  std::atomic&lt;Node*&gt; next_[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一部分主要是1个显式的构造函数，指定某个键并初始化key这个成员数据，然后是他的next_数组，这个数组主要是用来存放该结点的每一层的next结点的指针的，指定为1是因为必然要在第0层有该结点，接下来是他的2个无锁操作和2个不用内存屏障的操作，next这个无锁操作使用了next_这个原子对象的load函数，且指定了memory_order_acquire,那么在这个语句之前的都不会被重排到他后面了，而setnext则是store函数，指定了memory_order_release，则该语句后面的内容都不会重排到他前面去，<br>后面的2个则是使用了memory_order_relaxed,他只保证这条语句他是原子的，语句前后怎么重排都没有限制<br>接下来是一个生成新结点的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::NewNode(</span><br><span class="line">    const Key&amp; key, int height) &#123;</span><br><span class="line">  // 内存分配时只需要再分配 level - 1 层，因为第 0 层已经预先分配完毕了。</span><br><span class="line">  char* const node_memory = arena_-&gt;AllocateAligned(</span><br><span class="line">      sizeof(Node) + sizeof(std::atomic&lt;Node*&gt;) * (height - 1));</span><br><span class="line">  // 这里是 placement new 的写法，在现有的内存上进行 new object</span><br><span class="line">  return new (node_memory) Node(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2行开头的typename是为了告诉编译器，后面这个::Node是一个类型，那么整个函数的返回值就是NOde*了，首先分配内存，然后在这个内存上placement new，调用node的构造函数了</p>
<p>接下来是skiplist的成员函数<br>第一个是生成随机层数的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">int SkipList&lt;Key, Comparator&gt;::RandomHeight() &#123;</span><br><span class="line">  // Increase height with probability 1 in kBranching</span><br><span class="line">  static const unsigned int kBranching = 4;</span><br><span class="line">  int height = 1;</span><br><span class="line">  while (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == 0)) &#123;</span><br><span class="line">    height++;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(height &gt; 0);</span><br><span class="line">  assert(height &lt;= kMaxHeight);</span><br><span class="line">  return height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先初始化height为1，接着以1/4的概率使得while成立（在height比kmaxheight小的情况下），这样子第1层的node个数就大致是第0的1/4了，后面的层数以此类推，而用1/4这个概率貌似也是提出跳表的论文中建议的？<br>接下来是一个key的大小顺序的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">bool SkipList&lt;Key, Comparator&gt;::KeyIsAfterNode(const Key&amp; key, Node* n) const &#123;</span><br><span class="line">  // null n is considered infinite</span><br><span class="line">  return (n != nullptr) &amp;&amp; (compare_(n-&gt;key, key) &lt; 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当要比较的对象（比如说是next节点指向的某一层对象）不为空且compare比较器得到的结果小于0时，说明这个key在顺序上是在n后面的，</p>
<p>接下来就是查找在每一层上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(const Key&amp; key,</span><br><span class="line">                                              Node** prev) const &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  int level = GetMaxHeight() - 1;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    /* 获取当前 level 层的下一个节点 */</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line"></span><br><span class="line">    if (KeyIsAfterNode(key, next)) &#123;</span><br><span class="line">      // Keep searching in this list</span><br><span class="line">      x = next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // prev 数组主要记录的就是每一层的 prev 节点，主要用于插入和删除时使用</span><br><span class="line">      if (prev != nullptr) prev[level] = x;</span><br><span class="line">      if (level == 0) &#123;</span><br><span class="line">        return next;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // Switch to next list</span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的GetMaxHeight函数获取的是当前结点的层数，我们从这个节点的最高层开始找，不断获取他的next节点，判断这个node他</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-09-09</span><i class="fa fa-tag"></i><a class="tag" href="/tags/leveldb/" title="leveldb">leveldb </a><span class="leancloud_visitors"></span><span>About 1319 words, 4 min 23 sec  read</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">Next</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>